
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: number
  auth0Id: string
  email: string
  phone: string | null
  firstName: string | null
  lastName: string | null
  active: boolean
  lastActive: Date
  created: Date
  updated: Date
}

/**
 * Model Claimant
 * 
 */
export type Claimant = {
  id: number
  firstName: string | null
  middleName: string | null
  lastName: string | null
  phone: string | null
  email: string | null
  referrerId: number | null
  ssaStatusId: number | null
  created: Date
  updated: Date
}

/**
 * Model CallSession
 * 
 */
export type CallSession = {
  id: number
  userId: number
  claimantId: number
  sessionType: SessionTypes
  sessionStatus: SessionStatuses | null
  created: Date
  ended: Date | null
  updated: Date
  recordingUrl: string | null
  outgoingPhone: string
}

/**
 * Model VoiceMail
 * 
 */
export type VoiceMail = {
  id: number
  claimantId: number | null
  created: Date
  updated: Date
  recordingUrl: string | null
  transcription: string | null
}

/**
 * Model Form
 * 
 */
export type Form = {
  id: number
  name: string
  description: string | null
  created: Date
  updated: Date
}

/**
 * Model FormSection
 * 
 */
export type FormSection = {
  id: number
  formId: number
  name: string
  order: number
  showTimer: boolean
  created: Date
  updated: Date
}

/**
 * Model Question
 * 
 */
export type Question = {
  id: number
  formSectionId: number
  question: string
  questionType: QuestionType
  inputType: InputType | null
  order: number
  scriptText: string
  optout: boolean
  optoutText: string
  created: Date
  updated: Date
}

/**
 * Model Answer
 * 
 */
export type Answer = {
  id: number
  questionId: number
  claimantId: number
  sessionId: number
  optionId: number | null
  value: string | null
  created: Date
  updated: Date
}

/**
 * Model Subform
 * 
 */
export type Subform = {
  id: number
  questionId: number
  name: string
  created: Date
  updated: Date
}

/**
 * Model SubformField
 * 
 */
export type SubformField = {
  id: number
  subformId: number
  fieldType: SubFormFieldType
  inputType: InputType | null
  max: number | null
  name: string
  label: string
  required: boolean
  created: Date
  updated: Date
}

/**
 * Model SubformFieldOption
 * 
 */
export type SubformFieldOption = {
  id: number
  subformFieldId: number
  label: string
  value: string
  created: Date
  updated: Date
}

/**
 * Model SubformFieldAnswer
 * 
 */
export type SubformFieldAnswer = {
  id: number
  subformFieldId: number
  claimantId: number
  sessionId: number
  value: string | null
  optionId: number | null
  created: Date
  updated: Date
}

/**
 * Model Cursor
 * 
 */
export type Cursor = {
  id: number
  formSectionId: number
  questionId: number
  claimantId: number
  created: Date
  updatedAt: Date
}

/**
 * Model Option
 * 
 */
export type Option = {
  id: number
  questionId: number
  label: string
  value: string
  created: Date
  updatedAt: Date
}

/**
 * Model OptionRule
 * 
 */
export type OptionRule = {
  id: number
  optionId: number | null
  type: RuleType
  value: number | null
  operator: OperatorOption | null
  comparisonValue: string | null
  functionId: number | null
  questionAnswerRefId: number | null
  ssaStatusId: number | null
  isReferrerPayType: ReferrerPayTypes | null
  created: Date
  updated: Date
}

/**
 * Model QuestionRule
 * 
 */
export type QuestionRule = {
  id: number
  questionId: number | null
  optout: boolean | null
  type: RuleType
  value: number | null
  operator: OperatorOption | null
  comparisonValue: string | null
  functionId: number | null
  questionAnswerRefId: number | null
  ssaStatusId: number | null
  isReferrerPayType: ReferrerPayTypes | null
  created: Date
  updated: Date
}

/**
 * Model QuestionFormatRule
 * 
 */
export type QuestionFormatRule = {
  id: number
  questionId: number | null
  type: QuestionFormatTypes
  questionAnswerRefId: number | null
  claimantField: ClaimantFieldRefTypes | null
  created: Date
  updated: Date
}

/**
 * Model Function
 * 
 */
export type Function = {
  id: number
  name: string
  function: string
  created: Date
  updated: Date
}

/**
 * Model TouchPoint
 * 
 */
export type TouchPoint = {
  id: number
  claimantId: number
  type: TouchPointType
  created: Date
  updated: Date
}

/**
 * Model Referrer
 * 
 */
export type Referrer = {
  id: number
  name: string
  type: ReferrerTypes
  payType: ReferrerPayTypes
  preIntakeTimer: number
  created: Date
  updated: Date
}

/**
 * Model SSAStatus
 * 
 */
export type SSAStatus = {
  id: number
  name: string
  created: Date
  updated: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const ClaimantFieldRefTypes: {
  PHONE: 'PHONE',
  FIRST_NAME: 'FIRST_NAME',
  LAST_NAME: 'LAST_NAME',
  MIDDLE_NAME: 'MIDDLE_NAME',
  EMAIL: 'EMAIL'
};

export type ClaimantFieldRefTypes = (typeof ClaimantFieldRefTypes)[keyof typeof ClaimantFieldRefTypes]


export const InputType: {
  TEXT: 'TEXT',
  NUMBER: 'NUMBER',
  EMAIL: 'EMAIL',
  DATE: 'DATE',
  MONTH: 'MONTH',
  TEL: 'TEL',
  ADDRESS: 'ADDRESS',
  SSN: 'SSN'
};

export type InputType = (typeof InputType)[keyof typeof InputType]


export const OperatorOption: {
  GT: 'GT',
  LT: 'LT',
  EQUALS: 'EQUALS',
  GTE: 'GTE',
  LTE: 'LTE'
};

export type OperatorOption = (typeof OperatorOption)[keyof typeof OperatorOption]


export const QuestionFormatTypes: {
  VERIFICATION: 'VERIFICATION'
};

export type QuestionFormatTypes = (typeof QuestionFormatTypes)[keyof typeof QuestionFormatTypes]


export const QuestionType: {
  BOOLEAN: 'BOOLEAN',
  TEXT_INPUT: 'TEXT_INPUT',
  MULTIPLE_CHOICE: 'MULTIPLE_CHOICE',
  MULTI_SELECT: 'MULTI_SELECT',
  SUBFORM: 'SUBFORM'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]


export const ReferrerPayTypes: {
  PAID: 'PAID',
  PAID_TIMER: 'PAID_TIMER',
  PAID_ACCEPTED: 'PAID_ACCEPTED'
};

export type ReferrerPayTypes = (typeof ReferrerPayTypes)[keyof typeof ReferrerPayTypes]


export const ReferrerTypes: {
  LEAD: 'LEAD',
  PHONE: 'PHONE'
};

export type ReferrerTypes = (typeof ReferrerTypes)[keyof typeof ReferrerTypes]


export const RuleType: {
  TERMINATE: 'TERMINATE',
  QUESTION: 'QUESTION',
  FORM: 'FORM',
  SSA_STATUS: 'SSA_STATUS'
};

export type RuleType = (typeof RuleType)[keyof typeof RuleType]


export const SessionStatuses: {
  DID_NOT_ANSWER: 'DID_NOT_ANSWER',
  CONSULTATION_STARTED: 'CONSULTATION_STARTED',
  CONSULTATION_TERMINATED: 'CONSULTATION_TERMINATED',
  CONSULTATION_COMPLETD: 'CONSULTATION_COMPLETD'
};

export type SessionStatuses = (typeof SessionStatuses)[keyof typeof SessionStatuses]


export const SessionTypes: {
  INBOUND: 'INBOUND',
  OUTBOUND: 'OUTBOUND'
};

export type SessionTypes = (typeof SessionTypes)[keyof typeof SessionTypes]


export const SubFormFieldType: {
  INPUT: 'INPUT',
  SELECT: 'SELECT',
  RADIO: 'RADIO',
  CHECKBOX: 'CHECKBOX',
  TEXTAREA: 'TEXTAREA',
  ADDRESS: 'ADDRESS'
};

export type SubFormFieldType = (typeof SubFormFieldType)[keyof typeof SubFormFieldType]


export const TouchPointType: {
  CALL: 'CALL',
  EMAIL: 'EMAIL',
  TEXT: 'TEXT'
};

export type TouchPointType = (typeof TouchPointType)[keyof typeof TouchPointType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: {maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel}): Promise<R>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.claimant`: Exposes CRUD operations for the **Claimant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Claimants
    * const claimants = await prisma.claimant.findMany()
    * ```
    */
  get claimant(): Prisma.ClaimantDelegate<GlobalReject>;

  /**
   * `prisma.callSession`: Exposes CRUD operations for the **CallSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallSessions
    * const callSessions = await prisma.callSession.findMany()
    * ```
    */
  get callSession(): Prisma.CallSessionDelegate<GlobalReject>;

  /**
   * `prisma.voiceMail`: Exposes CRUD operations for the **VoiceMail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoiceMails
    * const voiceMails = await prisma.voiceMail.findMany()
    * ```
    */
  get voiceMail(): Prisma.VoiceMailDelegate<GlobalReject>;

  /**
   * `prisma.form`: Exposes CRUD operations for the **Form** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Forms
    * const forms = await prisma.form.findMany()
    * ```
    */
  get form(): Prisma.FormDelegate<GlobalReject>;

  /**
   * `prisma.formSection`: Exposes CRUD operations for the **FormSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormSections
    * const formSections = await prisma.formSection.findMany()
    * ```
    */
  get formSection(): Prisma.FormSectionDelegate<GlobalReject>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<GlobalReject>;

  /**
   * `prisma.answer`: Exposes CRUD operations for the **Answer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answer.findMany()
    * ```
    */
  get answer(): Prisma.AnswerDelegate<GlobalReject>;

  /**
   * `prisma.subform`: Exposes CRUD operations for the **Subform** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subforms
    * const subforms = await prisma.subform.findMany()
    * ```
    */
  get subform(): Prisma.SubformDelegate<GlobalReject>;

  /**
   * `prisma.subformField`: Exposes CRUD operations for the **SubformField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubformFields
    * const subformFields = await prisma.subformField.findMany()
    * ```
    */
  get subformField(): Prisma.SubformFieldDelegate<GlobalReject>;

  /**
   * `prisma.subformFieldOption`: Exposes CRUD operations for the **SubformFieldOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubformFieldOptions
    * const subformFieldOptions = await prisma.subformFieldOption.findMany()
    * ```
    */
  get subformFieldOption(): Prisma.SubformFieldOptionDelegate<GlobalReject>;

  /**
   * `prisma.subformFieldAnswer`: Exposes CRUD operations for the **SubformFieldAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubformFieldAnswers
    * const subformFieldAnswers = await prisma.subformFieldAnswer.findMany()
    * ```
    */
  get subformFieldAnswer(): Prisma.SubformFieldAnswerDelegate<GlobalReject>;

  /**
   * `prisma.cursor`: Exposes CRUD operations for the **Cursor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cursors
    * const cursors = await prisma.cursor.findMany()
    * ```
    */
  get cursor(): Prisma.CursorDelegate<GlobalReject>;

  /**
   * `prisma.option`: Exposes CRUD operations for the **Option** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Options
    * const options = await prisma.option.findMany()
    * ```
    */
  get option(): Prisma.OptionDelegate<GlobalReject>;

  /**
   * `prisma.optionRule`: Exposes CRUD operations for the **OptionRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OptionRules
    * const optionRules = await prisma.optionRule.findMany()
    * ```
    */
  get optionRule(): Prisma.OptionRuleDelegate<GlobalReject>;

  /**
   * `prisma.questionRule`: Exposes CRUD operations for the **QuestionRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionRules
    * const questionRules = await prisma.questionRule.findMany()
    * ```
    */
  get questionRule(): Prisma.QuestionRuleDelegate<GlobalReject>;

  /**
   * `prisma.questionFormatRule`: Exposes CRUD operations for the **QuestionFormatRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionFormatRules
    * const questionFormatRules = await prisma.questionFormatRule.findMany()
    * ```
    */
  get questionFormatRule(): Prisma.QuestionFormatRuleDelegate<GlobalReject>;

  /**
   * `prisma.function`: Exposes CRUD operations for the **Function** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Functions
    * const functions = await prisma.function.findMany()
    * ```
    */
  get function(): Prisma.FunctionDelegate<GlobalReject>;

  /**
   * `prisma.touchPoint`: Exposes CRUD operations for the **TouchPoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TouchPoints
    * const touchPoints = await prisma.touchPoint.findMany()
    * ```
    */
  get touchPoint(): Prisma.TouchPointDelegate<GlobalReject>;

  /**
   * `prisma.referrer`: Exposes CRUD operations for the **Referrer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrers
    * const referrers = await prisma.referrer.findMany()
    * ```
    */
  get referrer(): Prisma.ReferrerDelegate<GlobalReject>;

  /**
   * `prisma.sSAStatus`: Exposes CRUD operations for the **SSAStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SSAStatuses
    * const sSAStatuses = await prisma.sSAStatus.findMany()
    * ```
    */
  get sSAStatus(): Prisma.SSAStatusDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.7.1
   * Query Engine version: 272861e07ab64f234d3ffc4094e32bd61775599c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Claimant: 'Claimant',
    CallSession: 'CallSession',
    VoiceMail: 'VoiceMail',
    Form: 'Form',
    FormSection: 'FormSection',
    Question: 'Question',
    Answer: 'Answer',
    Subform: 'Subform',
    SubformField: 'SubformField',
    SubformFieldOption: 'SubformFieldOption',
    SubformFieldAnswer: 'SubformFieldAnswer',
    Cursor: 'Cursor',
    Option: 'Option',
    OptionRule: 'OptionRule',
    QuestionRule: 'QuestionRule',
    QuestionFormatRule: 'QuestionFormatRule',
    Function: 'Function',
    TouchPoint: 'TouchPoint',
    Referrer: 'Referrer',
    SSAStatus: 'SSAStatus'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    callSessions: number
  }

  export type UserCountOutputTypeSelect = {
    callSessions?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type ClaimantCountOutputType
   */


  export type ClaimantCountOutputType = {
    cursor: number
    answers: number
    touchPoint: number
    callSessions: number
    subformFieldAnswer: number
    VoiceMail: number
  }

  export type ClaimantCountOutputTypeSelect = {
    cursor?: boolean
    answers?: boolean
    touchPoint?: boolean
    callSessions?: boolean
    subformFieldAnswer?: boolean
    VoiceMail?: boolean
  }

  export type ClaimantCountOutputTypeGetPayload<S extends boolean | null | undefined | ClaimantCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ClaimantCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ClaimantCountOutputTypeArgs)
    ? ClaimantCountOutputType 
    : S extends { select: any } & (ClaimantCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ClaimantCountOutputType ? ClaimantCountOutputType[P] : never
  } 
      : ClaimantCountOutputType




  // Custom InputTypes

  /**
   * ClaimantCountOutputType without action
   */
  export type ClaimantCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ClaimantCountOutputType
     * 
    **/
    select?: ClaimantCountOutputTypeSelect | null
  }



  /**
   * Count Type CallSessionCountOutputType
   */


  export type CallSessionCountOutputType = {
    answer: number
    subformFieldAnswer: number
  }

  export type CallSessionCountOutputTypeSelect = {
    answer?: boolean
    subformFieldAnswer?: boolean
  }

  export type CallSessionCountOutputTypeGetPayload<S extends boolean | null | undefined | CallSessionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CallSessionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CallSessionCountOutputTypeArgs)
    ? CallSessionCountOutputType 
    : S extends { select: any } & (CallSessionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CallSessionCountOutputType ? CallSessionCountOutputType[P] : never
  } 
      : CallSessionCountOutputType




  // Custom InputTypes

  /**
   * CallSessionCountOutputType without action
   */
  export type CallSessionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CallSessionCountOutputType
     * 
    **/
    select?: CallSessionCountOutputTypeSelect | null
  }



  /**
   * Count Type FormCountOutputType
   */


  export type FormCountOutputType = {
    formSection: number
  }

  export type FormCountOutputTypeSelect = {
    formSection?: boolean
  }

  export type FormCountOutputTypeGetPayload<S extends boolean | null | undefined | FormCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FormCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FormCountOutputTypeArgs)
    ? FormCountOutputType 
    : S extends { select: any } & (FormCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FormCountOutputType ? FormCountOutputType[P] : never
  } 
      : FormCountOutputType




  // Custom InputTypes

  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FormCountOutputType
     * 
    **/
    select?: FormCountOutputTypeSelect | null
  }



  /**
   * Count Type FormSectionCountOutputType
   */


  export type FormSectionCountOutputType = {
    questions: number
    cursor: number
  }

  export type FormSectionCountOutputTypeSelect = {
    questions?: boolean
    cursor?: boolean
  }

  export type FormSectionCountOutputTypeGetPayload<S extends boolean | null | undefined | FormSectionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FormSectionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FormSectionCountOutputTypeArgs)
    ? FormSectionCountOutputType 
    : S extends { select: any } & (FormSectionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FormSectionCountOutputType ? FormSectionCountOutputType[P] : never
  } 
      : FormSectionCountOutputType




  // Custom InputTypes

  /**
   * FormSectionCountOutputType without action
   */
  export type FormSectionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FormSectionCountOutputType
     * 
    **/
    select?: FormSectionCountOutputTypeSelect | null
  }



  /**
   * Count Type QuestionCountOutputType
   */


  export type QuestionCountOutputType = {
    answers: number
    options: number
    optionRule: number
    rules: number
    questionAnswerRef: number
    questionFormatRule: number
    questionFormatAnswerRef: number
  }

  export type QuestionCountOutputTypeSelect = {
    answers?: boolean
    options?: boolean
    optionRule?: boolean
    rules?: boolean
    questionAnswerRef?: boolean
    questionFormatRule?: boolean
    questionFormatAnswerRef?: boolean
  }

  export type QuestionCountOutputTypeGetPayload<S extends boolean | null | undefined | QuestionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuestionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuestionCountOutputTypeArgs)
    ? QuestionCountOutputType 
    : S extends { select: any } & (QuestionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuestionCountOutputType ? QuestionCountOutputType[P] : never
  } 
      : QuestionCountOutputType




  // Custom InputTypes

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     * 
    **/
    select?: QuestionCountOutputTypeSelect | null
  }



  /**
   * Count Type SubformCountOutputType
   */


  export type SubformCountOutputType = {
    subformFields: number
  }

  export type SubformCountOutputTypeSelect = {
    subformFields?: boolean
  }

  export type SubformCountOutputTypeGetPayload<S extends boolean | null | undefined | SubformCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SubformCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SubformCountOutputTypeArgs)
    ? SubformCountOutputType 
    : S extends { select: any } & (SubformCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SubformCountOutputType ? SubformCountOutputType[P] : never
  } 
      : SubformCountOutputType




  // Custom InputTypes

  /**
   * SubformCountOutputType without action
   */
  export type SubformCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SubformCountOutputType
     * 
    **/
    select?: SubformCountOutputTypeSelect | null
  }



  /**
   * Count Type SubformFieldCountOutputType
   */


  export type SubformFieldCountOutputType = {
    subformFieldOptions: number
    subformFieldAnswer: number
  }

  export type SubformFieldCountOutputTypeSelect = {
    subformFieldOptions?: boolean
    subformFieldAnswer?: boolean
  }

  export type SubformFieldCountOutputTypeGetPayload<S extends boolean | null | undefined | SubformFieldCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SubformFieldCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SubformFieldCountOutputTypeArgs)
    ? SubformFieldCountOutputType 
    : S extends { select: any } & (SubformFieldCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SubformFieldCountOutputType ? SubformFieldCountOutputType[P] : never
  } 
      : SubformFieldCountOutputType




  // Custom InputTypes

  /**
   * SubformFieldCountOutputType without action
   */
  export type SubformFieldCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldCountOutputType
     * 
    **/
    select?: SubformFieldCountOutputTypeSelect | null
  }



  /**
   * Count Type SubformFieldOptionCountOutputType
   */


  export type SubformFieldOptionCountOutputType = {
    subformFieldAnswer: number
  }

  export type SubformFieldOptionCountOutputTypeSelect = {
    subformFieldAnswer?: boolean
  }

  export type SubformFieldOptionCountOutputTypeGetPayload<S extends boolean | null | undefined | SubformFieldOptionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SubformFieldOptionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SubformFieldOptionCountOutputTypeArgs)
    ? SubformFieldOptionCountOutputType 
    : S extends { select: any } & (SubformFieldOptionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SubformFieldOptionCountOutputType ? SubformFieldOptionCountOutputType[P] : never
  } 
      : SubformFieldOptionCountOutputType




  // Custom InputTypes

  /**
   * SubformFieldOptionCountOutputType without action
   */
  export type SubformFieldOptionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldOptionCountOutputType
     * 
    **/
    select?: SubformFieldOptionCountOutputTypeSelect | null
  }



  /**
   * Count Type OptionCountOutputType
   */


  export type OptionCountOutputType = {
    rules: number
    answer: number
  }

  export type OptionCountOutputTypeSelect = {
    rules?: boolean
    answer?: boolean
  }

  export type OptionCountOutputTypeGetPayload<S extends boolean | null | undefined | OptionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OptionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OptionCountOutputTypeArgs)
    ? OptionCountOutputType 
    : S extends { select: any } & (OptionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OptionCountOutputType ? OptionCountOutputType[P] : never
  } 
      : OptionCountOutputType




  // Custom InputTypes

  /**
   * OptionCountOutputType without action
   */
  export type OptionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OptionCountOutputType
     * 
    **/
    select?: OptionCountOutputTypeSelect | null
  }



  /**
   * Count Type FunctionCountOutputType
   */


  export type FunctionCountOutputType = {
    QuestionRule: number
    OptionRule: number
  }

  export type FunctionCountOutputTypeSelect = {
    QuestionRule?: boolean
    OptionRule?: boolean
  }

  export type FunctionCountOutputTypeGetPayload<S extends boolean | null | undefined | FunctionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FunctionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FunctionCountOutputTypeArgs)
    ? FunctionCountOutputType 
    : S extends { select: any } & (FunctionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FunctionCountOutputType ? FunctionCountOutputType[P] : never
  } 
      : FunctionCountOutputType




  // Custom InputTypes

  /**
   * FunctionCountOutputType without action
   */
  export type FunctionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FunctionCountOutputType
     * 
    **/
    select?: FunctionCountOutputTypeSelect | null
  }



  /**
   * Count Type ReferrerCountOutputType
   */


  export type ReferrerCountOutputType = {
    Claimant: number
  }

  export type ReferrerCountOutputTypeSelect = {
    Claimant?: boolean
  }

  export type ReferrerCountOutputTypeGetPayload<S extends boolean | null | undefined | ReferrerCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ReferrerCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ReferrerCountOutputTypeArgs)
    ? ReferrerCountOutputType 
    : S extends { select: any } & (ReferrerCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ReferrerCountOutputType ? ReferrerCountOutputType[P] : never
  } 
      : ReferrerCountOutputType




  // Custom InputTypes

  /**
   * ReferrerCountOutputType without action
   */
  export type ReferrerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ReferrerCountOutputType
     * 
    **/
    select?: ReferrerCountOutputTypeSelect | null
  }



  /**
   * Count Type SSAStatusCountOutputType
   */


  export type SSAStatusCountOutputType = {
    claimant: number
    OptionRule: number
    QuestionRule: number
  }

  export type SSAStatusCountOutputTypeSelect = {
    claimant?: boolean
    OptionRule?: boolean
    QuestionRule?: boolean
  }

  export type SSAStatusCountOutputTypeGetPayload<S extends boolean | null | undefined | SSAStatusCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SSAStatusCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SSAStatusCountOutputTypeArgs)
    ? SSAStatusCountOutputType 
    : S extends { select: any } & (SSAStatusCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SSAStatusCountOutputType ? SSAStatusCountOutputType[P] : never
  } 
      : SSAStatusCountOutputType




  // Custom InputTypes

  /**
   * SSAStatusCountOutputType without action
   */
  export type SSAStatusCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SSAStatusCountOutputType
     * 
    **/
    select?: SSAStatusCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    auth0Id: string | null
    email: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    active: boolean | null
    lastActive: Date | null
    created: Date | null
    updated: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    auth0Id: string | null
    email: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    active: boolean | null
    lastActive: Date | null
    created: Date | null
    updated: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    auth0Id: number
    email: number
    phone: number
    firstName: number
    lastName: number
    active: number
    lastActive: number
    created: number
    updated: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    auth0Id?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    active?: true
    lastActive?: true
    created?: true
    updated?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    auth0Id?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    active?: true
    lastActive?: true
    created?: true
    updated?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    auth0Id?: true
    email?: true
    phone?: true
    firstName?: true
    lastName?: true
    active?: true
    lastActive?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    auth0Id: string
    email: string
    phone: string | null
    firstName: string | null
    lastName: string | null
    active: boolean
    lastActive: Date
    created: Date
    updated: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    auth0Id?: boolean
    email?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    active?: boolean
    lastActive?: boolean
    created?: boolean
    updated?: boolean
    callSessions?: boolean | CallSessionFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    callSessions?: boolean | CallSessionFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  } 

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'callSessions' ? Array < CallSessionGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'callSessions' ? Array < CallSessionGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    callSessions<T extends CallSessionFindManyArgs= {}>(args?: Subset<T, CallSessionFindManyArgs>): PrismaPromise<Array<CallSessionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Claimant
   */


  export type AggregateClaimant = {
    _count: ClaimantCountAggregateOutputType | null
    _avg: ClaimantAvgAggregateOutputType | null
    _sum: ClaimantSumAggregateOutputType | null
    _min: ClaimantMinAggregateOutputType | null
    _max: ClaimantMaxAggregateOutputType | null
  }

  export type ClaimantAvgAggregateOutputType = {
    id: number | null
    referrerId: number | null
    ssaStatusId: number | null
  }

  export type ClaimantSumAggregateOutputType = {
    id: number | null
    referrerId: number | null
    ssaStatusId: number | null
  }

  export type ClaimantMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    referrerId: number | null
    ssaStatusId: number | null
    created: Date | null
    updated: Date | null
  }

  export type ClaimantMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    referrerId: number | null
    ssaStatusId: number | null
    created: Date | null
    updated: Date | null
  }

  export type ClaimantCountAggregateOutputType = {
    id: number
    firstName: number
    middleName: number
    lastName: number
    phone: number
    email: number
    referrerId: number
    ssaStatusId: number
    created: number
    updated: number
    _all: number
  }


  export type ClaimantAvgAggregateInputType = {
    id?: true
    referrerId?: true
    ssaStatusId?: true
  }

  export type ClaimantSumAggregateInputType = {
    id?: true
    referrerId?: true
    ssaStatusId?: true
  }

  export type ClaimantMinAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    phone?: true
    email?: true
    referrerId?: true
    ssaStatusId?: true
    created?: true
    updated?: true
  }

  export type ClaimantMaxAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    phone?: true
    email?: true
    referrerId?: true
    ssaStatusId?: true
    created?: true
    updated?: true
  }

  export type ClaimantCountAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    phone?: true
    email?: true
    referrerId?: true
    ssaStatusId?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type ClaimantAggregateArgs = {
    /**
     * Filter which Claimant to aggregate.
     * 
    **/
    where?: ClaimantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claimants to fetch.
     * 
    **/
    orderBy?: Enumerable<ClaimantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ClaimantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claimants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claimants.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Claimants
    **/
    _count?: true | ClaimantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaimantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaimantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimantMaxAggregateInputType
  }

  export type GetClaimantAggregateType<T extends ClaimantAggregateArgs> = {
        [P in keyof T & keyof AggregateClaimant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaimant[P]>
      : GetScalarType<T[P], AggregateClaimant[P]>
  }




  export type ClaimantGroupByArgs = {
    where?: ClaimantWhereInput
    orderBy?: Enumerable<ClaimantOrderByWithAggregationInput>
    by: Array<ClaimantScalarFieldEnum>
    having?: ClaimantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimantCountAggregateInputType | true
    _avg?: ClaimantAvgAggregateInputType
    _sum?: ClaimantSumAggregateInputType
    _min?: ClaimantMinAggregateInputType
    _max?: ClaimantMaxAggregateInputType
  }


  export type ClaimantGroupByOutputType = {
    id: number
    firstName: string | null
    middleName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    referrerId: number | null
    ssaStatusId: number | null
    created: Date
    updated: Date
    _count: ClaimantCountAggregateOutputType | null
    _avg: ClaimantAvgAggregateOutputType | null
    _sum: ClaimantSumAggregateOutputType | null
    _min: ClaimantMinAggregateOutputType | null
    _max: ClaimantMaxAggregateOutputType | null
  }

  type GetClaimantGroupByPayload<T extends ClaimantGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClaimantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimantGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimantGroupByOutputType[P]>
        }
      >
    >


  export type ClaimantSelect = {
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    referrerId?: boolean
    ssaStatusId?: boolean
    created?: boolean
    updated?: boolean
    cursor?: boolean | CursorFindManyArgs
    answers?: boolean | AnswerFindManyArgs
    touchPoint?: boolean | TouchPointFindManyArgs
    callSessions?: boolean | CallSessionFindManyArgs
    subformFieldAnswer?: boolean | SubformFieldAnswerFindManyArgs
    ssaStatus?: boolean | SSAStatusArgs
    referrer?: boolean | ReferrerArgs
    VoiceMail?: boolean | VoiceMailFindManyArgs
    _count?: boolean | ClaimantCountOutputTypeArgs
  }


  export type ClaimantInclude = {
    cursor?: boolean | CursorFindManyArgs
    answers?: boolean | AnswerFindManyArgs
    touchPoint?: boolean | TouchPointFindManyArgs
    callSessions?: boolean | CallSessionFindManyArgs
    subformFieldAnswer?: boolean | SubformFieldAnswerFindManyArgs
    ssaStatus?: boolean | SSAStatusArgs
    referrer?: boolean | ReferrerArgs
    VoiceMail?: boolean | VoiceMailFindManyArgs
    _count?: boolean | ClaimantCountOutputTypeArgs
  } 

  export type ClaimantGetPayload<S extends boolean | null | undefined | ClaimantArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Claimant :
    S extends undefined ? never :
    S extends { include: any } & (ClaimantArgs | ClaimantFindManyArgs)
    ? Claimant  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'cursor' ? Array < CursorGetPayload<S['include'][P]>>  :
        P extends 'answers' ? Array < AnswerGetPayload<S['include'][P]>>  :
        P extends 'touchPoint' ? Array < TouchPointGetPayload<S['include'][P]>>  :
        P extends 'callSessions' ? Array < CallSessionGetPayload<S['include'][P]>>  :
        P extends 'subformFieldAnswer' ? Array < SubformFieldAnswerGetPayload<S['include'][P]>>  :
        P extends 'ssaStatus' ? SSAStatusGetPayload<S['include'][P]> | null :
        P extends 'referrer' ? ReferrerGetPayload<S['include'][P]> | null :
        P extends 'VoiceMail' ? Array < VoiceMailGetPayload<S['include'][P]>>  :
        P extends '_count' ? ClaimantCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ClaimantArgs | ClaimantFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'cursor' ? Array < CursorGetPayload<S['select'][P]>>  :
        P extends 'answers' ? Array < AnswerGetPayload<S['select'][P]>>  :
        P extends 'touchPoint' ? Array < TouchPointGetPayload<S['select'][P]>>  :
        P extends 'callSessions' ? Array < CallSessionGetPayload<S['select'][P]>>  :
        P extends 'subformFieldAnswer' ? Array < SubformFieldAnswerGetPayload<S['select'][P]>>  :
        P extends 'ssaStatus' ? SSAStatusGetPayload<S['select'][P]> | null :
        P extends 'referrer' ? ReferrerGetPayload<S['select'][P]> | null :
        P extends 'VoiceMail' ? Array < VoiceMailGetPayload<S['select'][P]>>  :
        P extends '_count' ? ClaimantCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Claimant ? Claimant[P] : never
  } 
      : Claimant


  type ClaimantCountArgs = Merge<
    Omit<ClaimantFindManyArgs, 'select' | 'include'> & {
      select?: ClaimantCountAggregateInputType | true
    }
  >

  export interface ClaimantDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Claimant that matches the filter.
     * @param {ClaimantFindUniqueArgs} args - Arguments to find a Claimant
     * @example
     * // Get one Claimant
     * const claimant = await prisma.claimant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClaimantFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClaimantFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Claimant'> extends True ? Prisma__ClaimantClient<ClaimantGetPayload<T>> : Prisma__ClaimantClient<ClaimantGetPayload<T> | null, null>

    /**
     * Find one Claimant that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClaimantFindUniqueOrThrowArgs} args - Arguments to find a Claimant
     * @example
     * // Get one Claimant
     * const claimant = await prisma.claimant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClaimantFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ClaimantFindUniqueOrThrowArgs>
    ): Prisma__ClaimantClient<ClaimantGetPayload<T>>

    /**
     * Find the first Claimant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimantFindFirstArgs} args - Arguments to find a Claimant
     * @example
     * // Get one Claimant
     * const claimant = await prisma.claimant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClaimantFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClaimantFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Claimant'> extends True ? Prisma__ClaimantClient<ClaimantGetPayload<T>> : Prisma__ClaimantClient<ClaimantGetPayload<T> | null, null>

    /**
     * Find the first Claimant that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimantFindFirstOrThrowArgs} args - Arguments to find a Claimant
     * @example
     * // Get one Claimant
     * const claimant = await prisma.claimant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClaimantFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClaimantFindFirstOrThrowArgs>
    ): Prisma__ClaimantClient<ClaimantGetPayload<T>>

    /**
     * Find zero or more Claimants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Claimants
     * const claimants = await prisma.claimant.findMany()
     * 
     * // Get first 10 Claimants
     * const claimants = await prisma.claimant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimantWithIdOnly = await prisma.claimant.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClaimantFindManyArgs>(
      args?: SelectSubset<T, ClaimantFindManyArgs>
    ): PrismaPromise<Array<ClaimantGetPayload<T>>>

    /**
     * Create a Claimant.
     * @param {ClaimantCreateArgs} args - Arguments to create a Claimant.
     * @example
     * // Create one Claimant
     * const Claimant = await prisma.claimant.create({
     *   data: {
     *     // ... data to create a Claimant
     *   }
     * })
     * 
    **/
    create<T extends ClaimantCreateArgs>(
      args: SelectSubset<T, ClaimantCreateArgs>
    ): Prisma__ClaimantClient<ClaimantGetPayload<T>>

    /**
     * Create many Claimants.
     *     @param {ClaimantCreateManyArgs} args - Arguments to create many Claimants.
     *     @example
     *     // Create many Claimants
     *     const claimant = await prisma.claimant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClaimantCreateManyArgs>(
      args?: SelectSubset<T, ClaimantCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Claimant.
     * @param {ClaimantDeleteArgs} args - Arguments to delete one Claimant.
     * @example
     * // Delete one Claimant
     * const Claimant = await prisma.claimant.delete({
     *   where: {
     *     // ... filter to delete one Claimant
     *   }
     * })
     * 
    **/
    delete<T extends ClaimantDeleteArgs>(
      args: SelectSubset<T, ClaimantDeleteArgs>
    ): Prisma__ClaimantClient<ClaimantGetPayload<T>>

    /**
     * Update one Claimant.
     * @param {ClaimantUpdateArgs} args - Arguments to update one Claimant.
     * @example
     * // Update one Claimant
     * const claimant = await prisma.claimant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClaimantUpdateArgs>(
      args: SelectSubset<T, ClaimantUpdateArgs>
    ): Prisma__ClaimantClient<ClaimantGetPayload<T>>

    /**
     * Delete zero or more Claimants.
     * @param {ClaimantDeleteManyArgs} args - Arguments to filter Claimants to delete.
     * @example
     * // Delete a few Claimants
     * const { count } = await prisma.claimant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClaimantDeleteManyArgs>(
      args?: SelectSubset<T, ClaimantDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claimants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Claimants
     * const claimant = await prisma.claimant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClaimantUpdateManyArgs>(
      args: SelectSubset<T, ClaimantUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Claimant.
     * @param {ClaimantUpsertArgs} args - Arguments to update or create a Claimant.
     * @example
     * // Update or create a Claimant
     * const claimant = await prisma.claimant.upsert({
     *   create: {
     *     // ... data to create a Claimant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Claimant we want to update
     *   }
     * })
    **/
    upsert<T extends ClaimantUpsertArgs>(
      args: SelectSubset<T, ClaimantUpsertArgs>
    ): Prisma__ClaimantClient<ClaimantGetPayload<T>>

    /**
     * Count the number of Claimants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimantCountArgs} args - Arguments to filter Claimants to count.
     * @example
     * // Count the number of Claimants
     * const count = await prisma.claimant.count({
     *   where: {
     *     // ... the filter for the Claimants we want to count
     *   }
     * })
    **/
    count<T extends ClaimantCountArgs>(
      args?: Subset<T, ClaimantCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Claimant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimantAggregateArgs>(args: Subset<T, ClaimantAggregateArgs>): PrismaPromise<GetClaimantAggregateType<T>>

    /**
     * Group by Claimant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimantGroupByArgs['orderBy'] }
        : { orderBy?: ClaimantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimantGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Claimant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClaimantClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cursor<T extends CursorFindManyArgs= {}>(args?: Subset<T, CursorFindManyArgs>): PrismaPromise<Array<CursorGetPayload<T>>| Null>;

    answers<T extends AnswerFindManyArgs= {}>(args?: Subset<T, AnswerFindManyArgs>): PrismaPromise<Array<AnswerGetPayload<T>>| Null>;

    touchPoint<T extends TouchPointFindManyArgs= {}>(args?: Subset<T, TouchPointFindManyArgs>): PrismaPromise<Array<TouchPointGetPayload<T>>| Null>;

    callSessions<T extends CallSessionFindManyArgs= {}>(args?: Subset<T, CallSessionFindManyArgs>): PrismaPromise<Array<CallSessionGetPayload<T>>| Null>;

    subformFieldAnswer<T extends SubformFieldAnswerFindManyArgs= {}>(args?: Subset<T, SubformFieldAnswerFindManyArgs>): PrismaPromise<Array<SubformFieldAnswerGetPayload<T>>| Null>;

    ssaStatus<T extends SSAStatusArgs= {}>(args?: Subset<T, SSAStatusArgs>): Prisma__SSAStatusClient<SSAStatusGetPayload<T> | Null>;

    referrer<T extends ReferrerArgs= {}>(args?: Subset<T, ReferrerArgs>): Prisma__ReferrerClient<ReferrerGetPayload<T> | Null>;

    VoiceMail<T extends VoiceMailFindManyArgs= {}>(args?: Subset<T, VoiceMailFindManyArgs>): PrismaPromise<Array<VoiceMailGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Claimant base type for findUnique actions
   */
  export type ClaimantFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Claimant
     * 
    **/
    select?: ClaimantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClaimantInclude | null
    /**
     * Filter, which Claimant to fetch.
     * 
    **/
    where: ClaimantWhereUniqueInput
  }

  /**
   * Claimant: findUnique
   */
  export interface ClaimantFindUniqueArgs extends ClaimantFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Claimant findUniqueOrThrow
   */
  export type ClaimantFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Claimant
     * 
    **/
    select?: ClaimantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClaimantInclude | null
    /**
     * Filter, which Claimant to fetch.
     * 
    **/
    where: ClaimantWhereUniqueInput
  }


  /**
   * Claimant base type for findFirst actions
   */
  export type ClaimantFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Claimant
     * 
    **/
    select?: ClaimantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClaimantInclude | null
    /**
     * Filter, which Claimant to fetch.
     * 
    **/
    where?: ClaimantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claimants to fetch.
     * 
    **/
    orderBy?: Enumerable<ClaimantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claimants.
     * 
    **/
    cursor?: ClaimantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claimants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claimants.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claimants.
     * 
    **/
    distinct?: Enumerable<ClaimantScalarFieldEnum>
  }

  /**
   * Claimant: findFirst
   */
  export interface ClaimantFindFirstArgs extends ClaimantFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Claimant findFirstOrThrow
   */
  export type ClaimantFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Claimant
     * 
    **/
    select?: ClaimantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClaimantInclude | null
    /**
     * Filter, which Claimant to fetch.
     * 
    **/
    where?: ClaimantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claimants to fetch.
     * 
    **/
    orderBy?: Enumerable<ClaimantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claimants.
     * 
    **/
    cursor?: ClaimantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claimants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claimants.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claimants.
     * 
    **/
    distinct?: Enumerable<ClaimantScalarFieldEnum>
  }


  /**
   * Claimant findMany
   */
  export type ClaimantFindManyArgs = {
    /**
     * Select specific fields to fetch from the Claimant
     * 
    **/
    select?: ClaimantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClaimantInclude | null
    /**
     * Filter, which Claimants to fetch.
     * 
    **/
    where?: ClaimantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claimants to fetch.
     * 
    **/
    orderBy?: Enumerable<ClaimantOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Claimants.
     * 
    **/
    cursor?: ClaimantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claimants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claimants.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClaimantScalarFieldEnum>
  }


  /**
   * Claimant create
   */
  export type ClaimantCreateArgs = {
    /**
     * Select specific fields to fetch from the Claimant
     * 
    **/
    select?: ClaimantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClaimantInclude | null
    /**
     * The data needed to create a Claimant.
     * 
    **/
    data: XOR<ClaimantCreateInput, ClaimantUncheckedCreateInput>
  }


  /**
   * Claimant createMany
   */
  export type ClaimantCreateManyArgs = {
    /**
     * The data used to create many Claimants.
     * 
    **/
    data: Enumerable<ClaimantCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Claimant update
   */
  export type ClaimantUpdateArgs = {
    /**
     * Select specific fields to fetch from the Claimant
     * 
    **/
    select?: ClaimantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClaimantInclude | null
    /**
     * The data needed to update a Claimant.
     * 
    **/
    data: XOR<ClaimantUpdateInput, ClaimantUncheckedUpdateInput>
    /**
     * Choose, which Claimant to update.
     * 
    **/
    where: ClaimantWhereUniqueInput
  }


  /**
   * Claimant updateMany
   */
  export type ClaimantUpdateManyArgs = {
    /**
     * The data used to update Claimants.
     * 
    **/
    data: XOR<ClaimantUpdateManyMutationInput, ClaimantUncheckedUpdateManyInput>
    /**
     * Filter which Claimants to update
     * 
    **/
    where?: ClaimantWhereInput
  }


  /**
   * Claimant upsert
   */
  export type ClaimantUpsertArgs = {
    /**
     * Select specific fields to fetch from the Claimant
     * 
    **/
    select?: ClaimantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClaimantInclude | null
    /**
     * The filter to search for the Claimant to update in case it exists.
     * 
    **/
    where: ClaimantWhereUniqueInput
    /**
     * In case the Claimant found by the `where` argument doesn't exist, create a new Claimant with this data.
     * 
    **/
    create: XOR<ClaimantCreateInput, ClaimantUncheckedCreateInput>
    /**
     * In case the Claimant was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ClaimantUpdateInput, ClaimantUncheckedUpdateInput>
  }


  /**
   * Claimant delete
   */
  export type ClaimantDeleteArgs = {
    /**
     * Select specific fields to fetch from the Claimant
     * 
    **/
    select?: ClaimantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClaimantInclude | null
    /**
     * Filter which Claimant to delete.
     * 
    **/
    where: ClaimantWhereUniqueInput
  }


  /**
   * Claimant deleteMany
   */
  export type ClaimantDeleteManyArgs = {
    /**
     * Filter which Claimants to delete
     * 
    **/
    where?: ClaimantWhereInput
  }


  /**
   * Claimant without action
   */
  export type ClaimantArgs = {
    /**
     * Select specific fields to fetch from the Claimant
     * 
    **/
    select?: ClaimantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClaimantInclude | null
  }



  /**
   * Model CallSession
   */


  export type AggregateCallSession = {
    _count: CallSessionCountAggregateOutputType | null
    _avg: CallSessionAvgAggregateOutputType | null
    _sum: CallSessionSumAggregateOutputType | null
    _min: CallSessionMinAggregateOutputType | null
    _max: CallSessionMaxAggregateOutputType | null
  }

  export type CallSessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    claimantId: number | null
  }

  export type CallSessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    claimantId: number | null
  }

  export type CallSessionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    claimantId: number | null
    sessionType: SessionTypes | null
    sessionStatus: SessionStatuses | null
    created: Date | null
    ended: Date | null
    updated: Date | null
    recordingUrl: string | null
    outgoingPhone: string | null
  }

  export type CallSessionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    claimantId: number | null
    sessionType: SessionTypes | null
    sessionStatus: SessionStatuses | null
    created: Date | null
    ended: Date | null
    updated: Date | null
    recordingUrl: string | null
    outgoingPhone: string | null
  }

  export type CallSessionCountAggregateOutputType = {
    id: number
    userId: number
    claimantId: number
    sessionType: number
    sessionStatus: number
    created: number
    ended: number
    updated: number
    recordingUrl: number
    outgoingPhone: number
    _all: number
  }


  export type CallSessionAvgAggregateInputType = {
    id?: true
    userId?: true
    claimantId?: true
  }

  export type CallSessionSumAggregateInputType = {
    id?: true
    userId?: true
    claimantId?: true
  }

  export type CallSessionMinAggregateInputType = {
    id?: true
    userId?: true
    claimantId?: true
    sessionType?: true
    sessionStatus?: true
    created?: true
    ended?: true
    updated?: true
    recordingUrl?: true
    outgoingPhone?: true
  }

  export type CallSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    claimantId?: true
    sessionType?: true
    sessionStatus?: true
    created?: true
    ended?: true
    updated?: true
    recordingUrl?: true
    outgoingPhone?: true
  }

  export type CallSessionCountAggregateInputType = {
    id?: true
    userId?: true
    claimantId?: true
    sessionType?: true
    sessionStatus?: true
    created?: true
    ended?: true
    updated?: true
    recordingUrl?: true
    outgoingPhone?: true
    _all?: true
  }

  export type CallSessionAggregateArgs = {
    /**
     * Filter which CallSession to aggregate.
     * 
    **/
    where?: CallSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSessions to fetch.
     * 
    **/
    orderBy?: Enumerable<CallSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CallSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallSessions
    **/
    _count?: true | CallSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CallSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CallSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallSessionMaxAggregateInputType
  }

  export type GetCallSessionAggregateType<T extends CallSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCallSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallSession[P]>
      : GetScalarType<T[P], AggregateCallSession[P]>
  }




  export type CallSessionGroupByArgs = {
    where?: CallSessionWhereInput
    orderBy?: Enumerable<CallSessionOrderByWithAggregationInput>
    by: Array<CallSessionScalarFieldEnum>
    having?: CallSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallSessionCountAggregateInputType | true
    _avg?: CallSessionAvgAggregateInputType
    _sum?: CallSessionSumAggregateInputType
    _min?: CallSessionMinAggregateInputType
    _max?: CallSessionMaxAggregateInputType
  }


  export type CallSessionGroupByOutputType = {
    id: number
    userId: number
    claimantId: number
    sessionType: SessionTypes
    sessionStatus: SessionStatuses | null
    created: Date
    ended: Date | null
    updated: Date
    recordingUrl: string | null
    outgoingPhone: string
    _count: CallSessionCountAggregateOutputType | null
    _avg: CallSessionAvgAggregateOutputType | null
    _sum: CallSessionSumAggregateOutputType | null
    _min: CallSessionMinAggregateOutputType | null
    _max: CallSessionMaxAggregateOutputType | null
  }

  type GetCallSessionGroupByPayload<T extends CallSessionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CallSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CallSessionGroupByOutputType[P]>
        }
      >
    >


  export type CallSessionSelect = {
    id?: boolean
    userId?: boolean
    claimantId?: boolean
    sessionType?: boolean
    sessionStatus?: boolean
    created?: boolean
    ended?: boolean
    updated?: boolean
    user?: boolean | UserArgs
    claimant?: boolean | ClaimantArgs
    answer?: boolean | AnswerFindManyArgs
    subformFieldAnswer?: boolean | SubformFieldAnswerFindManyArgs
    recordingUrl?: boolean
    outgoingPhone?: boolean
    _count?: boolean | CallSessionCountOutputTypeArgs
  }


  export type CallSessionInclude = {
    user?: boolean | UserArgs
    claimant?: boolean | ClaimantArgs
    answer?: boolean | AnswerFindManyArgs
    subformFieldAnswer?: boolean | SubformFieldAnswerFindManyArgs
    _count?: boolean | CallSessionCountOutputTypeArgs
  } 

  export type CallSessionGetPayload<S extends boolean | null | undefined | CallSessionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CallSession :
    S extends undefined ? never :
    S extends { include: any } & (CallSessionArgs | CallSessionFindManyArgs)
    ? CallSession  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'claimant' ? ClaimantGetPayload<S['include'][P]> :
        P extends 'answer' ? Array < AnswerGetPayload<S['include'][P]>>  :
        P extends 'subformFieldAnswer' ? Array < SubformFieldAnswerGetPayload<S['include'][P]>>  :
        P extends '_count' ? CallSessionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CallSessionArgs | CallSessionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'claimant' ? ClaimantGetPayload<S['select'][P]> :
        P extends 'answer' ? Array < AnswerGetPayload<S['select'][P]>>  :
        P extends 'subformFieldAnswer' ? Array < SubformFieldAnswerGetPayload<S['select'][P]>>  :
        P extends '_count' ? CallSessionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CallSession ? CallSession[P] : never
  } 
      : CallSession


  type CallSessionCountArgs = Merge<
    Omit<CallSessionFindManyArgs, 'select' | 'include'> & {
      select?: CallSessionCountAggregateInputType | true
    }
  >

  export interface CallSessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CallSession that matches the filter.
     * @param {CallSessionFindUniqueArgs} args - Arguments to find a CallSession
     * @example
     * // Get one CallSession
     * const callSession = await prisma.callSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CallSessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CallSessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CallSession'> extends True ? Prisma__CallSessionClient<CallSessionGetPayload<T>> : Prisma__CallSessionClient<CallSessionGetPayload<T> | null, null>

    /**
     * Find one CallSession that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CallSessionFindUniqueOrThrowArgs} args - Arguments to find a CallSession
     * @example
     * // Get one CallSession
     * const callSession = await prisma.callSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CallSessionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CallSessionFindUniqueOrThrowArgs>
    ): Prisma__CallSessionClient<CallSessionGetPayload<T>>

    /**
     * Find the first CallSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionFindFirstArgs} args - Arguments to find a CallSession
     * @example
     * // Get one CallSession
     * const callSession = await prisma.callSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CallSessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CallSessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CallSession'> extends True ? Prisma__CallSessionClient<CallSessionGetPayload<T>> : Prisma__CallSessionClient<CallSessionGetPayload<T> | null, null>

    /**
     * Find the first CallSession that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionFindFirstOrThrowArgs} args - Arguments to find a CallSession
     * @example
     * // Get one CallSession
     * const callSession = await prisma.callSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CallSessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CallSessionFindFirstOrThrowArgs>
    ): Prisma__CallSessionClient<CallSessionGetPayload<T>>

    /**
     * Find zero or more CallSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallSessions
     * const callSessions = await prisma.callSession.findMany()
     * 
     * // Get first 10 CallSessions
     * const callSessions = await prisma.callSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callSessionWithIdOnly = await prisma.callSession.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CallSessionFindManyArgs>(
      args?: SelectSubset<T, CallSessionFindManyArgs>
    ): PrismaPromise<Array<CallSessionGetPayload<T>>>

    /**
     * Create a CallSession.
     * @param {CallSessionCreateArgs} args - Arguments to create a CallSession.
     * @example
     * // Create one CallSession
     * const CallSession = await prisma.callSession.create({
     *   data: {
     *     // ... data to create a CallSession
     *   }
     * })
     * 
    **/
    create<T extends CallSessionCreateArgs>(
      args: SelectSubset<T, CallSessionCreateArgs>
    ): Prisma__CallSessionClient<CallSessionGetPayload<T>>

    /**
     * Create many CallSessions.
     *     @param {CallSessionCreateManyArgs} args - Arguments to create many CallSessions.
     *     @example
     *     // Create many CallSessions
     *     const callSession = await prisma.callSession.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CallSessionCreateManyArgs>(
      args?: SelectSubset<T, CallSessionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CallSession.
     * @param {CallSessionDeleteArgs} args - Arguments to delete one CallSession.
     * @example
     * // Delete one CallSession
     * const CallSession = await prisma.callSession.delete({
     *   where: {
     *     // ... filter to delete one CallSession
     *   }
     * })
     * 
    **/
    delete<T extends CallSessionDeleteArgs>(
      args: SelectSubset<T, CallSessionDeleteArgs>
    ): Prisma__CallSessionClient<CallSessionGetPayload<T>>

    /**
     * Update one CallSession.
     * @param {CallSessionUpdateArgs} args - Arguments to update one CallSession.
     * @example
     * // Update one CallSession
     * const callSession = await prisma.callSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CallSessionUpdateArgs>(
      args: SelectSubset<T, CallSessionUpdateArgs>
    ): Prisma__CallSessionClient<CallSessionGetPayload<T>>

    /**
     * Delete zero or more CallSessions.
     * @param {CallSessionDeleteManyArgs} args - Arguments to filter CallSessions to delete.
     * @example
     * // Delete a few CallSessions
     * const { count } = await prisma.callSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CallSessionDeleteManyArgs>(
      args?: SelectSubset<T, CallSessionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallSessions
     * const callSession = await prisma.callSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CallSessionUpdateManyArgs>(
      args: SelectSubset<T, CallSessionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CallSession.
     * @param {CallSessionUpsertArgs} args - Arguments to update or create a CallSession.
     * @example
     * // Update or create a CallSession
     * const callSession = await prisma.callSession.upsert({
     *   create: {
     *     // ... data to create a CallSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallSession we want to update
     *   }
     * })
    **/
    upsert<T extends CallSessionUpsertArgs>(
      args: SelectSubset<T, CallSessionUpsertArgs>
    ): Prisma__CallSessionClient<CallSessionGetPayload<T>>

    /**
     * Count the number of CallSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionCountArgs} args - Arguments to filter CallSessions to count.
     * @example
     * // Count the number of CallSessions
     * const count = await prisma.callSession.count({
     *   where: {
     *     // ... the filter for the CallSessions we want to count
     *   }
     * })
    **/
    count<T extends CallSessionCountArgs>(
      args?: Subset<T, CallSessionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallSessionAggregateArgs>(args: Subset<T, CallSessionAggregateArgs>): PrismaPromise<GetCallSessionAggregateType<T>>

    /**
     * Group by CallSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallSessionGroupByArgs['orderBy'] }
        : { orderBy?: CallSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallSessionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CallSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CallSessionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    claimant<T extends ClaimantArgs= {}>(args?: Subset<T, ClaimantArgs>): Prisma__ClaimantClient<ClaimantGetPayload<T> | Null>;

    answer<T extends AnswerFindManyArgs= {}>(args?: Subset<T, AnswerFindManyArgs>): PrismaPromise<Array<AnswerGetPayload<T>>| Null>;

    subformFieldAnswer<T extends SubformFieldAnswerFindManyArgs= {}>(args?: Subset<T, SubformFieldAnswerFindManyArgs>): PrismaPromise<Array<SubformFieldAnswerGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CallSession base type for findUnique actions
   */
  export type CallSessionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CallSession
     * 
    **/
    select?: CallSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CallSessionInclude | null
    /**
     * Filter, which CallSession to fetch.
     * 
    **/
    where: CallSessionWhereUniqueInput
  }

  /**
   * CallSession: findUnique
   */
  export interface CallSessionFindUniqueArgs extends CallSessionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CallSession findUniqueOrThrow
   */
  export type CallSessionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CallSession
     * 
    **/
    select?: CallSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CallSessionInclude | null
    /**
     * Filter, which CallSession to fetch.
     * 
    **/
    where: CallSessionWhereUniqueInput
  }


  /**
   * CallSession base type for findFirst actions
   */
  export type CallSessionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CallSession
     * 
    **/
    select?: CallSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CallSessionInclude | null
    /**
     * Filter, which CallSession to fetch.
     * 
    **/
    where?: CallSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSessions to fetch.
     * 
    **/
    orderBy?: Enumerable<CallSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallSessions.
     * 
    **/
    cursor?: CallSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallSessions.
     * 
    **/
    distinct?: Enumerable<CallSessionScalarFieldEnum>
  }

  /**
   * CallSession: findFirst
   */
  export interface CallSessionFindFirstArgs extends CallSessionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CallSession findFirstOrThrow
   */
  export type CallSessionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CallSession
     * 
    **/
    select?: CallSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CallSessionInclude | null
    /**
     * Filter, which CallSession to fetch.
     * 
    **/
    where?: CallSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSessions to fetch.
     * 
    **/
    orderBy?: Enumerable<CallSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallSessions.
     * 
    **/
    cursor?: CallSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallSessions.
     * 
    **/
    distinct?: Enumerable<CallSessionScalarFieldEnum>
  }


  /**
   * CallSession findMany
   */
  export type CallSessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the CallSession
     * 
    **/
    select?: CallSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CallSessionInclude | null
    /**
     * Filter, which CallSessions to fetch.
     * 
    **/
    where?: CallSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSessions to fetch.
     * 
    **/
    orderBy?: Enumerable<CallSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallSessions.
     * 
    **/
    cursor?: CallSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSessions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CallSessionScalarFieldEnum>
  }


  /**
   * CallSession create
   */
  export type CallSessionCreateArgs = {
    /**
     * Select specific fields to fetch from the CallSession
     * 
    **/
    select?: CallSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CallSessionInclude | null
    /**
     * The data needed to create a CallSession.
     * 
    **/
    data: XOR<CallSessionCreateInput, CallSessionUncheckedCreateInput>
  }


  /**
   * CallSession createMany
   */
  export type CallSessionCreateManyArgs = {
    /**
     * The data used to create many CallSessions.
     * 
    **/
    data: Enumerable<CallSessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CallSession update
   */
  export type CallSessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the CallSession
     * 
    **/
    select?: CallSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CallSessionInclude | null
    /**
     * The data needed to update a CallSession.
     * 
    **/
    data: XOR<CallSessionUpdateInput, CallSessionUncheckedUpdateInput>
    /**
     * Choose, which CallSession to update.
     * 
    **/
    where: CallSessionWhereUniqueInput
  }


  /**
   * CallSession updateMany
   */
  export type CallSessionUpdateManyArgs = {
    /**
     * The data used to update CallSessions.
     * 
    **/
    data: XOR<CallSessionUpdateManyMutationInput, CallSessionUncheckedUpdateManyInput>
    /**
     * Filter which CallSessions to update
     * 
    **/
    where?: CallSessionWhereInput
  }


  /**
   * CallSession upsert
   */
  export type CallSessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the CallSession
     * 
    **/
    select?: CallSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CallSessionInclude | null
    /**
     * The filter to search for the CallSession to update in case it exists.
     * 
    **/
    where: CallSessionWhereUniqueInput
    /**
     * In case the CallSession found by the `where` argument doesn't exist, create a new CallSession with this data.
     * 
    **/
    create: XOR<CallSessionCreateInput, CallSessionUncheckedCreateInput>
    /**
     * In case the CallSession was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CallSessionUpdateInput, CallSessionUncheckedUpdateInput>
  }


  /**
   * CallSession delete
   */
  export type CallSessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the CallSession
     * 
    **/
    select?: CallSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CallSessionInclude | null
    /**
     * Filter which CallSession to delete.
     * 
    **/
    where: CallSessionWhereUniqueInput
  }


  /**
   * CallSession deleteMany
   */
  export type CallSessionDeleteManyArgs = {
    /**
     * Filter which CallSessions to delete
     * 
    **/
    where?: CallSessionWhereInput
  }


  /**
   * CallSession without action
   */
  export type CallSessionArgs = {
    /**
     * Select specific fields to fetch from the CallSession
     * 
    **/
    select?: CallSessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CallSessionInclude | null
  }



  /**
   * Model VoiceMail
   */


  export type AggregateVoiceMail = {
    _count: VoiceMailCountAggregateOutputType | null
    _avg: VoiceMailAvgAggregateOutputType | null
    _sum: VoiceMailSumAggregateOutputType | null
    _min: VoiceMailMinAggregateOutputType | null
    _max: VoiceMailMaxAggregateOutputType | null
  }

  export type VoiceMailAvgAggregateOutputType = {
    id: number | null
    claimantId: number | null
  }

  export type VoiceMailSumAggregateOutputType = {
    id: number | null
    claimantId: number | null
  }

  export type VoiceMailMinAggregateOutputType = {
    id: number | null
    claimantId: number | null
    created: Date | null
    updated: Date | null
    recordingUrl: string | null
    transcription: string | null
  }

  export type VoiceMailMaxAggregateOutputType = {
    id: number | null
    claimantId: number | null
    created: Date | null
    updated: Date | null
    recordingUrl: string | null
    transcription: string | null
  }

  export type VoiceMailCountAggregateOutputType = {
    id: number
    claimantId: number
    created: number
    updated: number
    recordingUrl: number
    transcription: number
    _all: number
  }


  export type VoiceMailAvgAggregateInputType = {
    id?: true
    claimantId?: true
  }

  export type VoiceMailSumAggregateInputType = {
    id?: true
    claimantId?: true
  }

  export type VoiceMailMinAggregateInputType = {
    id?: true
    claimantId?: true
    created?: true
    updated?: true
    recordingUrl?: true
    transcription?: true
  }

  export type VoiceMailMaxAggregateInputType = {
    id?: true
    claimantId?: true
    created?: true
    updated?: true
    recordingUrl?: true
    transcription?: true
  }

  export type VoiceMailCountAggregateInputType = {
    id?: true
    claimantId?: true
    created?: true
    updated?: true
    recordingUrl?: true
    transcription?: true
    _all?: true
  }

  export type VoiceMailAggregateArgs = {
    /**
     * Filter which VoiceMail to aggregate.
     * 
    **/
    where?: VoiceMailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceMails to fetch.
     * 
    **/
    orderBy?: Enumerable<VoiceMailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VoiceMailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceMails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceMails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoiceMails
    **/
    _count?: true | VoiceMailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoiceMailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoiceMailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoiceMailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoiceMailMaxAggregateInputType
  }

  export type GetVoiceMailAggregateType<T extends VoiceMailAggregateArgs> = {
        [P in keyof T & keyof AggregateVoiceMail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoiceMail[P]>
      : GetScalarType<T[P], AggregateVoiceMail[P]>
  }




  export type VoiceMailGroupByArgs = {
    where?: VoiceMailWhereInput
    orderBy?: Enumerable<VoiceMailOrderByWithAggregationInput>
    by: Array<VoiceMailScalarFieldEnum>
    having?: VoiceMailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoiceMailCountAggregateInputType | true
    _avg?: VoiceMailAvgAggregateInputType
    _sum?: VoiceMailSumAggregateInputType
    _min?: VoiceMailMinAggregateInputType
    _max?: VoiceMailMaxAggregateInputType
  }


  export type VoiceMailGroupByOutputType = {
    id: number
    claimantId: number | null
    created: Date
    updated: Date
    recordingUrl: string | null
    transcription: string | null
    _count: VoiceMailCountAggregateOutputType | null
    _avg: VoiceMailAvgAggregateOutputType | null
    _sum: VoiceMailSumAggregateOutputType | null
    _min: VoiceMailMinAggregateOutputType | null
    _max: VoiceMailMaxAggregateOutputType | null
  }

  type GetVoiceMailGroupByPayload<T extends VoiceMailGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VoiceMailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoiceMailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoiceMailGroupByOutputType[P]>
            : GetScalarType<T[P], VoiceMailGroupByOutputType[P]>
        }
      >
    >


  export type VoiceMailSelect = {
    id?: boolean
    claimantId?: boolean
    created?: boolean
    updated?: boolean
    claimant?: boolean | ClaimantArgs
    recordingUrl?: boolean
    transcription?: boolean
  }


  export type VoiceMailInclude = {
    claimant?: boolean | ClaimantArgs
  } 

  export type VoiceMailGetPayload<S extends boolean | null | undefined | VoiceMailArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VoiceMail :
    S extends undefined ? never :
    S extends { include: any } & (VoiceMailArgs | VoiceMailFindManyArgs)
    ? VoiceMail  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'claimant' ? ClaimantGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (VoiceMailArgs | VoiceMailFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'claimant' ? ClaimantGetPayload<S['select'][P]> | null :  P extends keyof VoiceMail ? VoiceMail[P] : never
  } 
      : VoiceMail


  type VoiceMailCountArgs = Merge<
    Omit<VoiceMailFindManyArgs, 'select' | 'include'> & {
      select?: VoiceMailCountAggregateInputType | true
    }
  >

  export interface VoiceMailDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one VoiceMail that matches the filter.
     * @param {VoiceMailFindUniqueArgs} args - Arguments to find a VoiceMail
     * @example
     * // Get one VoiceMail
     * const voiceMail = await prisma.voiceMail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VoiceMailFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VoiceMailFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VoiceMail'> extends True ? Prisma__VoiceMailClient<VoiceMailGetPayload<T>> : Prisma__VoiceMailClient<VoiceMailGetPayload<T> | null, null>

    /**
     * Find one VoiceMail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VoiceMailFindUniqueOrThrowArgs} args - Arguments to find a VoiceMail
     * @example
     * // Get one VoiceMail
     * const voiceMail = await prisma.voiceMail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VoiceMailFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VoiceMailFindUniqueOrThrowArgs>
    ): Prisma__VoiceMailClient<VoiceMailGetPayload<T>>

    /**
     * Find the first VoiceMail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceMailFindFirstArgs} args - Arguments to find a VoiceMail
     * @example
     * // Get one VoiceMail
     * const voiceMail = await prisma.voiceMail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VoiceMailFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VoiceMailFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VoiceMail'> extends True ? Prisma__VoiceMailClient<VoiceMailGetPayload<T>> : Prisma__VoiceMailClient<VoiceMailGetPayload<T> | null, null>

    /**
     * Find the first VoiceMail that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceMailFindFirstOrThrowArgs} args - Arguments to find a VoiceMail
     * @example
     * // Get one VoiceMail
     * const voiceMail = await prisma.voiceMail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VoiceMailFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VoiceMailFindFirstOrThrowArgs>
    ): Prisma__VoiceMailClient<VoiceMailGetPayload<T>>

    /**
     * Find zero or more VoiceMails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceMailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoiceMails
     * const voiceMails = await prisma.voiceMail.findMany()
     * 
     * // Get first 10 VoiceMails
     * const voiceMails = await prisma.voiceMail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voiceMailWithIdOnly = await prisma.voiceMail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VoiceMailFindManyArgs>(
      args?: SelectSubset<T, VoiceMailFindManyArgs>
    ): PrismaPromise<Array<VoiceMailGetPayload<T>>>

    /**
     * Create a VoiceMail.
     * @param {VoiceMailCreateArgs} args - Arguments to create a VoiceMail.
     * @example
     * // Create one VoiceMail
     * const VoiceMail = await prisma.voiceMail.create({
     *   data: {
     *     // ... data to create a VoiceMail
     *   }
     * })
     * 
    **/
    create<T extends VoiceMailCreateArgs>(
      args: SelectSubset<T, VoiceMailCreateArgs>
    ): Prisma__VoiceMailClient<VoiceMailGetPayload<T>>

    /**
     * Create many VoiceMails.
     *     @param {VoiceMailCreateManyArgs} args - Arguments to create many VoiceMails.
     *     @example
     *     // Create many VoiceMails
     *     const voiceMail = await prisma.voiceMail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VoiceMailCreateManyArgs>(
      args?: SelectSubset<T, VoiceMailCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VoiceMail.
     * @param {VoiceMailDeleteArgs} args - Arguments to delete one VoiceMail.
     * @example
     * // Delete one VoiceMail
     * const VoiceMail = await prisma.voiceMail.delete({
     *   where: {
     *     // ... filter to delete one VoiceMail
     *   }
     * })
     * 
    **/
    delete<T extends VoiceMailDeleteArgs>(
      args: SelectSubset<T, VoiceMailDeleteArgs>
    ): Prisma__VoiceMailClient<VoiceMailGetPayload<T>>

    /**
     * Update one VoiceMail.
     * @param {VoiceMailUpdateArgs} args - Arguments to update one VoiceMail.
     * @example
     * // Update one VoiceMail
     * const voiceMail = await prisma.voiceMail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VoiceMailUpdateArgs>(
      args: SelectSubset<T, VoiceMailUpdateArgs>
    ): Prisma__VoiceMailClient<VoiceMailGetPayload<T>>

    /**
     * Delete zero or more VoiceMails.
     * @param {VoiceMailDeleteManyArgs} args - Arguments to filter VoiceMails to delete.
     * @example
     * // Delete a few VoiceMails
     * const { count } = await prisma.voiceMail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VoiceMailDeleteManyArgs>(
      args?: SelectSubset<T, VoiceMailDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoiceMails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceMailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoiceMails
     * const voiceMail = await prisma.voiceMail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VoiceMailUpdateManyArgs>(
      args: SelectSubset<T, VoiceMailUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VoiceMail.
     * @param {VoiceMailUpsertArgs} args - Arguments to update or create a VoiceMail.
     * @example
     * // Update or create a VoiceMail
     * const voiceMail = await prisma.voiceMail.upsert({
     *   create: {
     *     // ... data to create a VoiceMail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoiceMail we want to update
     *   }
     * })
    **/
    upsert<T extends VoiceMailUpsertArgs>(
      args: SelectSubset<T, VoiceMailUpsertArgs>
    ): Prisma__VoiceMailClient<VoiceMailGetPayload<T>>

    /**
     * Count the number of VoiceMails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceMailCountArgs} args - Arguments to filter VoiceMails to count.
     * @example
     * // Count the number of VoiceMails
     * const count = await prisma.voiceMail.count({
     *   where: {
     *     // ... the filter for the VoiceMails we want to count
     *   }
     * })
    **/
    count<T extends VoiceMailCountArgs>(
      args?: Subset<T, VoiceMailCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoiceMailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoiceMail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceMailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoiceMailAggregateArgs>(args: Subset<T, VoiceMailAggregateArgs>): PrismaPromise<GetVoiceMailAggregateType<T>>

    /**
     * Group by VoiceMail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceMailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoiceMailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoiceMailGroupByArgs['orderBy'] }
        : { orderBy?: VoiceMailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoiceMailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoiceMailGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for VoiceMail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VoiceMailClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    claimant<T extends ClaimantArgs= {}>(args?: Subset<T, ClaimantArgs>): Prisma__ClaimantClient<ClaimantGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * VoiceMail base type for findUnique actions
   */
  export type VoiceMailFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the VoiceMail
     * 
    **/
    select?: VoiceMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VoiceMailInclude | null
    /**
     * Filter, which VoiceMail to fetch.
     * 
    **/
    where: VoiceMailWhereUniqueInput
  }

  /**
   * VoiceMail: findUnique
   */
  export interface VoiceMailFindUniqueArgs extends VoiceMailFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VoiceMail findUniqueOrThrow
   */
  export type VoiceMailFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the VoiceMail
     * 
    **/
    select?: VoiceMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VoiceMailInclude | null
    /**
     * Filter, which VoiceMail to fetch.
     * 
    **/
    where: VoiceMailWhereUniqueInput
  }


  /**
   * VoiceMail base type for findFirst actions
   */
  export type VoiceMailFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the VoiceMail
     * 
    **/
    select?: VoiceMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VoiceMailInclude | null
    /**
     * Filter, which VoiceMail to fetch.
     * 
    **/
    where?: VoiceMailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceMails to fetch.
     * 
    **/
    orderBy?: Enumerable<VoiceMailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoiceMails.
     * 
    **/
    cursor?: VoiceMailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceMails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceMails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoiceMails.
     * 
    **/
    distinct?: Enumerable<VoiceMailScalarFieldEnum>
  }

  /**
   * VoiceMail: findFirst
   */
  export interface VoiceMailFindFirstArgs extends VoiceMailFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * VoiceMail findFirstOrThrow
   */
  export type VoiceMailFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the VoiceMail
     * 
    **/
    select?: VoiceMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VoiceMailInclude | null
    /**
     * Filter, which VoiceMail to fetch.
     * 
    **/
    where?: VoiceMailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceMails to fetch.
     * 
    **/
    orderBy?: Enumerable<VoiceMailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoiceMails.
     * 
    **/
    cursor?: VoiceMailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceMails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceMails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoiceMails.
     * 
    **/
    distinct?: Enumerable<VoiceMailScalarFieldEnum>
  }


  /**
   * VoiceMail findMany
   */
  export type VoiceMailFindManyArgs = {
    /**
     * Select specific fields to fetch from the VoiceMail
     * 
    **/
    select?: VoiceMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VoiceMailInclude | null
    /**
     * Filter, which VoiceMails to fetch.
     * 
    **/
    where?: VoiceMailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceMails to fetch.
     * 
    **/
    orderBy?: Enumerable<VoiceMailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoiceMails.
     * 
    **/
    cursor?: VoiceMailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceMails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceMails.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VoiceMailScalarFieldEnum>
  }


  /**
   * VoiceMail create
   */
  export type VoiceMailCreateArgs = {
    /**
     * Select specific fields to fetch from the VoiceMail
     * 
    **/
    select?: VoiceMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VoiceMailInclude | null
    /**
     * The data needed to create a VoiceMail.
     * 
    **/
    data: XOR<VoiceMailCreateInput, VoiceMailUncheckedCreateInput>
  }


  /**
   * VoiceMail createMany
   */
  export type VoiceMailCreateManyArgs = {
    /**
     * The data used to create many VoiceMails.
     * 
    **/
    data: Enumerable<VoiceMailCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VoiceMail update
   */
  export type VoiceMailUpdateArgs = {
    /**
     * Select specific fields to fetch from the VoiceMail
     * 
    **/
    select?: VoiceMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VoiceMailInclude | null
    /**
     * The data needed to update a VoiceMail.
     * 
    **/
    data: XOR<VoiceMailUpdateInput, VoiceMailUncheckedUpdateInput>
    /**
     * Choose, which VoiceMail to update.
     * 
    **/
    where: VoiceMailWhereUniqueInput
  }


  /**
   * VoiceMail updateMany
   */
  export type VoiceMailUpdateManyArgs = {
    /**
     * The data used to update VoiceMails.
     * 
    **/
    data: XOR<VoiceMailUpdateManyMutationInput, VoiceMailUncheckedUpdateManyInput>
    /**
     * Filter which VoiceMails to update
     * 
    **/
    where?: VoiceMailWhereInput
  }


  /**
   * VoiceMail upsert
   */
  export type VoiceMailUpsertArgs = {
    /**
     * Select specific fields to fetch from the VoiceMail
     * 
    **/
    select?: VoiceMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VoiceMailInclude | null
    /**
     * The filter to search for the VoiceMail to update in case it exists.
     * 
    **/
    where: VoiceMailWhereUniqueInput
    /**
     * In case the VoiceMail found by the `where` argument doesn't exist, create a new VoiceMail with this data.
     * 
    **/
    create: XOR<VoiceMailCreateInput, VoiceMailUncheckedCreateInput>
    /**
     * In case the VoiceMail was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VoiceMailUpdateInput, VoiceMailUncheckedUpdateInput>
  }


  /**
   * VoiceMail delete
   */
  export type VoiceMailDeleteArgs = {
    /**
     * Select specific fields to fetch from the VoiceMail
     * 
    **/
    select?: VoiceMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VoiceMailInclude | null
    /**
     * Filter which VoiceMail to delete.
     * 
    **/
    where: VoiceMailWhereUniqueInput
  }


  /**
   * VoiceMail deleteMany
   */
  export type VoiceMailDeleteManyArgs = {
    /**
     * Filter which VoiceMails to delete
     * 
    **/
    where?: VoiceMailWhereInput
  }


  /**
   * VoiceMail without action
   */
  export type VoiceMailArgs = {
    /**
     * Select specific fields to fetch from the VoiceMail
     * 
    **/
    select?: VoiceMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VoiceMailInclude | null
  }



  /**
   * Model Form
   */


  export type AggregateForm = {
    _count: FormCountAggregateOutputType | null
    _avg: FormAvgAggregateOutputType | null
    _sum: FormSumAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  export type FormAvgAggregateOutputType = {
    id: number | null
  }

  export type FormSumAggregateOutputType = {
    id: number | null
  }

  export type FormMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created: Date | null
    updated: Date | null
  }

  export type FormMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created: Date | null
    updated: Date | null
  }

  export type FormCountAggregateOutputType = {
    id: number
    name: number
    description: number
    created: number
    updated: number
    _all: number
  }


  export type FormAvgAggregateInputType = {
    id?: true
  }

  export type FormSumAggregateInputType = {
    id?: true
  }

  export type FormMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created?: true
    updated?: true
  }

  export type FormMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created?: true
    updated?: true
  }

  export type FormCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type FormAggregateArgs = {
    /**
     * Filter which Form to aggregate.
     * 
    **/
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     * 
    **/
    orderBy?: Enumerable<FormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Forms
    **/
    _count?: true | FormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormMaxAggregateInputType
  }

  export type GetFormAggregateType<T extends FormAggregateArgs> = {
        [P in keyof T & keyof AggregateForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForm[P]>
      : GetScalarType<T[P], AggregateForm[P]>
  }




  export type FormGroupByArgs = {
    where?: FormWhereInput
    orderBy?: Enumerable<FormOrderByWithAggregationInput>
    by: Array<FormScalarFieldEnum>
    having?: FormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormCountAggregateInputType | true
    _avg?: FormAvgAggregateInputType
    _sum?: FormSumAggregateInputType
    _min?: FormMinAggregateInputType
    _max?: FormMaxAggregateInputType
  }


  export type FormGroupByOutputType = {
    id: number
    name: string
    description: string | null
    created: Date
    updated: Date
    _count: FormCountAggregateOutputType | null
    _avg: FormAvgAggregateOutputType | null
    _sum: FormSumAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  type GetFormGroupByPayload<T extends FormGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormGroupByOutputType[P]>
            : GetScalarType<T[P], FormGroupByOutputType[P]>
        }
      >
    >


  export type FormSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    created?: boolean
    updated?: boolean
    formSection?: boolean | FormSectionFindManyArgs
    _count?: boolean | FormCountOutputTypeArgs
  }


  export type FormInclude = {
    formSection?: boolean | FormSectionFindManyArgs
    _count?: boolean | FormCountOutputTypeArgs
  } 

  export type FormGetPayload<S extends boolean | null | undefined | FormArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Form :
    S extends undefined ? never :
    S extends { include: any } & (FormArgs | FormFindManyArgs)
    ? Form  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'formSection' ? Array < FormSectionGetPayload<S['include'][P]>>  :
        P extends '_count' ? FormCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FormArgs | FormFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'formSection' ? Array < FormSectionGetPayload<S['select'][P]>>  :
        P extends '_count' ? FormCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Form ? Form[P] : never
  } 
      : Form


  type FormCountArgs = Merge<
    Omit<FormFindManyArgs, 'select' | 'include'> & {
      select?: FormCountAggregateInputType | true
    }
  >

  export interface FormDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Form that matches the filter.
     * @param {FormFindUniqueArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FormFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Form'> extends True ? Prisma__FormClient<FormGetPayload<T>> : Prisma__FormClient<FormGetPayload<T> | null, null>

    /**
     * Find one Form that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FormFindUniqueOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FormFindUniqueOrThrowArgs>
    ): Prisma__FormClient<FormGetPayload<T>>

    /**
     * Find the first Form that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FormFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Form'> extends True ? Prisma__FormClient<FormGetPayload<T>> : Prisma__FormClient<FormGetPayload<T> | null, null>

    /**
     * Find the first Form that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FormFindFirstOrThrowArgs>
    ): Prisma__FormClient<FormGetPayload<T>>

    /**
     * Find zero or more Forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Forms
     * const forms = await prisma.form.findMany()
     * 
     * // Get first 10 Forms
     * const forms = await prisma.form.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formWithIdOnly = await prisma.form.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormFindManyArgs>(
      args?: SelectSubset<T, FormFindManyArgs>
    ): PrismaPromise<Array<FormGetPayload<T>>>

    /**
     * Create a Form.
     * @param {FormCreateArgs} args - Arguments to create a Form.
     * @example
     * // Create one Form
     * const Form = await prisma.form.create({
     *   data: {
     *     // ... data to create a Form
     *   }
     * })
     * 
    **/
    create<T extends FormCreateArgs>(
      args: SelectSubset<T, FormCreateArgs>
    ): Prisma__FormClient<FormGetPayload<T>>

    /**
     * Create many Forms.
     *     @param {FormCreateManyArgs} args - Arguments to create many Forms.
     *     @example
     *     // Create many Forms
     *     const form = await prisma.form.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FormCreateManyArgs>(
      args?: SelectSubset<T, FormCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Form.
     * @param {FormDeleteArgs} args - Arguments to delete one Form.
     * @example
     * // Delete one Form
     * const Form = await prisma.form.delete({
     *   where: {
     *     // ... filter to delete one Form
     *   }
     * })
     * 
    **/
    delete<T extends FormDeleteArgs>(
      args: SelectSubset<T, FormDeleteArgs>
    ): Prisma__FormClient<FormGetPayload<T>>

    /**
     * Update one Form.
     * @param {FormUpdateArgs} args - Arguments to update one Form.
     * @example
     * // Update one Form
     * const form = await prisma.form.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormUpdateArgs>(
      args: SelectSubset<T, FormUpdateArgs>
    ): Prisma__FormClient<FormGetPayload<T>>

    /**
     * Delete zero or more Forms.
     * @param {FormDeleteManyArgs} args - Arguments to filter Forms to delete.
     * @example
     * // Delete a few Forms
     * const { count } = await prisma.form.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormDeleteManyArgs>(
      args?: SelectSubset<T, FormDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Forms
     * const form = await prisma.form.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormUpdateManyArgs>(
      args: SelectSubset<T, FormUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Form.
     * @param {FormUpsertArgs} args - Arguments to update or create a Form.
     * @example
     * // Update or create a Form
     * const form = await prisma.form.upsert({
     *   create: {
     *     // ... data to create a Form
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Form we want to update
     *   }
     * })
    **/
    upsert<T extends FormUpsertArgs>(
      args: SelectSubset<T, FormUpsertArgs>
    ): Prisma__FormClient<FormGetPayload<T>>

    /**
     * Count the number of Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormCountArgs} args - Arguments to filter Forms to count.
     * @example
     * // Count the number of Forms
     * const count = await prisma.form.count({
     *   where: {
     *     // ... the filter for the Forms we want to count
     *   }
     * })
    **/
    count<T extends FormCountArgs>(
      args?: Subset<T, FormCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormAggregateArgs>(args: Subset<T, FormAggregateArgs>): PrismaPromise<GetFormAggregateType<T>>

    /**
     * Group by Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormGroupByArgs['orderBy'] }
        : { orderBy?: FormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Form.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FormClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    formSection<T extends FormSectionFindManyArgs= {}>(args?: Subset<T, FormSectionFindManyArgs>): PrismaPromise<Array<FormSectionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Form base type for findUnique actions
   */
  export type FormFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Form
     * 
    **/
    select?: FormSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormInclude | null
    /**
     * Filter, which Form to fetch.
     * 
    **/
    where: FormWhereUniqueInput
  }

  /**
   * Form: findUnique
   */
  export interface FormFindUniqueArgs extends FormFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Form findUniqueOrThrow
   */
  export type FormFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Form
     * 
    **/
    select?: FormSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormInclude | null
    /**
     * Filter, which Form to fetch.
     * 
    **/
    where: FormWhereUniqueInput
  }


  /**
   * Form base type for findFirst actions
   */
  export type FormFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Form
     * 
    **/
    select?: FormSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormInclude | null
    /**
     * Filter, which Form to fetch.
     * 
    **/
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     * 
    **/
    orderBy?: Enumerable<FormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     * 
    **/
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     * 
    **/
    distinct?: Enumerable<FormScalarFieldEnum>
  }

  /**
   * Form: findFirst
   */
  export interface FormFindFirstArgs extends FormFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Form findFirstOrThrow
   */
  export type FormFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Form
     * 
    **/
    select?: FormSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormInclude | null
    /**
     * Filter, which Form to fetch.
     * 
    **/
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     * 
    **/
    orderBy?: Enumerable<FormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     * 
    **/
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     * 
    **/
    distinct?: Enumerable<FormScalarFieldEnum>
  }


  /**
   * Form findMany
   */
  export type FormFindManyArgs = {
    /**
     * Select specific fields to fetch from the Form
     * 
    **/
    select?: FormSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormInclude | null
    /**
     * Filter, which Forms to fetch.
     * 
    **/
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     * 
    **/
    orderBy?: Enumerable<FormOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Forms.
     * 
    **/
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FormScalarFieldEnum>
  }


  /**
   * Form create
   */
  export type FormCreateArgs = {
    /**
     * Select specific fields to fetch from the Form
     * 
    **/
    select?: FormSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormInclude | null
    /**
     * The data needed to create a Form.
     * 
    **/
    data: XOR<FormCreateInput, FormUncheckedCreateInput>
  }


  /**
   * Form createMany
   */
  export type FormCreateManyArgs = {
    /**
     * The data used to create many Forms.
     * 
    **/
    data: Enumerable<FormCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Form update
   */
  export type FormUpdateArgs = {
    /**
     * Select specific fields to fetch from the Form
     * 
    **/
    select?: FormSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormInclude | null
    /**
     * The data needed to update a Form.
     * 
    **/
    data: XOR<FormUpdateInput, FormUncheckedUpdateInput>
    /**
     * Choose, which Form to update.
     * 
    **/
    where: FormWhereUniqueInput
  }


  /**
   * Form updateMany
   */
  export type FormUpdateManyArgs = {
    /**
     * The data used to update Forms.
     * 
    **/
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyInput>
    /**
     * Filter which Forms to update
     * 
    **/
    where?: FormWhereInput
  }


  /**
   * Form upsert
   */
  export type FormUpsertArgs = {
    /**
     * Select specific fields to fetch from the Form
     * 
    **/
    select?: FormSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormInclude | null
    /**
     * The filter to search for the Form to update in case it exists.
     * 
    **/
    where: FormWhereUniqueInput
    /**
     * In case the Form found by the `where` argument doesn't exist, create a new Form with this data.
     * 
    **/
    create: XOR<FormCreateInput, FormUncheckedCreateInput>
    /**
     * In case the Form was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FormUpdateInput, FormUncheckedUpdateInput>
  }


  /**
   * Form delete
   */
  export type FormDeleteArgs = {
    /**
     * Select specific fields to fetch from the Form
     * 
    **/
    select?: FormSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormInclude | null
    /**
     * Filter which Form to delete.
     * 
    **/
    where: FormWhereUniqueInput
  }


  /**
   * Form deleteMany
   */
  export type FormDeleteManyArgs = {
    /**
     * Filter which Forms to delete
     * 
    **/
    where?: FormWhereInput
  }


  /**
   * Form without action
   */
  export type FormArgs = {
    /**
     * Select specific fields to fetch from the Form
     * 
    **/
    select?: FormSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormInclude | null
  }



  /**
   * Model FormSection
   */


  export type AggregateFormSection = {
    _count: FormSectionCountAggregateOutputType | null
    _avg: FormSectionAvgAggregateOutputType | null
    _sum: FormSectionSumAggregateOutputType | null
    _min: FormSectionMinAggregateOutputType | null
    _max: FormSectionMaxAggregateOutputType | null
  }

  export type FormSectionAvgAggregateOutputType = {
    id: number | null
    formId: number | null
    order: number | null
  }

  export type FormSectionSumAggregateOutputType = {
    id: number | null
    formId: number | null
    order: number | null
  }

  export type FormSectionMinAggregateOutputType = {
    id: number | null
    formId: number | null
    name: string | null
    order: number | null
    showTimer: boolean | null
    created: Date | null
    updated: Date | null
  }

  export type FormSectionMaxAggregateOutputType = {
    id: number | null
    formId: number | null
    name: string | null
    order: number | null
    showTimer: boolean | null
    created: Date | null
    updated: Date | null
  }

  export type FormSectionCountAggregateOutputType = {
    id: number
    formId: number
    name: number
    order: number
    showTimer: number
    created: number
    updated: number
    _all: number
  }


  export type FormSectionAvgAggregateInputType = {
    id?: true
    formId?: true
    order?: true
  }

  export type FormSectionSumAggregateInputType = {
    id?: true
    formId?: true
    order?: true
  }

  export type FormSectionMinAggregateInputType = {
    id?: true
    formId?: true
    name?: true
    order?: true
    showTimer?: true
    created?: true
    updated?: true
  }

  export type FormSectionMaxAggregateInputType = {
    id?: true
    formId?: true
    name?: true
    order?: true
    showTimer?: true
    created?: true
    updated?: true
  }

  export type FormSectionCountAggregateInputType = {
    id?: true
    formId?: true
    name?: true
    order?: true
    showTimer?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type FormSectionAggregateArgs = {
    /**
     * Filter which FormSection to aggregate.
     * 
    **/
    where?: FormSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSections to fetch.
     * 
    **/
    orderBy?: Enumerable<FormSectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FormSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormSections
    **/
    _count?: true | FormSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormSectionMaxAggregateInputType
  }

  export type GetFormSectionAggregateType<T extends FormSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateFormSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormSection[P]>
      : GetScalarType<T[P], AggregateFormSection[P]>
  }




  export type FormSectionGroupByArgs = {
    where?: FormSectionWhereInput
    orderBy?: Enumerable<FormSectionOrderByWithAggregationInput>
    by: Array<FormSectionScalarFieldEnum>
    having?: FormSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormSectionCountAggregateInputType | true
    _avg?: FormSectionAvgAggregateInputType
    _sum?: FormSectionSumAggregateInputType
    _min?: FormSectionMinAggregateInputType
    _max?: FormSectionMaxAggregateInputType
  }


  export type FormSectionGroupByOutputType = {
    id: number
    formId: number
    name: string
    order: number
    showTimer: boolean
    created: Date
    updated: Date
    _count: FormSectionCountAggregateOutputType | null
    _avg: FormSectionAvgAggregateOutputType | null
    _sum: FormSectionSumAggregateOutputType | null
    _min: FormSectionMinAggregateOutputType | null
    _max: FormSectionMaxAggregateOutputType | null
  }

  type GetFormSectionGroupByPayload<T extends FormSectionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FormSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormSectionGroupByOutputType[P]>
            : GetScalarType<T[P], FormSectionGroupByOutputType[P]>
        }
      >
    >


  export type FormSectionSelect = {
    id?: boolean
    formId?: boolean
    name?: boolean
    order?: boolean
    showTimer?: boolean
    created?: boolean
    updated?: boolean
    questions?: boolean | QuestionFindManyArgs
    cursor?: boolean | CursorFindManyArgs
    form?: boolean | FormArgs
    _count?: boolean | FormSectionCountOutputTypeArgs
  }


  export type FormSectionInclude = {
    questions?: boolean | QuestionFindManyArgs
    cursor?: boolean | CursorFindManyArgs
    form?: boolean | FormArgs
    _count?: boolean | FormSectionCountOutputTypeArgs
  } 

  export type FormSectionGetPayload<S extends boolean | null | undefined | FormSectionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FormSection :
    S extends undefined ? never :
    S extends { include: any } & (FormSectionArgs | FormSectionFindManyArgs)
    ? FormSection  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'questions' ? Array < QuestionGetPayload<S['include'][P]>>  :
        P extends 'cursor' ? Array < CursorGetPayload<S['include'][P]>>  :
        P extends 'form' ? FormGetPayload<S['include'][P]> :
        P extends '_count' ? FormSectionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FormSectionArgs | FormSectionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'questions' ? Array < QuestionGetPayload<S['select'][P]>>  :
        P extends 'cursor' ? Array < CursorGetPayload<S['select'][P]>>  :
        P extends 'form' ? FormGetPayload<S['select'][P]> :
        P extends '_count' ? FormSectionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FormSection ? FormSection[P] : never
  } 
      : FormSection


  type FormSectionCountArgs = Merge<
    Omit<FormSectionFindManyArgs, 'select' | 'include'> & {
      select?: FormSectionCountAggregateInputType | true
    }
  >

  export interface FormSectionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one FormSection that matches the filter.
     * @param {FormSectionFindUniqueArgs} args - Arguments to find a FormSection
     * @example
     * // Get one FormSection
     * const formSection = await prisma.formSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FormSectionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FormSectionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FormSection'> extends True ? Prisma__FormSectionClient<FormSectionGetPayload<T>> : Prisma__FormSectionClient<FormSectionGetPayload<T> | null, null>

    /**
     * Find one FormSection that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FormSectionFindUniqueOrThrowArgs} args - Arguments to find a FormSection
     * @example
     * // Get one FormSection
     * const formSection = await prisma.formSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FormSectionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FormSectionFindUniqueOrThrowArgs>
    ): Prisma__FormSectionClient<FormSectionGetPayload<T>>

    /**
     * Find the first FormSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSectionFindFirstArgs} args - Arguments to find a FormSection
     * @example
     * // Get one FormSection
     * const formSection = await prisma.formSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FormSectionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FormSectionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FormSection'> extends True ? Prisma__FormSectionClient<FormSectionGetPayload<T>> : Prisma__FormSectionClient<FormSectionGetPayload<T> | null, null>

    /**
     * Find the first FormSection that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSectionFindFirstOrThrowArgs} args - Arguments to find a FormSection
     * @example
     * // Get one FormSection
     * const formSection = await prisma.formSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FormSectionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FormSectionFindFirstOrThrowArgs>
    ): Prisma__FormSectionClient<FormSectionGetPayload<T>>

    /**
     * Find zero or more FormSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSectionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormSections
     * const formSections = await prisma.formSection.findMany()
     * 
     * // Get first 10 FormSections
     * const formSections = await prisma.formSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formSectionWithIdOnly = await prisma.formSection.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FormSectionFindManyArgs>(
      args?: SelectSubset<T, FormSectionFindManyArgs>
    ): PrismaPromise<Array<FormSectionGetPayload<T>>>

    /**
     * Create a FormSection.
     * @param {FormSectionCreateArgs} args - Arguments to create a FormSection.
     * @example
     * // Create one FormSection
     * const FormSection = await prisma.formSection.create({
     *   data: {
     *     // ... data to create a FormSection
     *   }
     * })
     * 
    **/
    create<T extends FormSectionCreateArgs>(
      args: SelectSubset<T, FormSectionCreateArgs>
    ): Prisma__FormSectionClient<FormSectionGetPayload<T>>

    /**
     * Create many FormSections.
     *     @param {FormSectionCreateManyArgs} args - Arguments to create many FormSections.
     *     @example
     *     // Create many FormSections
     *     const formSection = await prisma.formSection.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FormSectionCreateManyArgs>(
      args?: SelectSubset<T, FormSectionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a FormSection.
     * @param {FormSectionDeleteArgs} args - Arguments to delete one FormSection.
     * @example
     * // Delete one FormSection
     * const FormSection = await prisma.formSection.delete({
     *   where: {
     *     // ... filter to delete one FormSection
     *   }
     * })
     * 
    **/
    delete<T extends FormSectionDeleteArgs>(
      args: SelectSubset<T, FormSectionDeleteArgs>
    ): Prisma__FormSectionClient<FormSectionGetPayload<T>>

    /**
     * Update one FormSection.
     * @param {FormSectionUpdateArgs} args - Arguments to update one FormSection.
     * @example
     * // Update one FormSection
     * const formSection = await prisma.formSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FormSectionUpdateArgs>(
      args: SelectSubset<T, FormSectionUpdateArgs>
    ): Prisma__FormSectionClient<FormSectionGetPayload<T>>

    /**
     * Delete zero or more FormSections.
     * @param {FormSectionDeleteManyArgs} args - Arguments to filter FormSections to delete.
     * @example
     * // Delete a few FormSections
     * const { count } = await prisma.formSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FormSectionDeleteManyArgs>(
      args?: SelectSubset<T, FormSectionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormSections
     * const formSection = await prisma.formSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FormSectionUpdateManyArgs>(
      args: SelectSubset<T, FormSectionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one FormSection.
     * @param {FormSectionUpsertArgs} args - Arguments to update or create a FormSection.
     * @example
     * // Update or create a FormSection
     * const formSection = await prisma.formSection.upsert({
     *   create: {
     *     // ... data to create a FormSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormSection we want to update
     *   }
     * })
    **/
    upsert<T extends FormSectionUpsertArgs>(
      args: SelectSubset<T, FormSectionUpsertArgs>
    ): Prisma__FormSectionClient<FormSectionGetPayload<T>>

    /**
     * Count the number of FormSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSectionCountArgs} args - Arguments to filter FormSections to count.
     * @example
     * // Count the number of FormSections
     * const count = await prisma.formSection.count({
     *   where: {
     *     // ... the filter for the FormSections we want to count
     *   }
     * })
    **/
    count<T extends FormSectionCountArgs>(
      args?: Subset<T, FormSectionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormSectionAggregateArgs>(args: Subset<T, FormSectionAggregateArgs>): PrismaPromise<GetFormSectionAggregateType<T>>

    /**
     * Group by FormSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormSectionGroupByArgs['orderBy'] }
        : { orderBy?: FormSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormSectionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FormSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FormSectionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    questions<T extends QuestionFindManyArgs= {}>(args?: Subset<T, QuestionFindManyArgs>): PrismaPromise<Array<QuestionGetPayload<T>>| Null>;

    cursor<T extends CursorFindManyArgs= {}>(args?: Subset<T, CursorFindManyArgs>): PrismaPromise<Array<CursorGetPayload<T>>| Null>;

    form<T extends FormArgs= {}>(args?: Subset<T, FormArgs>): Prisma__FormClient<FormGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FormSection base type for findUnique actions
   */
  export type FormSectionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FormSection
     * 
    **/
    select?: FormSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormSectionInclude | null
    /**
     * Filter, which FormSection to fetch.
     * 
    **/
    where: FormSectionWhereUniqueInput
  }

  /**
   * FormSection: findUnique
   */
  export interface FormSectionFindUniqueArgs extends FormSectionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FormSection findUniqueOrThrow
   */
  export type FormSectionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FormSection
     * 
    **/
    select?: FormSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormSectionInclude | null
    /**
     * Filter, which FormSection to fetch.
     * 
    **/
    where: FormSectionWhereUniqueInput
  }


  /**
   * FormSection base type for findFirst actions
   */
  export type FormSectionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FormSection
     * 
    **/
    select?: FormSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormSectionInclude | null
    /**
     * Filter, which FormSection to fetch.
     * 
    **/
    where?: FormSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSections to fetch.
     * 
    **/
    orderBy?: Enumerable<FormSectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSections.
     * 
    **/
    cursor?: FormSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSections.
     * 
    **/
    distinct?: Enumerable<FormSectionScalarFieldEnum>
  }

  /**
   * FormSection: findFirst
   */
  export interface FormSectionFindFirstArgs extends FormSectionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FormSection findFirstOrThrow
   */
  export type FormSectionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FormSection
     * 
    **/
    select?: FormSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormSectionInclude | null
    /**
     * Filter, which FormSection to fetch.
     * 
    **/
    where?: FormSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSections to fetch.
     * 
    **/
    orderBy?: Enumerable<FormSectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSections.
     * 
    **/
    cursor?: FormSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSections.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSections.
     * 
    **/
    distinct?: Enumerable<FormSectionScalarFieldEnum>
  }


  /**
   * FormSection findMany
   */
  export type FormSectionFindManyArgs = {
    /**
     * Select specific fields to fetch from the FormSection
     * 
    **/
    select?: FormSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormSectionInclude | null
    /**
     * Filter, which FormSections to fetch.
     * 
    **/
    where?: FormSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSections to fetch.
     * 
    **/
    orderBy?: Enumerable<FormSectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormSections.
     * 
    **/
    cursor?: FormSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSections from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSections.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FormSectionScalarFieldEnum>
  }


  /**
   * FormSection create
   */
  export type FormSectionCreateArgs = {
    /**
     * Select specific fields to fetch from the FormSection
     * 
    **/
    select?: FormSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormSectionInclude | null
    /**
     * The data needed to create a FormSection.
     * 
    **/
    data: XOR<FormSectionCreateInput, FormSectionUncheckedCreateInput>
  }


  /**
   * FormSection createMany
   */
  export type FormSectionCreateManyArgs = {
    /**
     * The data used to create many FormSections.
     * 
    **/
    data: Enumerable<FormSectionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FormSection update
   */
  export type FormSectionUpdateArgs = {
    /**
     * Select specific fields to fetch from the FormSection
     * 
    **/
    select?: FormSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormSectionInclude | null
    /**
     * The data needed to update a FormSection.
     * 
    **/
    data: XOR<FormSectionUpdateInput, FormSectionUncheckedUpdateInput>
    /**
     * Choose, which FormSection to update.
     * 
    **/
    where: FormSectionWhereUniqueInput
  }


  /**
   * FormSection updateMany
   */
  export type FormSectionUpdateManyArgs = {
    /**
     * The data used to update FormSections.
     * 
    **/
    data: XOR<FormSectionUpdateManyMutationInput, FormSectionUncheckedUpdateManyInput>
    /**
     * Filter which FormSections to update
     * 
    **/
    where?: FormSectionWhereInput
  }


  /**
   * FormSection upsert
   */
  export type FormSectionUpsertArgs = {
    /**
     * Select specific fields to fetch from the FormSection
     * 
    **/
    select?: FormSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormSectionInclude | null
    /**
     * The filter to search for the FormSection to update in case it exists.
     * 
    **/
    where: FormSectionWhereUniqueInput
    /**
     * In case the FormSection found by the `where` argument doesn't exist, create a new FormSection with this data.
     * 
    **/
    create: XOR<FormSectionCreateInput, FormSectionUncheckedCreateInput>
    /**
     * In case the FormSection was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FormSectionUpdateInput, FormSectionUncheckedUpdateInput>
  }


  /**
   * FormSection delete
   */
  export type FormSectionDeleteArgs = {
    /**
     * Select specific fields to fetch from the FormSection
     * 
    **/
    select?: FormSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormSectionInclude | null
    /**
     * Filter which FormSection to delete.
     * 
    **/
    where: FormSectionWhereUniqueInput
  }


  /**
   * FormSection deleteMany
   */
  export type FormSectionDeleteManyArgs = {
    /**
     * Filter which FormSections to delete
     * 
    **/
    where?: FormSectionWhereInput
  }


  /**
   * FormSection without action
   */
  export type FormSectionArgs = {
    /**
     * Select specific fields to fetch from the FormSection
     * 
    **/
    select?: FormSectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FormSectionInclude | null
  }



  /**
   * Model Question
   */


  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    id: number | null
    formSectionId: number | null
    order: number | null
  }

  export type QuestionSumAggregateOutputType = {
    id: number | null
    formSectionId: number | null
    order: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: number | null
    formSectionId: number | null
    question: string | null
    questionType: QuestionType | null
    inputType: InputType | null
    order: number | null
    scriptText: string | null
    optout: boolean | null
    optoutText: string | null
    created: Date | null
    updated: Date | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: number | null
    formSectionId: number | null
    question: string | null
    questionType: QuestionType | null
    inputType: InputType | null
    order: number | null
    scriptText: string | null
    optout: boolean | null
    optoutText: string | null
    created: Date | null
    updated: Date | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    formSectionId: number
    question: number
    questionType: number
    inputType: number
    order: number
    scriptText: number
    optout: number
    optoutText: number
    created: number
    updated: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    id?: true
    formSectionId?: true
    order?: true
  }

  export type QuestionSumAggregateInputType = {
    id?: true
    formSectionId?: true
    order?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    formSectionId?: true
    question?: true
    questionType?: true
    inputType?: true
    order?: true
    scriptText?: true
    optout?: true
    optoutText?: true
    created?: true
    updated?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    formSectionId?: true
    question?: true
    questionType?: true
    inputType?: true
    order?: true
    scriptText?: true
    optout?: true
    optoutText?: true
    created?: true
    updated?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    formSectionId?: true
    question?: true
    questionType?: true
    inputType?: true
    order?: true
    scriptText?: true
    optout?: true
    optoutText?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type QuestionAggregateArgs = {
    /**
     * Filter which Question to aggregate.
     * 
    **/
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs = {
    where?: QuestionWhereInput
    orderBy?: Enumerable<QuestionOrderByWithAggregationInput>
    by: Array<QuestionScalarFieldEnum>
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }


  export type QuestionGroupByOutputType = {
    id: number
    formSectionId: number
    question: string
    questionType: QuestionType
    inputType: InputType | null
    order: number
    scriptText: string
    optout: boolean
    optoutText: string
    created: Date
    updated: Date
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect = {
    id?: boolean
    formSectionId?: boolean
    question?: boolean
    questionType?: boolean
    inputType?: boolean
    order?: boolean
    scriptText?: boolean
    optout?: boolean
    optoutText?: boolean
    created?: boolean
    updated?: boolean
    answers?: boolean | AnswerFindManyArgs
    options?: boolean | OptionFindManyArgs
    subform?: boolean | SubformArgs
    formSection?: boolean | FormSectionArgs
    optionRule?: boolean | OptionRuleFindManyArgs
    rules?: boolean | QuestionRuleFindManyArgs
    questionAnswerRef?: boolean | QuestionRuleFindManyArgs
    questionFormatRule?: boolean | QuestionFormatRuleFindManyArgs
    questionFormatAnswerRef?: boolean | QuestionFormatRuleFindManyArgs
    _count?: boolean | QuestionCountOutputTypeArgs
  }


  export type QuestionInclude = {
    answers?: boolean | AnswerFindManyArgs
    options?: boolean | OptionFindManyArgs
    subform?: boolean | SubformArgs
    formSection?: boolean | FormSectionArgs
    optionRule?: boolean | OptionRuleFindManyArgs
    rules?: boolean | QuestionRuleFindManyArgs
    questionAnswerRef?: boolean | QuestionRuleFindManyArgs
    questionFormatRule?: boolean | QuestionFormatRuleFindManyArgs
    questionFormatAnswerRef?: boolean | QuestionFormatRuleFindManyArgs
    _count?: boolean | QuestionCountOutputTypeArgs
  } 

  export type QuestionGetPayload<S extends boolean | null | undefined | QuestionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Question :
    S extends undefined ? never :
    S extends { include: any } & (QuestionArgs | QuestionFindManyArgs)
    ? Question  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'answers' ? Array < AnswerGetPayload<S['include'][P]>>  :
        P extends 'options' ? Array < OptionGetPayload<S['include'][P]>>  :
        P extends 'subform' ? SubformGetPayload<S['include'][P]> | null :
        P extends 'formSection' ? FormSectionGetPayload<S['include'][P]> :
        P extends 'optionRule' ? Array < OptionRuleGetPayload<S['include'][P]>>  :
        P extends 'rules' ? Array < QuestionRuleGetPayload<S['include'][P]>>  :
        P extends 'questionAnswerRef' ? Array < QuestionRuleGetPayload<S['include'][P]>>  :
        P extends 'questionFormatRule' ? Array < QuestionFormatRuleGetPayload<S['include'][P]>>  :
        P extends 'questionFormatAnswerRef' ? Array < QuestionFormatRuleGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuestionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (QuestionArgs | QuestionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'answers' ? Array < AnswerGetPayload<S['select'][P]>>  :
        P extends 'options' ? Array < OptionGetPayload<S['select'][P]>>  :
        P extends 'subform' ? SubformGetPayload<S['select'][P]> | null :
        P extends 'formSection' ? FormSectionGetPayload<S['select'][P]> :
        P extends 'optionRule' ? Array < OptionRuleGetPayload<S['select'][P]>>  :
        P extends 'rules' ? Array < QuestionRuleGetPayload<S['select'][P]>>  :
        P extends 'questionAnswerRef' ? Array < QuestionRuleGetPayload<S['select'][P]>>  :
        P extends 'questionFormatRule' ? Array < QuestionFormatRuleGetPayload<S['select'][P]>>  :
        P extends 'questionFormatAnswerRef' ? Array < QuestionFormatRuleGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuestionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Question ? Question[P] : never
  } 
      : Question


  type QuestionCountArgs = Merge<
    Omit<QuestionFindManyArgs, 'select' | 'include'> & {
      select?: QuestionCountAggregateInputType | true
    }
  >

  export interface QuestionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Question'> extends True ? Prisma__QuestionClient<QuestionGetPayload<T>> : Prisma__QuestionClient<QuestionGetPayload<T> | null, null>

    /**
     * Find one Question that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionFindUniqueOrThrowArgs>
    ): Prisma__QuestionClient<QuestionGetPayload<T>>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Question'> extends True ? Prisma__QuestionClient<QuestionGetPayload<T>> : Prisma__QuestionClient<QuestionGetPayload<T> | null, null>

    /**
     * Find the first Question that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionFindFirstOrThrowArgs>
    ): Prisma__QuestionClient<QuestionGetPayload<T>>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionFindManyArgs>(
      args?: SelectSubset<T, QuestionFindManyArgs>
    ): PrismaPromise<Array<QuestionGetPayload<T>>>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
    **/
    create<T extends QuestionCreateArgs>(
      args: SelectSubset<T, QuestionCreateArgs>
    ): Prisma__QuestionClient<QuestionGetPayload<T>>

    /**
     * Create many Questions.
     *     @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     *     @example
     *     // Create many Questions
     *     const question = await prisma.question.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionCreateManyArgs>(
      args?: SelectSubset<T, QuestionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
    **/
    delete<T extends QuestionDeleteArgs>(
      args: SelectSubset<T, QuestionDeleteArgs>
    ): Prisma__QuestionClient<QuestionGetPayload<T>>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionUpdateArgs>(
      args: SelectSubset<T, QuestionUpdateArgs>
    ): Prisma__QuestionClient<QuestionGetPayload<T>>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionDeleteManyArgs>(
      args?: SelectSubset<T, QuestionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionUpdateManyArgs>(
      args: SelectSubset<T, QuestionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionUpsertArgs>(
      args: SelectSubset<T, QuestionUpsertArgs>
    ): Prisma__QuestionClient<QuestionGetPayload<T>>

    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    answers<T extends AnswerFindManyArgs= {}>(args?: Subset<T, AnswerFindManyArgs>): PrismaPromise<Array<AnswerGetPayload<T>>| Null>;

    options<T extends OptionFindManyArgs= {}>(args?: Subset<T, OptionFindManyArgs>): PrismaPromise<Array<OptionGetPayload<T>>| Null>;

    subform<T extends SubformArgs= {}>(args?: Subset<T, SubformArgs>): Prisma__SubformClient<SubformGetPayload<T> | Null>;

    formSection<T extends FormSectionArgs= {}>(args?: Subset<T, FormSectionArgs>): Prisma__FormSectionClient<FormSectionGetPayload<T> | Null>;

    optionRule<T extends OptionRuleFindManyArgs= {}>(args?: Subset<T, OptionRuleFindManyArgs>): PrismaPromise<Array<OptionRuleGetPayload<T>>| Null>;

    rules<T extends QuestionRuleFindManyArgs= {}>(args?: Subset<T, QuestionRuleFindManyArgs>): PrismaPromise<Array<QuestionRuleGetPayload<T>>| Null>;

    questionAnswerRef<T extends QuestionRuleFindManyArgs= {}>(args?: Subset<T, QuestionRuleFindManyArgs>): PrismaPromise<Array<QuestionRuleGetPayload<T>>| Null>;

    questionFormatRule<T extends QuestionFormatRuleFindManyArgs= {}>(args?: Subset<T, QuestionFormatRuleFindManyArgs>): PrismaPromise<Array<QuestionFormatRuleGetPayload<T>>| Null>;

    questionFormatAnswerRef<T extends QuestionFormatRuleFindManyArgs= {}>(args?: Subset<T, QuestionFormatRuleFindManyArgs>): PrismaPromise<Array<QuestionFormatRuleGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Question base type for findUnique actions
   */
  export type QuestionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * Filter, which Question to fetch.
     * 
    **/
    where: QuestionWhereUniqueInput
  }

  /**
   * Question: findUnique
   */
  export interface QuestionFindUniqueArgs extends QuestionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * Filter, which Question to fetch.
     * 
    **/
    where: QuestionWhereUniqueInput
  }


  /**
   * Question base type for findFirst actions
   */
  export type QuestionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * Filter, which Question to fetch.
     * 
    **/
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     * 
    **/
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     * 
    **/
    distinct?: Enumerable<QuestionScalarFieldEnum>
  }

  /**
   * Question: findFirst
   */
  export interface QuestionFindFirstArgs extends QuestionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * Filter, which Question to fetch.
     * 
    **/
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     * 
    **/
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     * 
    **/
    distinct?: Enumerable<QuestionScalarFieldEnum>
  }


  /**
   * Question findMany
   */
  export type QuestionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * Filter, which Questions to fetch.
     * 
    **/
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     * 
    **/
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionScalarFieldEnum>
  }


  /**
   * Question create
   */
  export type QuestionCreateArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * The data needed to create a Question.
     * 
    **/
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }


  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs = {
    /**
     * The data used to create many Questions.
     * 
    **/
    data: Enumerable<QuestionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Question update
   */
  export type QuestionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * The data needed to update a Question.
     * 
    **/
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     * 
    **/
    where: QuestionWhereUniqueInput
  }


  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs = {
    /**
     * The data used to update Questions.
     * 
    **/
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     * 
    **/
    where?: QuestionWhereInput
  }


  /**
   * Question upsert
   */
  export type QuestionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * The filter to search for the Question to update in case it exists.
     * 
    **/
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     * 
    **/
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }


  /**
   * Question delete
   */
  export type QuestionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
    /**
     * Filter which Question to delete.
     * 
    **/
    where: QuestionWhereUniqueInput
  }


  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs = {
    /**
     * Filter which Questions to delete
     * 
    **/
    where?: QuestionWhereInput
  }


  /**
   * Question without action
   */
  export type QuestionArgs = {
    /**
     * Select specific fields to fetch from the Question
     * 
    **/
    select?: QuestionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionInclude | null
  }



  /**
   * Model Answer
   */


  export type AggregateAnswer = {
    _count: AnswerCountAggregateOutputType | null
    _avg: AnswerAvgAggregateOutputType | null
    _sum: AnswerSumAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  export type AnswerAvgAggregateOutputType = {
    id: number | null
    questionId: number | null
    claimantId: number | null
    sessionId: number | null
    optionId: number | null
  }

  export type AnswerSumAggregateOutputType = {
    id: number | null
    questionId: number | null
    claimantId: number | null
    sessionId: number | null
    optionId: number | null
  }

  export type AnswerMinAggregateOutputType = {
    id: number | null
    questionId: number | null
    claimantId: number | null
    sessionId: number | null
    optionId: number | null
    value: string | null
    created: Date | null
    updated: Date | null
  }

  export type AnswerMaxAggregateOutputType = {
    id: number | null
    questionId: number | null
    claimantId: number | null
    sessionId: number | null
    optionId: number | null
    value: string | null
    created: Date | null
    updated: Date | null
  }

  export type AnswerCountAggregateOutputType = {
    id: number
    questionId: number
    claimantId: number
    sessionId: number
    optionId: number
    value: number
    created: number
    updated: number
    _all: number
  }


  export type AnswerAvgAggregateInputType = {
    id?: true
    questionId?: true
    claimantId?: true
    sessionId?: true
    optionId?: true
  }

  export type AnswerSumAggregateInputType = {
    id?: true
    questionId?: true
    claimantId?: true
    sessionId?: true
    optionId?: true
  }

  export type AnswerMinAggregateInputType = {
    id?: true
    questionId?: true
    claimantId?: true
    sessionId?: true
    optionId?: true
    value?: true
    created?: true
    updated?: true
  }

  export type AnswerMaxAggregateInputType = {
    id?: true
    questionId?: true
    claimantId?: true
    sessionId?: true
    optionId?: true
    value?: true
    created?: true
    updated?: true
  }

  export type AnswerCountAggregateInputType = {
    id?: true
    questionId?: true
    claimantId?: true
    sessionId?: true
    optionId?: true
    value?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type AnswerAggregateArgs = {
    /**
     * Filter which Answer to aggregate.
     * 
    **/
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     * 
    **/
    orderBy?: Enumerable<AnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Answers
    **/
    _count?: true | AnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswerMaxAggregateInputType
  }

  export type GetAnswerAggregateType<T extends AnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswer[P]>
      : GetScalarType<T[P], AggregateAnswer[P]>
  }




  export type AnswerGroupByArgs = {
    where?: AnswerWhereInput
    orderBy?: Enumerable<AnswerOrderByWithAggregationInput>
    by: Array<AnswerScalarFieldEnum>
    having?: AnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswerCountAggregateInputType | true
    _avg?: AnswerAvgAggregateInputType
    _sum?: AnswerSumAggregateInputType
    _min?: AnswerMinAggregateInputType
    _max?: AnswerMaxAggregateInputType
  }


  export type AnswerGroupByOutputType = {
    id: number
    questionId: number
    claimantId: number
    sessionId: number
    optionId: number | null
    value: string | null
    created: Date
    updated: Date
    _count: AnswerCountAggregateOutputType | null
    _avg: AnswerAvgAggregateOutputType | null
    _sum: AnswerSumAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  type GetAnswerGroupByPayload<T extends AnswerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswerGroupByOutputType[P]>
            : GetScalarType<T[P], AnswerGroupByOutputType[P]>
        }
      >
    >


  export type AnswerSelect = {
    id?: boolean
    questionId?: boolean
    claimantId?: boolean
    sessionId?: boolean
    optionId?: boolean
    value?: boolean
    created?: boolean
    updated?: boolean
    question?: boolean | QuestionArgs
    claimant?: boolean | ClaimantArgs
    option?: boolean | OptionArgs
    callSession?: boolean | CallSessionArgs
  }


  export type AnswerInclude = {
    question?: boolean | QuestionArgs
    claimant?: boolean | ClaimantArgs
    option?: boolean | OptionArgs
    callSession?: boolean | CallSessionArgs
  } 

  export type AnswerGetPayload<S extends boolean | null | undefined | AnswerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Answer :
    S extends undefined ? never :
    S extends { include: any } & (AnswerArgs | AnswerFindManyArgs)
    ? Answer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'question' ? QuestionGetPayload<S['include'][P]> :
        P extends 'claimant' ? ClaimantGetPayload<S['include'][P]> :
        P extends 'option' ? OptionGetPayload<S['include'][P]> | null :
        P extends 'callSession' ? CallSessionGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AnswerArgs | AnswerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'question' ? QuestionGetPayload<S['select'][P]> :
        P extends 'claimant' ? ClaimantGetPayload<S['select'][P]> :
        P extends 'option' ? OptionGetPayload<S['select'][P]> | null :
        P extends 'callSession' ? CallSessionGetPayload<S['select'][P]> :  P extends keyof Answer ? Answer[P] : never
  } 
      : Answer


  type AnswerCountArgs = Merge<
    Omit<AnswerFindManyArgs, 'select' | 'include'> & {
      select?: AnswerCountAggregateInputType | true
    }
  >

  export interface AnswerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Answer that matches the filter.
     * @param {AnswerFindUniqueArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnswerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AnswerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Answer'> extends True ? Prisma__AnswerClient<AnswerGetPayload<T>> : Prisma__AnswerClient<AnswerGetPayload<T> | null, null>

    /**
     * Find one Answer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AnswerFindUniqueOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AnswerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AnswerFindUniqueOrThrowArgs>
    ): Prisma__AnswerClient<AnswerGetPayload<T>>

    /**
     * Find the first Answer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnswerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AnswerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Answer'> extends True ? Prisma__AnswerClient<AnswerGetPayload<T>> : Prisma__AnswerClient<AnswerGetPayload<T> | null, null>

    /**
     * Find the first Answer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AnswerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AnswerFindFirstOrThrowArgs>
    ): Prisma__AnswerClient<AnswerGetPayload<T>>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answer.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answerWithIdOnly = await prisma.answer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AnswerFindManyArgs>(
      args?: SelectSubset<T, AnswerFindManyArgs>
    ): PrismaPromise<Array<AnswerGetPayload<T>>>

    /**
     * Create a Answer.
     * @param {AnswerCreateArgs} args - Arguments to create a Answer.
     * @example
     * // Create one Answer
     * const Answer = await prisma.answer.create({
     *   data: {
     *     // ... data to create a Answer
     *   }
     * })
     * 
    **/
    create<T extends AnswerCreateArgs>(
      args: SelectSubset<T, AnswerCreateArgs>
    ): Prisma__AnswerClient<AnswerGetPayload<T>>

    /**
     * Create many Answers.
     *     @param {AnswerCreateManyArgs} args - Arguments to create many Answers.
     *     @example
     *     // Create many Answers
     *     const answer = await prisma.answer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AnswerCreateManyArgs>(
      args?: SelectSubset<T, AnswerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Answer.
     * @param {AnswerDeleteArgs} args - Arguments to delete one Answer.
     * @example
     * // Delete one Answer
     * const Answer = await prisma.answer.delete({
     *   where: {
     *     // ... filter to delete one Answer
     *   }
     * })
     * 
    **/
    delete<T extends AnswerDeleteArgs>(
      args: SelectSubset<T, AnswerDeleteArgs>
    ): Prisma__AnswerClient<AnswerGetPayload<T>>

    /**
     * Update one Answer.
     * @param {AnswerUpdateArgs} args - Arguments to update one Answer.
     * @example
     * // Update one Answer
     * const answer = await prisma.answer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnswerUpdateArgs>(
      args: SelectSubset<T, AnswerUpdateArgs>
    ): Prisma__AnswerClient<AnswerGetPayload<T>>

    /**
     * Delete zero or more Answers.
     * @param {AnswerDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnswerDeleteManyArgs>(
      args?: SelectSubset<T, AnswerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answer = await prisma.answer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnswerUpdateManyArgs>(
      args: SelectSubset<T, AnswerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Answer.
     * @param {AnswerUpsertArgs} args - Arguments to update or create a Answer.
     * @example
     * // Update or create a Answer
     * const answer = await prisma.answer.upsert({
     *   create: {
     *     // ... data to create a Answer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answer we want to update
     *   }
     * })
    **/
    upsert<T extends AnswerUpsertArgs>(
      args: SelectSubset<T, AnswerUpsertArgs>
    ): Prisma__AnswerClient<AnswerGetPayload<T>>

    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answer.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends AnswerCountArgs>(
      args?: Subset<T, AnswerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswerAggregateArgs>(args: Subset<T, AnswerAggregateArgs>): PrismaPromise<GetAnswerAggregateType<T>>

    /**
     * Group by Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswerGroupByArgs['orderBy'] }
        : { orderBy?: AnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswerGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Answer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AnswerClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    question<T extends QuestionArgs= {}>(args?: Subset<T, QuestionArgs>): Prisma__QuestionClient<QuestionGetPayload<T> | Null>;

    claimant<T extends ClaimantArgs= {}>(args?: Subset<T, ClaimantArgs>): Prisma__ClaimantClient<ClaimantGetPayload<T> | Null>;

    option<T extends OptionArgs= {}>(args?: Subset<T, OptionArgs>): Prisma__OptionClient<OptionGetPayload<T> | Null>;

    callSession<T extends CallSessionArgs= {}>(args?: Subset<T, CallSessionArgs>): Prisma__CallSessionClient<CallSessionGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Answer base type for findUnique actions
   */
  export type AnswerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * Filter, which Answer to fetch.
     * 
    **/
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer: findUnique
   */
  export interface AnswerFindUniqueArgs extends AnswerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Answer findUniqueOrThrow
   */
  export type AnswerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * Filter, which Answer to fetch.
     * 
    **/
    where: AnswerWhereUniqueInput
  }


  /**
   * Answer base type for findFirst actions
   */
  export type AnswerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * Filter, which Answer to fetch.
     * 
    **/
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     * 
    **/
    orderBy?: Enumerable<AnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     * 
    **/
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     * 
    **/
    distinct?: Enumerable<AnswerScalarFieldEnum>
  }

  /**
   * Answer: findFirst
   */
  export interface AnswerFindFirstArgs extends AnswerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Answer findFirstOrThrow
   */
  export type AnswerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * Filter, which Answer to fetch.
     * 
    **/
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     * 
    **/
    orderBy?: Enumerable<AnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     * 
    **/
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     * 
    **/
    distinct?: Enumerable<AnswerScalarFieldEnum>
  }


  /**
   * Answer findMany
   */
  export type AnswerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * Filter, which Answers to fetch.
     * 
    **/
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     * 
    **/
    orderBy?: Enumerable<AnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Answers.
     * 
    **/
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AnswerScalarFieldEnum>
  }


  /**
   * Answer create
   */
  export type AnswerCreateArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * The data needed to create a Answer.
     * 
    **/
    data: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
  }


  /**
   * Answer createMany
   */
  export type AnswerCreateManyArgs = {
    /**
     * The data used to create many Answers.
     * 
    **/
    data: Enumerable<AnswerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Answer update
   */
  export type AnswerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * The data needed to update a Answer.
     * 
    **/
    data: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
    /**
     * Choose, which Answer to update.
     * 
    **/
    where: AnswerWhereUniqueInput
  }


  /**
   * Answer updateMany
   */
  export type AnswerUpdateManyArgs = {
    /**
     * The data used to update Answers.
     * 
    **/
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     * 
    **/
    where?: AnswerWhereInput
  }


  /**
   * Answer upsert
   */
  export type AnswerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * The filter to search for the Answer to update in case it exists.
     * 
    **/
    where: AnswerWhereUniqueInput
    /**
     * In case the Answer found by the `where` argument doesn't exist, create a new Answer with this data.
     * 
    **/
    create: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
    /**
     * In case the Answer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
  }


  /**
   * Answer delete
   */
  export type AnswerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
    /**
     * Filter which Answer to delete.
     * 
    **/
    where: AnswerWhereUniqueInput
  }


  /**
   * Answer deleteMany
   */
  export type AnswerDeleteManyArgs = {
    /**
     * Filter which Answers to delete
     * 
    **/
    where?: AnswerWhereInput
  }


  /**
   * Answer without action
   */
  export type AnswerArgs = {
    /**
     * Select specific fields to fetch from the Answer
     * 
    **/
    select?: AnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AnswerInclude | null
  }



  /**
   * Model Subform
   */


  export type AggregateSubform = {
    _count: SubformCountAggregateOutputType | null
    _avg: SubformAvgAggregateOutputType | null
    _sum: SubformSumAggregateOutputType | null
    _min: SubformMinAggregateOutputType | null
    _max: SubformMaxAggregateOutputType | null
  }

  export type SubformAvgAggregateOutputType = {
    id: number | null
    questionId: number | null
  }

  export type SubformSumAggregateOutputType = {
    id: number | null
    questionId: number | null
  }

  export type SubformMinAggregateOutputType = {
    id: number | null
    questionId: number | null
    name: string | null
    created: Date | null
    updated: Date | null
  }

  export type SubformMaxAggregateOutputType = {
    id: number | null
    questionId: number | null
    name: string | null
    created: Date | null
    updated: Date | null
  }

  export type SubformCountAggregateOutputType = {
    id: number
    questionId: number
    name: number
    created: number
    updated: number
    _all: number
  }


  export type SubformAvgAggregateInputType = {
    id?: true
    questionId?: true
  }

  export type SubformSumAggregateInputType = {
    id?: true
    questionId?: true
  }

  export type SubformMinAggregateInputType = {
    id?: true
    questionId?: true
    name?: true
    created?: true
    updated?: true
  }

  export type SubformMaxAggregateInputType = {
    id?: true
    questionId?: true
    name?: true
    created?: true
    updated?: true
  }

  export type SubformCountAggregateInputType = {
    id?: true
    questionId?: true
    name?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type SubformAggregateArgs = {
    /**
     * Filter which Subform to aggregate.
     * 
    **/
    where?: SubformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subforms to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subforms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subforms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subforms
    **/
    _count?: true | SubformCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubformAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubformSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubformMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubformMaxAggregateInputType
  }

  export type GetSubformAggregateType<T extends SubformAggregateArgs> = {
        [P in keyof T & keyof AggregateSubform]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubform[P]>
      : GetScalarType<T[P], AggregateSubform[P]>
  }




  export type SubformGroupByArgs = {
    where?: SubformWhereInput
    orderBy?: Enumerable<SubformOrderByWithAggregationInput>
    by: Array<SubformScalarFieldEnum>
    having?: SubformScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubformCountAggregateInputType | true
    _avg?: SubformAvgAggregateInputType
    _sum?: SubformSumAggregateInputType
    _min?: SubformMinAggregateInputType
    _max?: SubformMaxAggregateInputType
  }


  export type SubformGroupByOutputType = {
    id: number
    questionId: number
    name: string
    created: Date
    updated: Date
    _count: SubformCountAggregateOutputType | null
    _avg: SubformAvgAggregateOutputType | null
    _sum: SubformSumAggregateOutputType | null
    _min: SubformMinAggregateOutputType | null
    _max: SubformMaxAggregateOutputType | null
  }

  type GetSubformGroupByPayload<T extends SubformGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubformGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubformGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubformGroupByOutputType[P]>
            : GetScalarType<T[P], SubformGroupByOutputType[P]>
        }
      >
    >


  export type SubformSelect = {
    id?: boolean
    questionId?: boolean
    name?: boolean
    created?: boolean
    updated?: boolean
    subformFields?: boolean | SubformFieldFindManyArgs
    question?: boolean | QuestionArgs
    _count?: boolean | SubformCountOutputTypeArgs
  }


  export type SubformInclude = {
    subformFields?: boolean | SubformFieldFindManyArgs
    question?: boolean | QuestionArgs
    _count?: boolean | SubformCountOutputTypeArgs
  } 

  export type SubformGetPayload<S extends boolean | null | undefined | SubformArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Subform :
    S extends undefined ? never :
    S extends { include: any } & (SubformArgs | SubformFindManyArgs)
    ? Subform  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'subformFields' ? Array < SubformFieldGetPayload<S['include'][P]>>  :
        P extends 'question' ? QuestionGetPayload<S['include'][P]> :
        P extends '_count' ? SubformCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SubformArgs | SubformFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'subformFields' ? Array < SubformFieldGetPayload<S['select'][P]>>  :
        P extends 'question' ? QuestionGetPayload<S['select'][P]> :
        P extends '_count' ? SubformCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Subform ? Subform[P] : never
  } 
      : Subform


  type SubformCountArgs = Merge<
    Omit<SubformFindManyArgs, 'select' | 'include'> & {
      select?: SubformCountAggregateInputType | true
    }
  >

  export interface SubformDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Subform that matches the filter.
     * @param {SubformFindUniqueArgs} args - Arguments to find a Subform
     * @example
     * // Get one Subform
     * const subform = await prisma.subform.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubformFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubformFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Subform'> extends True ? Prisma__SubformClient<SubformGetPayload<T>> : Prisma__SubformClient<SubformGetPayload<T> | null, null>

    /**
     * Find one Subform that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubformFindUniqueOrThrowArgs} args - Arguments to find a Subform
     * @example
     * // Get one Subform
     * const subform = await prisma.subform.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubformFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubformFindUniqueOrThrowArgs>
    ): Prisma__SubformClient<SubformGetPayload<T>>

    /**
     * Find the first Subform that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFindFirstArgs} args - Arguments to find a Subform
     * @example
     * // Get one Subform
     * const subform = await prisma.subform.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubformFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubformFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Subform'> extends True ? Prisma__SubformClient<SubformGetPayload<T>> : Prisma__SubformClient<SubformGetPayload<T> | null, null>

    /**
     * Find the first Subform that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFindFirstOrThrowArgs} args - Arguments to find a Subform
     * @example
     * // Get one Subform
     * const subform = await prisma.subform.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubformFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubformFindFirstOrThrowArgs>
    ): Prisma__SubformClient<SubformGetPayload<T>>

    /**
     * Find zero or more Subforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subforms
     * const subforms = await prisma.subform.findMany()
     * 
     * // Get first 10 Subforms
     * const subforms = await prisma.subform.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subformWithIdOnly = await prisma.subform.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubformFindManyArgs>(
      args?: SelectSubset<T, SubformFindManyArgs>
    ): PrismaPromise<Array<SubformGetPayload<T>>>

    /**
     * Create a Subform.
     * @param {SubformCreateArgs} args - Arguments to create a Subform.
     * @example
     * // Create one Subform
     * const Subform = await prisma.subform.create({
     *   data: {
     *     // ... data to create a Subform
     *   }
     * })
     * 
    **/
    create<T extends SubformCreateArgs>(
      args: SelectSubset<T, SubformCreateArgs>
    ): Prisma__SubformClient<SubformGetPayload<T>>

    /**
     * Create many Subforms.
     *     @param {SubformCreateManyArgs} args - Arguments to create many Subforms.
     *     @example
     *     // Create many Subforms
     *     const subform = await prisma.subform.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubformCreateManyArgs>(
      args?: SelectSubset<T, SubformCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subform.
     * @param {SubformDeleteArgs} args - Arguments to delete one Subform.
     * @example
     * // Delete one Subform
     * const Subform = await prisma.subform.delete({
     *   where: {
     *     // ... filter to delete one Subform
     *   }
     * })
     * 
    **/
    delete<T extends SubformDeleteArgs>(
      args: SelectSubset<T, SubformDeleteArgs>
    ): Prisma__SubformClient<SubformGetPayload<T>>

    /**
     * Update one Subform.
     * @param {SubformUpdateArgs} args - Arguments to update one Subform.
     * @example
     * // Update one Subform
     * const subform = await prisma.subform.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubformUpdateArgs>(
      args: SelectSubset<T, SubformUpdateArgs>
    ): Prisma__SubformClient<SubformGetPayload<T>>

    /**
     * Delete zero or more Subforms.
     * @param {SubformDeleteManyArgs} args - Arguments to filter Subforms to delete.
     * @example
     * // Delete a few Subforms
     * const { count } = await prisma.subform.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubformDeleteManyArgs>(
      args?: SelectSubset<T, SubformDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subforms
     * const subform = await prisma.subform.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubformUpdateManyArgs>(
      args: SelectSubset<T, SubformUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subform.
     * @param {SubformUpsertArgs} args - Arguments to update or create a Subform.
     * @example
     * // Update or create a Subform
     * const subform = await prisma.subform.upsert({
     *   create: {
     *     // ... data to create a Subform
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subform we want to update
     *   }
     * })
    **/
    upsert<T extends SubformUpsertArgs>(
      args: SelectSubset<T, SubformUpsertArgs>
    ): Prisma__SubformClient<SubformGetPayload<T>>

    /**
     * Count the number of Subforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformCountArgs} args - Arguments to filter Subforms to count.
     * @example
     * // Count the number of Subforms
     * const count = await prisma.subform.count({
     *   where: {
     *     // ... the filter for the Subforms we want to count
     *   }
     * })
    **/
    count<T extends SubformCountArgs>(
      args?: Subset<T, SubformCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubformCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubformAggregateArgs>(args: Subset<T, SubformAggregateArgs>): PrismaPromise<GetSubformAggregateType<T>>

    /**
     * Group by Subform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubformGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubformGroupByArgs['orderBy'] }
        : { orderBy?: SubformGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubformGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubformGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Subform.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubformClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    subformFields<T extends SubformFieldFindManyArgs= {}>(args?: Subset<T, SubformFieldFindManyArgs>): PrismaPromise<Array<SubformFieldGetPayload<T>>| Null>;

    question<T extends QuestionArgs= {}>(args?: Subset<T, QuestionArgs>): Prisma__QuestionClient<QuestionGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Subform base type for findUnique actions
   */
  export type SubformFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Subform
     * 
    **/
    select?: SubformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformInclude | null
    /**
     * Filter, which Subform to fetch.
     * 
    **/
    where: SubformWhereUniqueInput
  }

  /**
   * Subform: findUnique
   */
  export interface SubformFindUniqueArgs extends SubformFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subform findUniqueOrThrow
   */
  export type SubformFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Subform
     * 
    **/
    select?: SubformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformInclude | null
    /**
     * Filter, which Subform to fetch.
     * 
    **/
    where: SubformWhereUniqueInput
  }


  /**
   * Subform base type for findFirst actions
   */
  export type SubformFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Subform
     * 
    **/
    select?: SubformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformInclude | null
    /**
     * Filter, which Subform to fetch.
     * 
    **/
    where?: SubformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subforms to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subforms.
     * 
    **/
    cursor?: SubformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subforms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subforms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subforms.
     * 
    **/
    distinct?: Enumerable<SubformScalarFieldEnum>
  }

  /**
   * Subform: findFirst
   */
  export interface SubformFindFirstArgs extends SubformFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subform findFirstOrThrow
   */
  export type SubformFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Subform
     * 
    **/
    select?: SubformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformInclude | null
    /**
     * Filter, which Subform to fetch.
     * 
    **/
    where?: SubformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subforms to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subforms.
     * 
    **/
    cursor?: SubformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subforms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subforms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subforms.
     * 
    **/
    distinct?: Enumerable<SubformScalarFieldEnum>
  }


  /**
   * Subform findMany
   */
  export type SubformFindManyArgs = {
    /**
     * Select specific fields to fetch from the Subform
     * 
    **/
    select?: SubformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformInclude | null
    /**
     * Filter, which Subforms to fetch.
     * 
    **/
    where?: SubformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subforms to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subforms.
     * 
    **/
    cursor?: SubformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subforms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subforms.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubformScalarFieldEnum>
  }


  /**
   * Subform create
   */
  export type SubformCreateArgs = {
    /**
     * Select specific fields to fetch from the Subform
     * 
    **/
    select?: SubformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformInclude | null
    /**
     * The data needed to create a Subform.
     * 
    **/
    data: XOR<SubformCreateInput, SubformUncheckedCreateInput>
  }


  /**
   * Subform createMany
   */
  export type SubformCreateManyArgs = {
    /**
     * The data used to create many Subforms.
     * 
    **/
    data: Enumerable<SubformCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Subform update
   */
  export type SubformUpdateArgs = {
    /**
     * Select specific fields to fetch from the Subform
     * 
    **/
    select?: SubformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformInclude | null
    /**
     * The data needed to update a Subform.
     * 
    **/
    data: XOR<SubformUpdateInput, SubformUncheckedUpdateInput>
    /**
     * Choose, which Subform to update.
     * 
    **/
    where: SubformWhereUniqueInput
  }


  /**
   * Subform updateMany
   */
  export type SubformUpdateManyArgs = {
    /**
     * The data used to update Subforms.
     * 
    **/
    data: XOR<SubformUpdateManyMutationInput, SubformUncheckedUpdateManyInput>
    /**
     * Filter which Subforms to update
     * 
    **/
    where?: SubformWhereInput
  }


  /**
   * Subform upsert
   */
  export type SubformUpsertArgs = {
    /**
     * Select specific fields to fetch from the Subform
     * 
    **/
    select?: SubformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformInclude | null
    /**
     * The filter to search for the Subform to update in case it exists.
     * 
    **/
    where: SubformWhereUniqueInput
    /**
     * In case the Subform found by the `where` argument doesn't exist, create a new Subform with this data.
     * 
    **/
    create: XOR<SubformCreateInput, SubformUncheckedCreateInput>
    /**
     * In case the Subform was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubformUpdateInput, SubformUncheckedUpdateInput>
  }


  /**
   * Subform delete
   */
  export type SubformDeleteArgs = {
    /**
     * Select specific fields to fetch from the Subform
     * 
    **/
    select?: SubformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformInclude | null
    /**
     * Filter which Subform to delete.
     * 
    **/
    where: SubformWhereUniqueInput
  }


  /**
   * Subform deleteMany
   */
  export type SubformDeleteManyArgs = {
    /**
     * Filter which Subforms to delete
     * 
    **/
    where?: SubformWhereInput
  }


  /**
   * Subform without action
   */
  export type SubformArgs = {
    /**
     * Select specific fields to fetch from the Subform
     * 
    **/
    select?: SubformSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformInclude | null
  }



  /**
   * Model SubformField
   */


  export type AggregateSubformField = {
    _count: SubformFieldCountAggregateOutputType | null
    _avg: SubformFieldAvgAggregateOutputType | null
    _sum: SubformFieldSumAggregateOutputType | null
    _min: SubformFieldMinAggregateOutputType | null
    _max: SubformFieldMaxAggregateOutputType | null
  }

  export type SubformFieldAvgAggregateOutputType = {
    id: number | null
    subformId: number | null
    max: number | null
  }

  export type SubformFieldSumAggregateOutputType = {
    id: number | null
    subformId: number | null
    max: number | null
  }

  export type SubformFieldMinAggregateOutputType = {
    id: number | null
    subformId: number | null
    fieldType: SubFormFieldType | null
    inputType: InputType | null
    max: number | null
    name: string | null
    label: string | null
    required: boolean | null
    created: Date | null
    updated: Date | null
  }

  export type SubformFieldMaxAggregateOutputType = {
    id: number | null
    subformId: number | null
    fieldType: SubFormFieldType | null
    inputType: InputType | null
    max: number | null
    name: string | null
    label: string | null
    required: boolean | null
    created: Date | null
    updated: Date | null
  }

  export type SubformFieldCountAggregateOutputType = {
    id: number
    subformId: number
    fieldType: number
    inputType: number
    max: number
    name: number
    label: number
    required: number
    created: number
    updated: number
    _all: number
  }


  export type SubformFieldAvgAggregateInputType = {
    id?: true
    subformId?: true
    max?: true
  }

  export type SubformFieldSumAggregateInputType = {
    id?: true
    subformId?: true
    max?: true
  }

  export type SubformFieldMinAggregateInputType = {
    id?: true
    subformId?: true
    fieldType?: true
    inputType?: true
    max?: true
    name?: true
    label?: true
    required?: true
    created?: true
    updated?: true
  }

  export type SubformFieldMaxAggregateInputType = {
    id?: true
    subformId?: true
    fieldType?: true
    inputType?: true
    max?: true
    name?: true
    label?: true
    required?: true
    created?: true
    updated?: true
  }

  export type SubformFieldCountAggregateInputType = {
    id?: true
    subformId?: true
    fieldType?: true
    inputType?: true
    max?: true
    name?: true
    label?: true
    required?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type SubformFieldAggregateArgs = {
    /**
     * Filter which SubformField to aggregate.
     * 
    **/
    where?: SubformFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubformFields to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformFieldOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubformFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubformFields from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubformFields.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubformFields
    **/
    _count?: true | SubformFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubformFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubformFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubformFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubformFieldMaxAggregateInputType
  }

  export type GetSubformFieldAggregateType<T extends SubformFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateSubformField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubformField[P]>
      : GetScalarType<T[P], AggregateSubformField[P]>
  }




  export type SubformFieldGroupByArgs = {
    where?: SubformFieldWhereInput
    orderBy?: Enumerable<SubformFieldOrderByWithAggregationInput>
    by: Array<SubformFieldScalarFieldEnum>
    having?: SubformFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubformFieldCountAggregateInputType | true
    _avg?: SubformFieldAvgAggregateInputType
    _sum?: SubformFieldSumAggregateInputType
    _min?: SubformFieldMinAggregateInputType
    _max?: SubformFieldMaxAggregateInputType
  }


  export type SubformFieldGroupByOutputType = {
    id: number
    subformId: number
    fieldType: SubFormFieldType
    inputType: InputType | null
    max: number | null
    name: string
    label: string
    required: boolean
    created: Date
    updated: Date
    _count: SubformFieldCountAggregateOutputType | null
    _avg: SubformFieldAvgAggregateOutputType | null
    _sum: SubformFieldSumAggregateOutputType | null
    _min: SubformFieldMinAggregateOutputType | null
    _max: SubformFieldMaxAggregateOutputType | null
  }

  type GetSubformFieldGroupByPayload<T extends SubformFieldGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubformFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubformFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubformFieldGroupByOutputType[P]>
            : GetScalarType<T[P], SubformFieldGroupByOutputType[P]>
        }
      >
    >


  export type SubformFieldSelect = {
    id?: boolean
    subformId?: boolean
    fieldType?: boolean
    inputType?: boolean
    max?: boolean
    name?: boolean
    label?: boolean
    required?: boolean
    created?: boolean
    updated?: boolean
    subformFieldOptions?: boolean | SubformFieldOptionFindManyArgs
    subformFieldAnswer?: boolean | SubformFieldAnswerFindManyArgs
    subForm?: boolean | SubformArgs
    _count?: boolean | SubformFieldCountOutputTypeArgs
  }


  export type SubformFieldInclude = {
    subformFieldOptions?: boolean | SubformFieldOptionFindManyArgs
    subformFieldAnswer?: boolean | SubformFieldAnswerFindManyArgs
    subForm?: boolean | SubformArgs
    _count?: boolean | SubformFieldCountOutputTypeArgs
  } 

  export type SubformFieldGetPayload<S extends boolean | null | undefined | SubformFieldArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SubformField :
    S extends undefined ? never :
    S extends { include: any } & (SubformFieldArgs | SubformFieldFindManyArgs)
    ? SubformField  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'subformFieldOptions' ? Array < SubformFieldOptionGetPayload<S['include'][P]>>  :
        P extends 'subformFieldAnswer' ? Array < SubformFieldAnswerGetPayload<S['include'][P]>>  :
        P extends 'subForm' ? SubformGetPayload<S['include'][P]> :
        P extends '_count' ? SubformFieldCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SubformFieldArgs | SubformFieldFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'subformFieldOptions' ? Array < SubformFieldOptionGetPayload<S['select'][P]>>  :
        P extends 'subformFieldAnswer' ? Array < SubformFieldAnswerGetPayload<S['select'][P]>>  :
        P extends 'subForm' ? SubformGetPayload<S['select'][P]> :
        P extends '_count' ? SubformFieldCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SubformField ? SubformField[P] : never
  } 
      : SubformField


  type SubformFieldCountArgs = Merge<
    Omit<SubformFieldFindManyArgs, 'select' | 'include'> & {
      select?: SubformFieldCountAggregateInputType | true
    }
  >

  export interface SubformFieldDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SubformField that matches the filter.
     * @param {SubformFieldFindUniqueArgs} args - Arguments to find a SubformField
     * @example
     * // Get one SubformField
     * const subformField = await prisma.subformField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubformFieldFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubformFieldFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubformField'> extends True ? Prisma__SubformFieldClient<SubformFieldGetPayload<T>> : Prisma__SubformFieldClient<SubformFieldGetPayload<T> | null, null>

    /**
     * Find one SubformField that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubformFieldFindUniqueOrThrowArgs} args - Arguments to find a SubformField
     * @example
     * // Get one SubformField
     * const subformField = await prisma.subformField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubformFieldFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubformFieldFindUniqueOrThrowArgs>
    ): Prisma__SubformFieldClient<SubformFieldGetPayload<T>>

    /**
     * Find the first SubformField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldFindFirstArgs} args - Arguments to find a SubformField
     * @example
     * // Get one SubformField
     * const subformField = await prisma.subformField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubformFieldFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubformFieldFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubformField'> extends True ? Prisma__SubformFieldClient<SubformFieldGetPayload<T>> : Prisma__SubformFieldClient<SubformFieldGetPayload<T> | null, null>

    /**
     * Find the first SubformField that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldFindFirstOrThrowArgs} args - Arguments to find a SubformField
     * @example
     * // Get one SubformField
     * const subformField = await prisma.subformField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubformFieldFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubformFieldFindFirstOrThrowArgs>
    ): Prisma__SubformFieldClient<SubformFieldGetPayload<T>>

    /**
     * Find zero or more SubformFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubformFields
     * const subformFields = await prisma.subformField.findMany()
     * 
     * // Get first 10 SubformFields
     * const subformFields = await prisma.subformField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subformFieldWithIdOnly = await prisma.subformField.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubformFieldFindManyArgs>(
      args?: SelectSubset<T, SubformFieldFindManyArgs>
    ): PrismaPromise<Array<SubformFieldGetPayload<T>>>

    /**
     * Create a SubformField.
     * @param {SubformFieldCreateArgs} args - Arguments to create a SubformField.
     * @example
     * // Create one SubformField
     * const SubformField = await prisma.subformField.create({
     *   data: {
     *     // ... data to create a SubformField
     *   }
     * })
     * 
    **/
    create<T extends SubformFieldCreateArgs>(
      args: SelectSubset<T, SubformFieldCreateArgs>
    ): Prisma__SubformFieldClient<SubformFieldGetPayload<T>>

    /**
     * Create many SubformFields.
     *     @param {SubformFieldCreateManyArgs} args - Arguments to create many SubformFields.
     *     @example
     *     // Create many SubformFields
     *     const subformField = await prisma.subformField.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubformFieldCreateManyArgs>(
      args?: SelectSubset<T, SubformFieldCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SubformField.
     * @param {SubformFieldDeleteArgs} args - Arguments to delete one SubformField.
     * @example
     * // Delete one SubformField
     * const SubformField = await prisma.subformField.delete({
     *   where: {
     *     // ... filter to delete one SubformField
     *   }
     * })
     * 
    **/
    delete<T extends SubformFieldDeleteArgs>(
      args: SelectSubset<T, SubformFieldDeleteArgs>
    ): Prisma__SubformFieldClient<SubformFieldGetPayload<T>>

    /**
     * Update one SubformField.
     * @param {SubformFieldUpdateArgs} args - Arguments to update one SubformField.
     * @example
     * // Update one SubformField
     * const subformField = await prisma.subformField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubformFieldUpdateArgs>(
      args: SelectSubset<T, SubformFieldUpdateArgs>
    ): Prisma__SubformFieldClient<SubformFieldGetPayload<T>>

    /**
     * Delete zero or more SubformFields.
     * @param {SubformFieldDeleteManyArgs} args - Arguments to filter SubformFields to delete.
     * @example
     * // Delete a few SubformFields
     * const { count } = await prisma.subformField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubformFieldDeleteManyArgs>(
      args?: SelectSubset<T, SubformFieldDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubformFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubformFields
     * const subformField = await prisma.subformField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubformFieldUpdateManyArgs>(
      args: SelectSubset<T, SubformFieldUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubformField.
     * @param {SubformFieldUpsertArgs} args - Arguments to update or create a SubformField.
     * @example
     * // Update or create a SubformField
     * const subformField = await prisma.subformField.upsert({
     *   create: {
     *     // ... data to create a SubformField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubformField we want to update
     *   }
     * })
    **/
    upsert<T extends SubformFieldUpsertArgs>(
      args: SelectSubset<T, SubformFieldUpsertArgs>
    ): Prisma__SubformFieldClient<SubformFieldGetPayload<T>>

    /**
     * Count the number of SubformFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldCountArgs} args - Arguments to filter SubformFields to count.
     * @example
     * // Count the number of SubformFields
     * const count = await prisma.subformField.count({
     *   where: {
     *     // ... the filter for the SubformFields we want to count
     *   }
     * })
    **/
    count<T extends SubformFieldCountArgs>(
      args?: Subset<T, SubformFieldCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubformFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubformField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubformFieldAggregateArgs>(args: Subset<T, SubformFieldAggregateArgs>): PrismaPromise<GetSubformFieldAggregateType<T>>

    /**
     * Group by SubformField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubformFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubformFieldGroupByArgs['orderBy'] }
        : { orderBy?: SubformFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubformFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubformFieldGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SubformField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubformFieldClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    subformFieldOptions<T extends SubformFieldOptionFindManyArgs= {}>(args?: Subset<T, SubformFieldOptionFindManyArgs>): PrismaPromise<Array<SubformFieldOptionGetPayload<T>>| Null>;

    subformFieldAnswer<T extends SubformFieldAnswerFindManyArgs= {}>(args?: Subset<T, SubformFieldAnswerFindManyArgs>): PrismaPromise<Array<SubformFieldAnswerGetPayload<T>>| Null>;

    subForm<T extends SubformArgs= {}>(args?: Subset<T, SubformArgs>): Prisma__SubformClient<SubformGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SubformField base type for findUnique actions
   */
  export type SubformFieldFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SubformField
     * 
    **/
    select?: SubformFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldInclude | null
    /**
     * Filter, which SubformField to fetch.
     * 
    **/
    where: SubformFieldWhereUniqueInput
  }

  /**
   * SubformField: findUnique
   */
  export interface SubformFieldFindUniqueArgs extends SubformFieldFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubformField findUniqueOrThrow
   */
  export type SubformFieldFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SubformField
     * 
    **/
    select?: SubformFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldInclude | null
    /**
     * Filter, which SubformField to fetch.
     * 
    **/
    where: SubformFieldWhereUniqueInput
  }


  /**
   * SubformField base type for findFirst actions
   */
  export type SubformFieldFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SubformField
     * 
    **/
    select?: SubformFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldInclude | null
    /**
     * Filter, which SubformField to fetch.
     * 
    **/
    where?: SubformFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubformFields to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformFieldOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubformFields.
     * 
    **/
    cursor?: SubformFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubformFields from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubformFields.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubformFields.
     * 
    **/
    distinct?: Enumerable<SubformFieldScalarFieldEnum>
  }

  /**
   * SubformField: findFirst
   */
  export interface SubformFieldFindFirstArgs extends SubformFieldFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubformField findFirstOrThrow
   */
  export type SubformFieldFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SubformField
     * 
    **/
    select?: SubformFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldInclude | null
    /**
     * Filter, which SubformField to fetch.
     * 
    **/
    where?: SubformFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubformFields to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformFieldOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubformFields.
     * 
    **/
    cursor?: SubformFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubformFields from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubformFields.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubformFields.
     * 
    **/
    distinct?: Enumerable<SubformFieldScalarFieldEnum>
  }


  /**
   * SubformField findMany
   */
  export type SubformFieldFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubformField
     * 
    **/
    select?: SubformFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldInclude | null
    /**
     * Filter, which SubformFields to fetch.
     * 
    **/
    where?: SubformFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubformFields to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformFieldOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubformFields.
     * 
    **/
    cursor?: SubformFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubformFields from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubformFields.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubformFieldScalarFieldEnum>
  }


  /**
   * SubformField create
   */
  export type SubformFieldCreateArgs = {
    /**
     * Select specific fields to fetch from the SubformField
     * 
    **/
    select?: SubformFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldInclude | null
    /**
     * The data needed to create a SubformField.
     * 
    **/
    data: XOR<SubformFieldCreateInput, SubformFieldUncheckedCreateInput>
  }


  /**
   * SubformField createMany
   */
  export type SubformFieldCreateManyArgs = {
    /**
     * The data used to create many SubformFields.
     * 
    **/
    data: Enumerable<SubformFieldCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubformField update
   */
  export type SubformFieldUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubformField
     * 
    **/
    select?: SubformFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldInclude | null
    /**
     * The data needed to update a SubformField.
     * 
    **/
    data: XOR<SubformFieldUpdateInput, SubformFieldUncheckedUpdateInput>
    /**
     * Choose, which SubformField to update.
     * 
    **/
    where: SubformFieldWhereUniqueInput
  }


  /**
   * SubformField updateMany
   */
  export type SubformFieldUpdateManyArgs = {
    /**
     * The data used to update SubformFields.
     * 
    **/
    data: XOR<SubformFieldUpdateManyMutationInput, SubformFieldUncheckedUpdateManyInput>
    /**
     * Filter which SubformFields to update
     * 
    **/
    where?: SubformFieldWhereInput
  }


  /**
   * SubformField upsert
   */
  export type SubformFieldUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubformField
     * 
    **/
    select?: SubformFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldInclude | null
    /**
     * The filter to search for the SubformField to update in case it exists.
     * 
    **/
    where: SubformFieldWhereUniqueInput
    /**
     * In case the SubformField found by the `where` argument doesn't exist, create a new SubformField with this data.
     * 
    **/
    create: XOR<SubformFieldCreateInput, SubformFieldUncheckedCreateInput>
    /**
     * In case the SubformField was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubformFieldUpdateInput, SubformFieldUncheckedUpdateInput>
  }


  /**
   * SubformField delete
   */
  export type SubformFieldDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubformField
     * 
    **/
    select?: SubformFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldInclude | null
    /**
     * Filter which SubformField to delete.
     * 
    **/
    where: SubformFieldWhereUniqueInput
  }


  /**
   * SubformField deleteMany
   */
  export type SubformFieldDeleteManyArgs = {
    /**
     * Filter which SubformFields to delete
     * 
    **/
    where?: SubformFieldWhereInput
  }


  /**
   * SubformField without action
   */
  export type SubformFieldArgs = {
    /**
     * Select specific fields to fetch from the SubformField
     * 
    **/
    select?: SubformFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldInclude | null
  }



  /**
   * Model SubformFieldOption
   */


  export type AggregateSubformFieldOption = {
    _count: SubformFieldOptionCountAggregateOutputType | null
    _avg: SubformFieldOptionAvgAggregateOutputType | null
    _sum: SubformFieldOptionSumAggregateOutputType | null
    _min: SubformFieldOptionMinAggregateOutputType | null
    _max: SubformFieldOptionMaxAggregateOutputType | null
  }

  export type SubformFieldOptionAvgAggregateOutputType = {
    id: number | null
    subformFieldId: number | null
  }

  export type SubformFieldOptionSumAggregateOutputType = {
    id: number | null
    subformFieldId: number | null
  }

  export type SubformFieldOptionMinAggregateOutputType = {
    id: number | null
    subformFieldId: number | null
    label: string | null
    value: string | null
    created: Date | null
    updated: Date | null
  }

  export type SubformFieldOptionMaxAggregateOutputType = {
    id: number | null
    subformFieldId: number | null
    label: string | null
    value: string | null
    created: Date | null
    updated: Date | null
  }

  export type SubformFieldOptionCountAggregateOutputType = {
    id: number
    subformFieldId: number
    label: number
    value: number
    created: number
    updated: number
    _all: number
  }


  export type SubformFieldOptionAvgAggregateInputType = {
    id?: true
    subformFieldId?: true
  }

  export type SubformFieldOptionSumAggregateInputType = {
    id?: true
    subformFieldId?: true
  }

  export type SubformFieldOptionMinAggregateInputType = {
    id?: true
    subformFieldId?: true
    label?: true
    value?: true
    created?: true
    updated?: true
  }

  export type SubformFieldOptionMaxAggregateInputType = {
    id?: true
    subformFieldId?: true
    label?: true
    value?: true
    created?: true
    updated?: true
  }

  export type SubformFieldOptionCountAggregateInputType = {
    id?: true
    subformFieldId?: true
    label?: true
    value?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type SubformFieldOptionAggregateArgs = {
    /**
     * Filter which SubformFieldOption to aggregate.
     * 
    **/
    where?: SubformFieldOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubformFieldOptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformFieldOptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubformFieldOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubformFieldOptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubformFieldOptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubformFieldOptions
    **/
    _count?: true | SubformFieldOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubformFieldOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubformFieldOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubformFieldOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubformFieldOptionMaxAggregateInputType
  }

  export type GetSubformFieldOptionAggregateType<T extends SubformFieldOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubformFieldOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubformFieldOption[P]>
      : GetScalarType<T[P], AggregateSubformFieldOption[P]>
  }




  export type SubformFieldOptionGroupByArgs = {
    where?: SubformFieldOptionWhereInput
    orderBy?: Enumerable<SubformFieldOptionOrderByWithAggregationInput>
    by: Array<SubformFieldOptionScalarFieldEnum>
    having?: SubformFieldOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubformFieldOptionCountAggregateInputType | true
    _avg?: SubformFieldOptionAvgAggregateInputType
    _sum?: SubformFieldOptionSumAggregateInputType
    _min?: SubformFieldOptionMinAggregateInputType
    _max?: SubformFieldOptionMaxAggregateInputType
  }


  export type SubformFieldOptionGroupByOutputType = {
    id: number
    subformFieldId: number
    label: string
    value: string
    created: Date
    updated: Date
    _count: SubformFieldOptionCountAggregateOutputType | null
    _avg: SubformFieldOptionAvgAggregateOutputType | null
    _sum: SubformFieldOptionSumAggregateOutputType | null
    _min: SubformFieldOptionMinAggregateOutputType | null
    _max: SubformFieldOptionMaxAggregateOutputType | null
  }

  type GetSubformFieldOptionGroupByPayload<T extends SubformFieldOptionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubformFieldOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubformFieldOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubformFieldOptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubformFieldOptionGroupByOutputType[P]>
        }
      >
    >


  export type SubformFieldOptionSelect = {
    id?: boolean
    subformFieldId?: boolean
    label?: boolean
    value?: boolean
    created?: boolean
    updated?: boolean
    subformFieldAnswer?: boolean | SubformFieldAnswerFindManyArgs
    subformField?: boolean | SubformFieldArgs
    _count?: boolean | SubformFieldOptionCountOutputTypeArgs
  }


  export type SubformFieldOptionInclude = {
    subformFieldAnswer?: boolean | SubformFieldAnswerFindManyArgs
    subformField?: boolean | SubformFieldArgs
    _count?: boolean | SubformFieldOptionCountOutputTypeArgs
  } 

  export type SubformFieldOptionGetPayload<S extends boolean | null | undefined | SubformFieldOptionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SubformFieldOption :
    S extends undefined ? never :
    S extends { include: any } & (SubformFieldOptionArgs | SubformFieldOptionFindManyArgs)
    ? SubformFieldOption  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'subformFieldAnswer' ? Array < SubformFieldAnswerGetPayload<S['include'][P]>>  :
        P extends 'subformField' ? SubformFieldGetPayload<S['include'][P]> :
        P extends '_count' ? SubformFieldOptionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SubformFieldOptionArgs | SubformFieldOptionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'subformFieldAnswer' ? Array < SubformFieldAnswerGetPayload<S['select'][P]>>  :
        P extends 'subformField' ? SubformFieldGetPayload<S['select'][P]> :
        P extends '_count' ? SubformFieldOptionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SubformFieldOption ? SubformFieldOption[P] : never
  } 
      : SubformFieldOption


  type SubformFieldOptionCountArgs = Merge<
    Omit<SubformFieldOptionFindManyArgs, 'select' | 'include'> & {
      select?: SubformFieldOptionCountAggregateInputType | true
    }
  >

  export interface SubformFieldOptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SubformFieldOption that matches the filter.
     * @param {SubformFieldOptionFindUniqueArgs} args - Arguments to find a SubformFieldOption
     * @example
     * // Get one SubformFieldOption
     * const subformFieldOption = await prisma.subformFieldOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubformFieldOptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubformFieldOptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubformFieldOption'> extends True ? Prisma__SubformFieldOptionClient<SubformFieldOptionGetPayload<T>> : Prisma__SubformFieldOptionClient<SubformFieldOptionGetPayload<T> | null, null>

    /**
     * Find one SubformFieldOption that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubformFieldOptionFindUniqueOrThrowArgs} args - Arguments to find a SubformFieldOption
     * @example
     * // Get one SubformFieldOption
     * const subformFieldOption = await prisma.subformFieldOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubformFieldOptionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubformFieldOptionFindUniqueOrThrowArgs>
    ): Prisma__SubformFieldOptionClient<SubformFieldOptionGetPayload<T>>

    /**
     * Find the first SubformFieldOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldOptionFindFirstArgs} args - Arguments to find a SubformFieldOption
     * @example
     * // Get one SubformFieldOption
     * const subformFieldOption = await prisma.subformFieldOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubformFieldOptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubformFieldOptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubformFieldOption'> extends True ? Prisma__SubformFieldOptionClient<SubformFieldOptionGetPayload<T>> : Prisma__SubformFieldOptionClient<SubformFieldOptionGetPayload<T> | null, null>

    /**
     * Find the first SubformFieldOption that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldOptionFindFirstOrThrowArgs} args - Arguments to find a SubformFieldOption
     * @example
     * // Get one SubformFieldOption
     * const subformFieldOption = await prisma.subformFieldOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubformFieldOptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubformFieldOptionFindFirstOrThrowArgs>
    ): Prisma__SubformFieldOptionClient<SubformFieldOptionGetPayload<T>>

    /**
     * Find zero or more SubformFieldOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldOptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubformFieldOptions
     * const subformFieldOptions = await prisma.subformFieldOption.findMany()
     * 
     * // Get first 10 SubformFieldOptions
     * const subformFieldOptions = await prisma.subformFieldOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subformFieldOptionWithIdOnly = await prisma.subformFieldOption.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubformFieldOptionFindManyArgs>(
      args?: SelectSubset<T, SubformFieldOptionFindManyArgs>
    ): PrismaPromise<Array<SubformFieldOptionGetPayload<T>>>

    /**
     * Create a SubformFieldOption.
     * @param {SubformFieldOptionCreateArgs} args - Arguments to create a SubformFieldOption.
     * @example
     * // Create one SubformFieldOption
     * const SubformFieldOption = await prisma.subformFieldOption.create({
     *   data: {
     *     // ... data to create a SubformFieldOption
     *   }
     * })
     * 
    **/
    create<T extends SubformFieldOptionCreateArgs>(
      args: SelectSubset<T, SubformFieldOptionCreateArgs>
    ): Prisma__SubformFieldOptionClient<SubformFieldOptionGetPayload<T>>

    /**
     * Create many SubformFieldOptions.
     *     @param {SubformFieldOptionCreateManyArgs} args - Arguments to create many SubformFieldOptions.
     *     @example
     *     // Create many SubformFieldOptions
     *     const subformFieldOption = await prisma.subformFieldOption.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubformFieldOptionCreateManyArgs>(
      args?: SelectSubset<T, SubformFieldOptionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SubformFieldOption.
     * @param {SubformFieldOptionDeleteArgs} args - Arguments to delete one SubformFieldOption.
     * @example
     * // Delete one SubformFieldOption
     * const SubformFieldOption = await prisma.subformFieldOption.delete({
     *   where: {
     *     // ... filter to delete one SubformFieldOption
     *   }
     * })
     * 
    **/
    delete<T extends SubformFieldOptionDeleteArgs>(
      args: SelectSubset<T, SubformFieldOptionDeleteArgs>
    ): Prisma__SubformFieldOptionClient<SubformFieldOptionGetPayload<T>>

    /**
     * Update one SubformFieldOption.
     * @param {SubformFieldOptionUpdateArgs} args - Arguments to update one SubformFieldOption.
     * @example
     * // Update one SubformFieldOption
     * const subformFieldOption = await prisma.subformFieldOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubformFieldOptionUpdateArgs>(
      args: SelectSubset<T, SubformFieldOptionUpdateArgs>
    ): Prisma__SubformFieldOptionClient<SubformFieldOptionGetPayload<T>>

    /**
     * Delete zero or more SubformFieldOptions.
     * @param {SubformFieldOptionDeleteManyArgs} args - Arguments to filter SubformFieldOptions to delete.
     * @example
     * // Delete a few SubformFieldOptions
     * const { count } = await prisma.subformFieldOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubformFieldOptionDeleteManyArgs>(
      args?: SelectSubset<T, SubformFieldOptionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubformFieldOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubformFieldOptions
     * const subformFieldOption = await prisma.subformFieldOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubformFieldOptionUpdateManyArgs>(
      args: SelectSubset<T, SubformFieldOptionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubformFieldOption.
     * @param {SubformFieldOptionUpsertArgs} args - Arguments to update or create a SubformFieldOption.
     * @example
     * // Update or create a SubformFieldOption
     * const subformFieldOption = await prisma.subformFieldOption.upsert({
     *   create: {
     *     // ... data to create a SubformFieldOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubformFieldOption we want to update
     *   }
     * })
    **/
    upsert<T extends SubformFieldOptionUpsertArgs>(
      args: SelectSubset<T, SubformFieldOptionUpsertArgs>
    ): Prisma__SubformFieldOptionClient<SubformFieldOptionGetPayload<T>>

    /**
     * Count the number of SubformFieldOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldOptionCountArgs} args - Arguments to filter SubformFieldOptions to count.
     * @example
     * // Count the number of SubformFieldOptions
     * const count = await prisma.subformFieldOption.count({
     *   where: {
     *     // ... the filter for the SubformFieldOptions we want to count
     *   }
     * })
    **/
    count<T extends SubformFieldOptionCountArgs>(
      args?: Subset<T, SubformFieldOptionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubformFieldOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubformFieldOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubformFieldOptionAggregateArgs>(args: Subset<T, SubformFieldOptionAggregateArgs>): PrismaPromise<GetSubformFieldOptionAggregateType<T>>

    /**
     * Group by SubformFieldOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubformFieldOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubformFieldOptionGroupByArgs['orderBy'] }
        : { orderBy?: SubformFieldOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubformFieldOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubformFieldOptionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SubformFieldOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubformFieldOptionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    subformFieldAnswer<T extends SubformFieldAnswerFindManyArgs= {}>(args?: Subset<T, SubformFieldAnswerFindManyArgs>): PrismaPromise<Array<SubformFieldAnswerGetPayload<T>>| Null>;

    subformField<T extends SubformFieldArgs= {}>(args?: Subset<T, SubformFieldArgs>): Prisma__SubformFieldClient<SubformFieldGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SubformFieldOption base type for findUnique actions
   */
  export type SubformFieldOptionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SubformFieldOption
     * 
    **/
    select?: SubformFieldOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldOptionInclude | null
    /**
     * Filter, which SubformFieldOption to fetch.
     * 
    **/
    where: SubformFieldOptionWhereUniqueInput
  }

  /**
   * SubformFieldOption: findUnique
   */
  export interface SubformFieldOptionFindUniqueArgs extends SubformFieldOptionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubformFieldOption findUniqueOrThrow
   */
  export type SubformFieldOptionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldOption
     * 
    **/
    select?: SubformFieldOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldOptionInclude | null
    /**
     * Filter, which SubformFieldOption to fetch.
     * 
    **/
    where: SubformFieldOptionWhereUniqueInput
  }


  /**
   * SubformFieldOption base type for findFirst actions
   */
  export type SubformFieldOptionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SubformFieldOption
     * 
    **/
    select?: SubformFieldOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldOptionInclude | null
    /**
     * Filter, which SubformFieldOption to fetch.
     * 
    **/
    where?: SubformFieldOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubformFieldOptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformFieldOptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubformFieldOptions.
     * 
    **/
    cursor?: SubformFieldOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubformFieldOptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubformFieldOptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubformFieldOptions.
     * 
    **/
    distinct?: Enumerable<SubformFieldOptionScalarFieldEnum>
  }

  /**
   * SubformFieldOption: findFirst
   */
  export interface SubformFieldOptionFindFirstArgs extends SubformFieldOptionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubformFieldOption findFirstOrThrow
   */
  export type SubformFieldOptionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldOption
     * 
    **/
    select?: SubformFieldOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldOptionInclude | null
    /**
     * Filter, which SubformFieldOption to fetch.
     * 
    **/
    where?: SubformFieldOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubformFieldOptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformFieldOptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubformFieldOptions.
     * 
    **/
    cursor?: SubformFieldOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubformFieldOptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubformFieldOptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubformFieldOptions.
     * 
    **/
    distinct?: Enumerable<SubformFieldOptionScalarFieldEnum>
  }


  /**
   * SubformFieldOption findMany
   */
  export type SubformFieldOptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldOption
     * 
    **/
    select?: SubformFieldOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldOptionInclude | null
    /**
     * Filter, which SubformFieldOptions to fetch.
     * 
    **/
    where?: SubformFieldOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubformFieldOptions to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformFieldOptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubformFieldOptions.
     * 
    **/
    cursor?: SubformFieldOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubformFieldOptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubformFieldOptions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubformFieldOptionScalarFieldEnum>
  }


  /**
   * SubformFieldOption create
   */
  export type SubformFieldOptionCreateArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldOption
     * 
    **/
    select?: SubformFieldOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldOptionInclude | null
    /**
     * The data needed to create a SubformFieldOption.
     * 
    **/
    data: XOR<SubformFieldOptionCreateInput, SubformFieldOptionUncheckedCreateInput>
  }


  /**
   * SubformFieldOption createMany
   */
  export type SubformFieldOptionCreateManyArgs = {
    /**
     * The data used to create many SubformFieldOptions.
     * 
    **/
    data: Enumerable<SubformFieldOptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubformFieldOption update
   */
  export type SubformFieldOptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldOption
     * 
    **/
    select?: SubformFieldOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldOptionInclude | null
    /**
     * The data needed to update a SubformFieldOption.
     * 
    **/
    data: XOR<SubformFieldOptionUpdateInput, SubformFieldOptionUncheckedUpdateInput>
    /**
     * Choose, which SubformFieldOption to update.
     * 
    **/
    where: SubformFieldOptionWhereUniqueInput
  }


  /**
   * SubformFieldOption updateMany
   */
  export type SubformFieldOptionUpdateManyArgs = {
    /**
     * The data used to update SubformFieldOptions.
     * 
    **/
    data: XOR<SubformFieldOptionUpdateManyMutationInput, SubformFieldOptionUncheckedUpdateManyInput>
    /**
     * Filter which SubformFieldOptions to update
     * 
    **/
    where?: SubformFieldOptionWhereInput
  }


  /**
   * SubformFieldOption upsert
   */
  export type SubformFieldOptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldOption
     * 
    **/
    select?: SubformFieldOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldOptionInclude | null
    /**
     * The filter to search for the SubformFieldOption to update in case it exists.
     * 
    **/
    where: SubformFieldOptionWhereUniqueInput
    /**
     * In case the SubformFieldOption found by the `where` argument doesn't exist, create a new SubformFieldOption with this data.
     * 
    **/
    create: XOR<SubformFieldOptionCreateInput, SubformFieldOptionUncheckedCreateInput>
    /**
     * In case the SubformFieldOption was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubformFieldOptionUpdateInput, SubformFieldOptionUncheckedUpdateInput>
  }


  /**
   * SubformFieldOption delete
   */
  export type SubformFieldOptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldOption
     * 
    **/
    select?: SubformFieldOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldOptionInclude | null
    /**
     * Filter which SubformFieldOption to delete.
     * 
    **/
    where: SubformFieldOptionWhereUniqueInput
  }


  /**
   * SubformFieldOption deleteMany
   */
  export type SubformFieldOptionDeleteManyArgs = {
    /**
     * Filter which SubformFieldOptions to delete
     * 
    **/
    where?: SubformFieldOptionWhereInput
  }


  /**
   * SubformFieldOption without action
   */
  export type SubformFieldOptionArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldOption
     * 
    **/
    select?: SubformFieldOptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldOptionInclude | null
  }



  /**
   * Model SubformFieldAnswer
   */


  export type AggregateSubformFieldAnswer = {
    _count: SubformFieldAnswerCountAggregateOutputType | null
    _avg: SubformFieldAnswerAvgAggregateOutputType | null
    _sum: SubformFieldAnswerSumAggregateOutputType | null
    _min: SubformFieldAnswerMinAggregateOutputType | null
    _max: SubformFieldAnswerMaxAggregateOutputType | null
  }

  export type SubformFieldAnswerAvgAggregateOutputType = {
    id: number | null
    subformFieldId: number | null
    claimantId: number | null
    sessionId: number | null
    optionId: number | null
  }

  export type SubformFieldAnswerSumAggregateOutputType = {
    id: number | null
    subformFieldId: number | null
    claimantId: number | null
    sessionId: number | null
    optionId: number | null
  }

  export type SubformFieldAnswerMinAggregateOutputType = {
    id: number | null
    subformFieldId: number | null
    claimantId: number | null
    sessionId: number | null
    value: string | null
    optionId: number | null
    created: Date | null
    updated: Date | null
  }

  export type SubformFieldAnswerMaxAggregateOutputType = {
    id: number | null
    subformFieldId: number | null
    claimantId: number | null
    sessionId: number | null
    value: string | null
    optionId: number | null
    created: Date | null
    updated: Date | null
  }

  export type SubformFieldAnswerCountAggregateOutputType = {
    id: number
    subformFieldId: number
    claimantId: number
    sessionId: number
    value: number
    optionId: number
    created: number
    updated: number
    _all: number
  }


  export type SubformFieldAnswerAvgAggregateInputType = {
    id?: true
    subformFieldId?: true
    claimantId?: true
    sessionId?: true
    optionId?: true
  }

  export type SubformFieldAnswerSumAggregateInputType = {
    id?: true
    subformFieldId?: true
    claimantId?: true
    sessionId?: true
    optionId?: true
  }

  export type SubformFieldAnswerMinAggregateInputType = {
    id?: true
    subformFieldId?: true
    claimantId?: true
    sessionId?: true
    value?: true
    optionId?: true
    created?: true
    updated?: true
  }

  export type SubformFieldAnswerMaxAggregateInputType = {
    id?: true
    subformFieldId?: true
    claimantId?: true
    sessionId?: true
    value?: true
    optionId?: true
    created?: true
    updated?: true
  }

  export type SubformFieldAnswerCountAggregateInputType = {
    id?: true
    subformFieldId?: true
    claimantId?: true
    sessionId?: true
    value?: true
    optionId?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type SubformFieldAnswerAggregateArgs = {
    /**
     * Filter which SubformFieldAnswer to aggregate.
     * 
    **/
    where?: SubformFieldAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubformFieldAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformFieldAnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SubformFieldAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubformFieldAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubformFieldAnswers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubformFieldAnswers
    **/
    _count?: true | SubformFieldAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubformFieldAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubformFieldAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubformFieldAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubformFieldAnswerMaxAggregateInputType
  }

  export type GetSubformFieldAnswerAggregateType<T extends SubformFieldAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateSubformFieldAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubformFieldAnswer[P]>
      : GetScalarType<T[P], AggregateSubformFieldAnswer[P]>
  }




  export type SubformFieldAnswerGroupByArgs = {
    where?: SubformFieldAnswerWhereInput
    orderBy?: Enumerable<SubformFieldAnswerOrderByWithAggregationInput>
    by: Array<SubformFieldAnswerScalarFieldEnum>
    having?: SubformFieldAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubformFieldAnswerCountAggregateInputType | true
    _avg?: SubformFieldAnswerAvgAggregateInputType
    _sum?: SubformFieldAnswerSumAggregateInputType
    _min?: SubformFieldAnswerMinAggregateInputType
    _max?: SubformFieldAnswerMaxAggregateInputType
  }


  export type SubformFieldAnswerGroupByOutputType = {
    id: number
    subformFieldId: number
    claimantId: number
    sessionId: number
    value: string | null
    optionId: number | null
    created: Date
    updated: Date
    _count: SubformFieldAnswerCountAggregateOutputType | null
    _avg: SubformFieldAnswerAvgAggregateOutputType | null
    _sum: SubformFieldAnswerSumAggregateOutputType | null
    _min: SubformFieldAnswerMinAggregateOutputType | null
    _max: SubformFieldAnswerMaxAggregateOutputType | null
  }

  type GetSubformFieldAnswerGroupByPayload<T extends SubformFieldAnswerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubformFieldAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubformFieldAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubformFieldAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], SubformFieldAnswerGroupByOutputType[P]>
        }
      >
    >


  export type SubformFieldAnswerSelect = {
    id?: boolean
    subformFieldId?: boolean
    claimantId?: boolean
    sessionId?: boolean
    value?: boolean
    optionId?: boolean
    created?: boolean
    updated?: boolean
    subformField?: boolean | SubformFieldArgs
    subformFieldOpion?: boolean | SubformFieldOptionArgs
    claimant?: boolean | ClaimantArgs
    session?: boolean | CallSessionArgs
  }


  export type SubformFieldAnswerInclude = {
    subformField?: boolean | SubformFieldArgs
    subformFieldOpion?: boolean | SubformFieldOptionArgs
    claimant?: boolean | ClaimantArgs
    session?: boolean | CallSessionArgs
  } 

  export type SubformFieldAnswerGetPayload<S extends boolean | null | undefined | SubformFieldAnswerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SubformFieldAnswer :
    S extends undefined ? never :
    S extends { include: any } & (SubformFieldAnswerArgs | SubformFieldAnswerFindManyArgs)
    ? SubformFieldAnswer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'subformField' ? SubformFieldGetPayload<S['include'][P]> :
        P extends 'subformFieldOpion' ? SubformFieldOptionGetPayload<S['include'][P]> | null :
        P extends 'claimant' ? ClaimantGetPayload<S['include'][P]> :
        P extends 'session' ? CallSessionGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SubformFieldAnswerArgs | SubformFieldAnswerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'subformField' ? SubformFieldGetPayload<S['select'][P]> :
        P extends 'subformFieldOpion' ? SubformFieldOptionGetPayload<S['select'][P]> | null :
        P extends 'claimant' ? ClaimantGetPayload<S['select'][P]> :
        P extends 'session' ? CallSessionGetPayload<S['select'][P]> :  P extends keyof SubformFieldAnswer ? SubformFieldAnswer[P] : never
  } 
      : SubformFieldAnswer


  type SubformFieldAnswerCountArgs = Merge<
    Omit<SubformFieldAnswerFindManyArgs, 'select' | 'include'> & {
      select?: SubformFieldAnswerCountAggregateInputType | true
    }
  >

  export interface SubformFieldAnswerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SubformFieldAnswer that matches the filter.
     * @param {SubformFieldAnswerFindUniqueArgs} args - Arguments to find a SubformFieldAnswer
     * @example
     * // Get one SubformFieldAnswer
     * const subformFieldAnswer = await prisma.subformFieldAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubformFieldAnswerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubformFieldAnswerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubformFieldAnswer'> extends True ? Prisma__SubformFieldAnswerClient<SubformFieldAnswerGetPayload<T>> : Prisma__SubformFieldAnswerClient<SubformFieldAnswerGetPayload<T> | null, null>

    /**
     * Find one SubformFieldAnswer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubformFieldAnswerFindUniqueOrThrowArgs} args - Arguments to find a SubformFieldAnswer
     * @example
     * // Get one SubformFieldAnswer
     * const subformFieldAnswer = await prisma.subformFieldAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubformFieldAnswerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubformFieldAnswerFindUniqueOrThrowArgs>
    ): Prisma__SubformFieldAnswerClient<SubformFieldAnswerGetPayload<T>>

    /**
     * Find the first SubformFieldAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldAnswerFindFirstArgs} args - Arguments to find a SubformFieldAnswer
     * @example
     * // Get one SubformFieldAnswer
     * const subformFieldAnswer = await prisma.subformFieldAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubformFieldAnswerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubformFieldAnswerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubformFieldAnswer'> extends True ? Prisma__SubformFieldAnswerClient<SubformFieldAnswerGetPayload<T>> : Prisma__SubformFieldAnswerClient<SubformFieldAnswerGetPayload<T> | null, null>

    /**
     * Find the first SubformFieldAnswer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldAnswerFindFirstOrThrowArgs} args - Arguments to find a SubformFieldAnswer
     * @example
     * // Get one SubformFieldAnswer
     * const subformFieldAnswer = await prisma.subformFieldAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubformFieldAnswerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubformFieldAnswerFindFirstOrThrowArgs>
    ): Prisma__SubformFieldAnswerClient<SubformFieldAnswerGetPayload<T>>

    /**
     * Find zero or more SubformFieldAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldAnswerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubformFieldAnswers
     * const subformFieldAnswers = await prisma.subformFieldAnswer.findMany()
     * 
     * // Get first 10 SubformFieldAnswers
     * const subformFieldAnswers = await prisma.subformFieldAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subformFieldAnswerWithIdOnly = await prisma.subformFieldAnswer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubformFieldAnswerFindManyArgs>(
      args?: SelectSubset<T, SubformFieldAnswerFindManyArgs>
    ): PrismaPromise<Array<SubformFieldAnswerGetPayload<T>>>

    /**
     * Create a SubformFieldAnswer.
     * @param {SubformFieldAnswerCreateArgs} args - Arguments to create a SubformFieldAnswer.
     * @example
     * // Create one SubformFieldAnswer
     * const SubformFieldAnswer = await prisma.subformFieldAnswer.create({
     *   data: {
     *     // ... data to create a SubformFieldAnswer
     *   }
     * })
     * 
    **/
    create<T extends SubformFieldAnswerCreateArgs>(
      args: SelectSubset<T, SubformFieldAnswerCreateArgs>
    ): Prisma__SubformFieldAnswerClient<SubformFieldAnswerGetPayload<T>>

    /**
     * Create many SubformFieldAnswers.
     *     @param {SubformFieldAnswerCreateManyArgs} args - Arguments to create many SubformFieldAnswers.
     *     @example
     *     // Create many SubformFieldAnswers
     *     const subformFieldAnswer = await prisma.subformFieldAnswer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubformFieldAnswerCreateManyArgs>(
      args?: SelectSubset<T, SubformFieldAnswerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SubformFieldAnswer.
     * @param {SubformFieldAnswerDeleteArgs} args - Arguments to delete one SubformFieldAnswer.
     * @example
     * // Delete one SubformFieldAnswer
     * const SubformFieldAnswer = await prisma.subformFieldAnswer.delete({
     *   where: {
     *     // ... filter to delete one SubformFieldAnswer
     *   }
     * })
     * 
    **/
    delete<T extends SubformFieldAnswerDeleteArgs>(
      args: SelectSubset<T, SubformFieldAnswerDeleteArgs>
    ): Prisma__SubformFieldAnswerClient<SubformFieldAnswerGetPayload<T>>

    /**
     * Update one SubformFieldAnswer.
     * @param {SubformFieldAnswerUpdateArgs} args - Arguments to update one SubformFieldAnswer.
     * @example
     * // Update one SubformFieldAnswer
     * const subformFieldAnswer = await prisma.subformFieldAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubformFieldAnswerUpdateArgs>(
      args: SelectSubset<T, SubformFieldAnswerUpdateArgs>
    ): Prisma__SubformFieldAnswerClient<SubformFieldAnswerGetPayload<T>>

    /**
     * Delete zero or more SubformFieldAnswers.
     * @param {SubformFieldAnswerDeleteManyArgs} args - Arguments to filter SubformFieldAnswers to delete.
     * @example
     * // Delete a few SubformFieldAnswers
     * const { count } = await prisma.subformFieldAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubformFieldAnswerDeleteManyArgs>(
      args?: SelectSubset<T, SubformFieldAnswerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubformFieldAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubformFieldAnswers
     * const subformFieldAnswer = await prisma.subformFieldAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubformFieldAnswerUpdateManyArgs>(
      args: SelectSubset<T, SubformFieldAnswerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubformFieldAnswer.
     * @param {SubformFieldAnswerUpsertArgs} args - Arguments to update or create a SubformFieldAnswer.
     * @example
     * // Update or create a SubformFieldAnswer
     * const subformFieldAnswer = await prisma.subformFieldAnswer.upsert({
     *   create: {
     *     // ... data to create a SubformFieldAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubformFieldAnswer we want to update
     *   }
     * })
    **/
    upsert<T extends SubformFieldAnswerUpsertArgs>(
      args: SelectSubset<T, SubformFieldAnswerUpsertArgs>
    ): Prisma__SubformFieldAnswerClient<SubformFieldAnswerGetPayload<T>>

    /**
     * Count the number of SubformFieldAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldAnswerCountArgs} args - Arguments to filter SubformFieldAnswers to count.
     * @example
     * // Count the number of SubformFieldAnswers
     * const count = await prisma.subformFieldAnswer.count({
     *   where: {
     *     // ... the filter for the SubformFieldAnswers we want to count
     *   }
     * })
    **/
    count<T extends SubformFieldAnswerCountArgs>(
      args?: Subset<T, SubformFieldAnswerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubformFieldAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubformFieldAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubformFieldAnswerAggregateArgs>(args: Subset<T, SubformFieldAnswerAggregateArgs>): PrismaPromise<GetSubformFieldAnswerAggregateType<T>>

    /**
     * Group by SubformFieldAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubformFieldAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubformFieldAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubformFieldAnswerGroupByArgs['orderBy'] }
        : { orderBy?: SubformFieldAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubformFieldAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubformFieldAnswerGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SubformFieldAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubformFieldAnswerClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    subformField<T extends SubformFieldArgs= {}>(args?: Subset<T, SubformFieldArgs>): Prisma__SubformFieldClient<SubformFieldGetPayload<T> | Null>;

    subformFieldOpion<T extends SubformFieldOptionArgs= {}>(args?: Subset<T, SubformFieldOptionArgs>): Prisma__SubformFieldOptionClient<SubformFieldOptionGetPayload<T> | Null>;

    claimant<T extends ClaimantArgs= {}>(args?: Subset<T, ClaimantArgs>): Prisma__ClaimantClient<ClaimantGetPayload<T> | Null>;

    session<T extends CallSessionArgs= {}>(args?: Subset<T, CallSessionArgs>): Prisma__CallSessionClient<CallSessionGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SubformFieldAnswer base type for findUnique actions
   */
  export type SubformFieldAnswerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SubformFieldAnswer
     * 
    **/
    select?: SubformFieldAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldAnswerInclude | null
    /**
     * Filter, which SubformFieldAnswer to fetch.
     * 
    **/
    where: SubformFieldAnswerWhereUniqueInput
  }

  /**
   * SubformFieldAnswer: findUnique
   */
  export interface SubformFieldAnswerFindUniqueArgs extends SubformFieldAnswerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubformFieldAnswer findUniqueOrThrow
   */
  export type SubformFieldAnswerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldAnswer
     * 
    **/
    select?: SubformFieldAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldAnswerInclude | null
    /**
     * Filter, which SubformFieldAnswer to fetch.
     * 
    **/
    where: SubformFieldAnswerWhereUniqueInput
  }


  /**
   * SubformFieldAnswer base type for findFirst actions
   */
  export type SubformFieldAnswerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SubformFieldAnswer
     * 
    **/
    select?: SubformFieldAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldAnswerInclude | null
    /**
     * Filter, which SubformFieldAnswer to fetch.
     * 
    **/
    where?: SubformFieldAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubformFieldAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformFieldAnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubformFieldAnswers.
     * 
    **/
    cursor?: SubformFieldAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubformFieldAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubformFieldAnswers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubformFieldAnswers.
     * 
    **/
    distinct?: Enumerable<SubformFieldAnswerScalarFieldEnum>
  }

  /**
   * SubformFieldAnswer: findFirst
   */
  export interface SubformFieldAnswerFindFirstArgs extends SubformFieldAnswerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubformFieldAnswer findFirstOrThrow
   */
  export type SubformFieldAnswerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldAnswer
     * 
    **/
    select?: SubformFieldAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldAnswerInclude | null
    /**
     * Filter, which SubformFieldAnswer to fetch.
     * 
    **/
    where?: SubformFieldAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubformFieldAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformFieldAnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubformFieldAnswers.
     * 
    **/
    cursor?: SubformFieldAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubformFieldAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubformFieldAnswers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubformFieldAnswers.
     * 
    **/
    distinct?: Enumerable<SubformFieldAnswerScalarFieldEnum>
  }


  /**
   * SubformFieldAnswer findMany
   */
  export type SubformFieldAnswerFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldAnswer
     * 
    **/
    select?: SubformFieldAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldAnswerInclude | null
    /**
     * Filter, which SubformFieldAnswers to fetch.
     * 
    **/
    where?: SubformFieldAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubformFieldAnswers to fetch.
     * 
    **/
    orderBy?: Enumerable<SubformFieldAnswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubformFieldAnswers.
     * 
    **/
    cursor?: SubformFieldAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubformFieldAnswers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubformFieldAnswers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubformFieldAnswerScalarFieldEnum>
  }


  /**
   * SubformFieldAnswer create
   */
  export type SubformFieldAnswerCreateArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldAnswer
     * 
    **/
    select?: SubformFieldAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldAnswerInclude | null
    /**
     * The data needed to create a SubformFieldAnswer.
     * 
    **/
    data: XOR<SubformFieldAnswerCreateInput, SubformFieldAnswerUncheckedCreateInput>
  }


  /**
   * SubformFieldAnswer createMany
   */
  export type SubformFieldAnswerCreateManyArgs = {
    /**
     * The data used to create many SubformFieldAnswers.
     * 
    **/
    data: Enumerable<SubformFieldAnswerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubformFieldAnswer update
   */
  export type SubformFieldAnswerUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldAnswer
     * 
    **/
    select?: SubformFieldAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldAnswerInclude | null
    /**
     * The data needed to update a SubformFieldAnswer.
     * 
    **/
    data: XOR<SubformFieldAnswerUpdateInput, SubformFieldAnswerUncheckedUpdateInput>
    /**
     * Choose, which SubformFieldAnswer to update.
     * 
    **/
    where: SubformFieldAnswerWhereUniqueInput
  }


  /**
   * SubformFieldAnswer updateMany
   */
  export type SubformFieldAnswerUpdateManyArgs = {
    /**
     * The data used to update SubformFieldAnswers.
     * 
    **/
    data: XOR<SubformFieldAnswerUpdateManyMutationInput, SubformFieldAnswerUncheckedUpdateManyInput>
    /**
     * Filter which SubformFieldAnswers to update
     * 
    **/
    where?: SubformFieldAnswerWhereInput
  }


  /**
   * SubformFieldAnswer upsert
   */
  export type SubformFieldAnswerUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldAnswer
     * 
    **/
    select?: SubformFieldAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldAnswerInclude | null
    /**
     * The filter to search for the SubformFieldAnswer to update in case it exists.
     * 
    **/
    where: SubformFieldAnswerWhereUniqueInput
    /**
     * In case the SubformFieldAnswer found by the `where` argument doesn't exist, create a new SubformFieldAnswer with this data.
     * 
    **/
    create: XOR<SubformFieldAnswerCreateInput, SubformFieldAnswerUncheckedCreateInput>
    /**
     * In case the SubformFieldAnswer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SubformFieldAnswerUpdateInput, SubformFieldAnswerUncheckedUpdateInput>
  }


  /**
   * SubformFieldAnswer delete
   */
  export type SubformFieldAnswerDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldAnswer
     * 
    **/
    select?: SubformFieldAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldAnswerInclude | null
    /**
     * Filter which SubformFieldAnswer to delete.
     * 
    **/
    where: SubformFieldAnswerWhereUniqueInput
  }


  /**
   * SubformFieldAnswer deleteMany
   */
  export type SubformFieldAnswerDeleteManyArgs = {
    /**
     * Filter which SubformFieldAnswers to delete
     * 
    **/
    where?: SubformFieldAnswerWhereInput
  }


  /**
   * SubformFieldAnswer without action
   */
  export type SubformFieldAnswerArgs = {
    /**
     * Select specific fields to fetch from the SubformFieldAnswer
     * 
    **/
    select?: SubformFieldAnswerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SubformFieldAnswerInclude | null
  }



  /**
   * Model Cursor
   */


  export type AggregateCursor = {
    _count: CursorCountAggregateOutputType | null
    _avg: CursorAvgAggregateOutputType | null
    _sum: CursorSumAggregateOutputType | null
    _min: CursorMinAggregateOutputType | null
    _max: CursorMaxAggregateOutputType | null
  }

  export type CursorAvgAggregateOutputType = {
    id: number | null
    formSectionId: number | null
    questionId: number | null
    claimantId: number | null
  }

  export type CursorSumAggregateOutputType = {
    id: number | null
    formSectionId: number | null
    questionId: number | null
    claimantId: number | null
  }

  export type CursorMinAggregateOutputType = {
    id: number | null
    formSectionId: number | null
    questionId: number | null
    claimantId: number | null
    created: Date | null
    updatedAt: Date | null
  }

  export type CursorMaxAggregateOutputType = {
    id: number | null
    formSectionId: number | null
    questionId: number | null
    claimantId: number | null
    created: Date | null
    updatedAt: Date | null
  }

  export type CursorCountAggregateOutputType = {
    id: number
    formSectionId: number
    questionId: number
    claimantId: number
    created: number
    updatedAt: number
    _all: number
  }


  export type CursorAvgAggregateInputType = {
    id?: true
    formSectionId?: true
    questionId?: true
    claimantId?: true
  }

  export type CursorSumAggregateInputType = {
    id?: true
    formSectionId?: true
    questionId?: true
    claimantId?: true
  }

  export type CursorMinAggregateInputType = {
    id?: true
    formSectionId?: true
    questionId?: true
    claimantId?: true
    created?: true
    updatedAt?: true
  }

  export type CursorMaxAggregateInputType = {
    id?: true
    formSectionId?: true
    questionId?: true
    claimantId?: true
    created?: true
    updatedAt?: true
  }

  export type CursorCountAggregateInputType = {
    id?: true
    formSectionId?: true
    questionId?: true
    claimantId?: true
    created?: true
    updatedAt?: true
    _all?: true
  }

  export type CursorAggregateArgs = {
    /**
     * Filter which Cursor to aggregate.
     * 
    **/
    where?: CursorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursors to fetch.
     * 
    **/
    orderBy?: Enumerable<CursorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CursorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cursors
    **/
    _count?: true | CursorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CursorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CursorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CursorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CursorMaxAggregateInputType
  }

  export type GetCursorAggregateType<T extends CursorAggregateArgs> = {
        [P in keyof T & keyof AggregateCursor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCursor[P]>
      : GetScalarType<T[P], AggregateCursor[P]>
  }




  export type CursorGroupByArgs = {
    where?: CursorWhereInput
    orderBy?: Enumerable<CursorOrderByWithAggregationInput>
    by: Array<CursorScalarFieldEnum>
    having?: CursorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CursorCountAggregateInputType | true
    _avg?: CursorAvgAggregateInputType
    _sum?: CursorSumAggregateInputType
    _min?: CursorMinAggregateInputType
    _max?: CursorMaxAggregateInputType
  }


  export type CursorGroupByOutputType = {
    id: number
    formSectionId: number
    questionId: number
    claimantId: number
    created: Date
    updatedAt: Date
    _count: CursorCountAggregateOutputType | null
    _avg: CursorAvgAggregateOutputType | null
    _sum: CursorSumAggregateOutputType | null
    _min: CursorMinAggregateOutputType | null
    _max: CursorMaxAggregateOutputType | null
  }

  type GetCursorGroupByPayload<T extends CursorGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CursorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CursorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CursorGroupByOutputType[P]>
            : GetScalarType<T[P], CursorGroupByOutputType[P]>
        }
      >
    >


  export type CursorSelect = {
    id?: boolean
    formSectionId?: boolean
    questionId?: boolean
    claimantId?: boolean
    created?: boolean
    updatedAt?: boolean
    claimant?: boolean | ClaimantArgs
    formSection?: boolean | FormSectionArgs
  }


  export type CursorInclude = {
    claimant?: boolean | ClaimantArgs
    formSection?: boolean | FormSectionArgs
  } 

  export type CursorGetPayload<S extends boolean | null | undefined | CursorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Cursor :
    S extends undefined ? never :
    S extends { include: any } & (CursorArgs | CursorFindManyArgs)
    ? Cursor  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'claimant' ? ClaimantGetPayload<S['include'][P]> :
        P extends 'formSection' ? FormSectionGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CursorArgs | CursorFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'claimant' ? ClaimantGetPayload<S['select'][P]> :
        P extends 'formSection' ? FormSectionGetPayload<S['select'][P]> :  P extends keyof Cursor ? Cursor[P] : never
  } 
      : Cursor


  type CursorCountArgs = Merge<
    Omit<CursorFindManyArgs, 'select' | 'include'> & {
      select?: CursorCountAggregateInputType | true
    }
  >

  export interface CursorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Cursor that matches the filter.
     * @param {CursorFindUniqueArgs} args - Arguments to find a Cursor
     * @example
     * // Get one Cursor
     * const cursor = await prisma.cursor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CursorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CursorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Cursor'> extends True ? Prisma__CursorClient<CursorGetPayload<T>> : Prisma__CursorClient<CursorGetPayload<T> | null, null>

    /**
     * Find one Cursor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CursorFindUniqueOrThrowArgs} args - Arguments to find a Cursor
     * @example
     * // Get one Cursor
     * const cursor = await prisma.cursor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CursorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CursorFindUniqueOrThrowArgs>
    ): Prisma__CursorClient<CursorGetPayload<T>>

    /**
     * Find the first Cursor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursorFindFirstArgs} args - Arguments to find a Cursor
     * @example
     * // Get one Cursor
     * const cursor = await prisma.cursor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CursorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CursorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Cursor'> extends True ? Prisma__CursorClient<CursorGetPayload<T>> : Prisma__CursorClient<CursorGetPayload<T> | null, null>

    /**
     * Find the first Cursor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursorFindFirstOrThrowArgs} args - Arguments to find a Cursor
     * @example
     * // Get one Cursor
     * const cursor = await prisma.cursor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CursorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CursorFindFirstOrThrowArgs>
    ): Prisma__CursorClient<CursorGetPayload<T>>

    /**
     * Find zero or more Cursors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cursors
     * const cursors = await prisma.cursor.findMany()
     * 
     * // Get first 10 Cursors
     * const cursors = await prisma.cursor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cursorWithIdOnly = await prisma.cursor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CursorFindManyArgs>(
      args?: SelectSubset<T, CursorFindManyArgs>
    ): PrismaPromise<Array<CursorGetPayload<T>>>

    /**
     * Create a Cursor.
     * @param {CursorCreateArgs} args - Arguments to create a Cursor.
     * @example
     * // Create one Cursor
     * const Cursor = await prisma.cursor.create({
     *   data: {
     *     // ... data to create a Cursor
     *   }
     * })
     * 
    **/
    create<T extends CursorCreateArgs>(
      args: SelectSubset<T, CursorCreateArgs>
    ): Prisma__CursorClient<CursorGetPayload<T>>

    /**
     * Create many Cursors.
     *     @param {CursorCreateManyArgs} args - Arguments to create many Cursors.
     *     @example
     *     // Create many Cursors
     *     const cursor = await prisma.cursor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CursorCreateManyArgs>(
      args?: SelectSubset<T, CursorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cursor.
     * @param {CursorDeleteArgs} args - Arguments to delete one Cursor.
     * @example
     * // Delete one Cursor
     * const Cursor = await prisma.cursor.delete({
     *   where: {
     *     // ... filter to delete one Cursor
     *   }
     * })
     * 
    **/
    delete<T extends CursorDeleteArgs>(
      args: SelectSubset<T, CursorDeleteArgs>
    ): Prisma__CursorClient<CursorGetPayload<T>>

    /**
     * Update one Cursor.
     * @param {CursorUpdateArgs} args - Arguments to update one Cursor.
     * @example
     * // Update one Cursor
     * const cursor = await prisma.cursor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CursorUpdateArgs>(
      args: SelectSubset<T, CursorUpdateArgs>
    ): Prisma__CursorClient<CursorGetPayload<T>>

    /**
     * Delete zero or more Cursors.
     * @param {CursorDeleteManyArgs} args - Arguments to filter Cursors to delete.
     * @example
     * // Delete a few Cursors
     * const { count } = await prisma.cursor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CursorDeleteManyArgs>(
      args?: SelectSubset<T, CursorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cursors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cursors
     * const cursor = await prisma.cursor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CursorUpdateManyArgs>(
      args: SelectSubset<T, CursorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cursor.
     * @param {CursorUpsertArgs} args - Arguments to update or create a Cursor.
     * @example
     * // Update or create a Cursor
     * const cursor = await prisma.cursor.upsert({
     *   create: {
     *     // ... data to create a Cursor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cursor we want to update
     *   }
     * })
    **/
    upsert<T extends CursorUpsertArgs>(
      args: SelectSubset<T, CursorUpsertArgs>
    ): Prisma__CursorClient<CursorGetPayload<T>>

    /**
     * Count the number of Cursors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursorCountArgs} args - Arguments to filter Cursors to count.
     * @example
     * // Count the number of Cursors
     * const count = await prisma.cursor.count({
     *   where: {
     *     // ... the filter for the Cursors we want to count
     *   }
     * })
    **/
    count<T extends CursorCountArgs>(
      args?: Subset<T, CursorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CursorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cursor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CursorAggregateArgs>(args: Subset<T, CursorAggregateArgs>): PrismaPromise<GetCursorAggregateType<T>>

    /**
     * Group by Cursor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CursorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CursorGroupByArgs['orderBy'] }
        : { orderBy?: CursorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CursorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCursorGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Cursor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CursorClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    claimant<T extends ClaimantArgs= {}>(args?: Subset<T, ClaimantArgs>): Prisma__ClaimantClient<ClaimantGetPayload<T> | Null>;

    formSection<T extends FormSectionArgs= {}>(args?: Subset<T, FormSectionArgs>): Prisma__FormSectionClient<FormSectionGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Cursor base type for findUnique actions
   */
  export type CursorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Cursor
     * 
    **/
    select?: CursorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursorInclude | null
    /**
     * Filter, which Cursor to fetch.
     * 
    **/
    where: CursorWhereUniqueInput
  }

  /**
   * Cursor: findUnique
   */
  export interface CursorFindUniqueArgs extends CursorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Cursor findUniqueOrThrow
   */
  export type CursorFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Cursor
     * 
    **/
    select?: CursorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursorInclude | null
    /**
     * Filter, which Cursor to fetch.
     * 
    **/
    where: CursorWhereUniqueInput
  }


  /**
   * Cursor base type for findFirst actions
   */
  export type CursorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Cursor
     * 
    **/
    select?: CursorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursorInclude | null
    /**
     * Filter, which Cursor to fetch.
     * 
    **/
    where?: CursorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursors to fetch.
     * 
    **/
    orderBy?: Enumerable<CursorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cursors.
     * 
    **/
    cursor?: CursorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cursors.
     * 
    **/
    distinct?: Enumerable<CursorScalarFieldEnum>
  }

  /**
   * Cursor: findFirst
   */
  export interface CursorFindFirstArgs extends CursorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Cursor findFirstOrThrow
   */
  export type CursorFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Cursor
     * 
    **/
    select?: CursorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursorInclude | null
    /**
     * Filter, which Cursor to fetch.
     * 
    **/
    where?: CursorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursors to fetch.
     * 
    **/
    orderBy?: Enumerable<CursorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cursors.
     * 
    **/
    cursor?: CursorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cursors.
     * 
    **/
    distinct?: Enumerable<CursorScalarFieldEnum>
  }


  /**
   * Cursor findMany
   */
  export type CursorFindManyArgs = {
    /**
     * Select specific fields to fetch from the Cursor
     * 
    **/
    select?: CursorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursorInclude | null
    /**
     * Filter, which Cursors to fetch.
     * 
    **/
    where?: CursorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursors to fetch.
     * 
    **/
    orderBy?: Enumerable<CursorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cursors.
     * 
    **/
    cursor?: CursorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CursorScalarFieldEnum>
  }


  /**
   * Cursor create
   */
  export type CursorCreateArgs = {
    /**
     * Select specific fields to fetch from the Cursor
     * 
    **/
    select?: CursorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursorInclude | null
    /**
     * The data needed to create a Cursor.
     * 
    **/
    data: XOR<CursorCreateInput, CursorUncheckedCreateInput>
  }


  /**
   * Cursor createMany
   */
  export type CursorCreateManyArgs = {
    /**
     * The data used to create many Cursors.
     * 
    **/
    data: Enumerable<CursorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Cursor update
   */
  export type CursorUpdateArgs = {
    /**
     * Select specific fields to fetch from the Cursor
     * 
    **/
    select?: CursorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursorInclude | null
    /**
     * The data needed to update a Cursor.
     * 
    **/
    data: XOR<CursorUpdateInput, CursorUncheckedUpdateInput>
    /**
     * Choose, which Cursor to update.
     * 
    **/
    where: CursorWhereUniqueInput
  }


  /**
   * Cursor updateMany
   */
  export type CursorUpdateManyArgs = {
    /**
     * The data used to update Cursors.
     * 
    **/
    data: XOR<CursorUpdateManyMutationInput, CursorUncheckedUpdateManyInput>
    /**
     * Filter which Cursors to update
     * 
    **/
    where?: CursorWhereInput
  }


  /**
   * Cursor upsert
   */
  export type CursorUpsertArgs = {
    /**
     * Select specific fields to fetch from the Cursor
     * 
    **/
    select?: CursorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursorInclude | null
    /**
     * The filter to search for the Cursor to update in case it exists.
     * 
    **/
    where: CursorWhereUniqueInput
    /**
     * In case the Cursor found by the `where` argument doesn't exist, create a new Cursor with this data.
     * 
    **/
    create: XOR<CursorCreateInput, CursorUncheckedCreateInput>
    /**
     * In case the Cursor was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CursorUpdateInput, CursorUncheckedUpdateInput>
  }


  /**
   * Cursor delete
   */
  export type CursorDeleteArgs = {
    /**
     * Select specific fields to fetch from the Cursor
     * 
    **/
    select?: CursorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursorInclude | null
    /**
     * Filter which Cursor to delete.
     * 
    **/
    where: CursorWhereUniqueInput
  }


  /**
   * Cursor deleteMany
   */
  export type CursorDeleteManyArgs = {
    /**
     * Filter which Cursors to delete
     * 
    **/
    where?: CursorWhereInput
  }


  /**
   * Cursor without action
   */
  export type CursorArgs = {
    /**
     * Select specific fields to fetch from the Cursor
     * 
    **/
    select?: CursorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CursorInclude | null
  }



  /**
   * Model Option
   */


  export type AggregateOption = {
    _count: OptionCountAggregateOutputType | null
    _avg: OptionAvgAggregateOutputType | null
    _sum: OptionSumAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  export type OptionAvgAggregateOutputType = {
    id: number | null
    questionId: number | null
  }

  export type OptionSumAggregateOutputType = {
    id: number | null
    questionId: number | null
  }

  export type OptionMinAggregateOutputType = {
    id: number | null
    questionId: number | null
    label: string | null
    value: string | null
    created: Date | null
    updatedAt: Date | null
  }

  export type OptionMaxAggregateOutputType = {
    id: number | null
    questionId: number | null
    label: string | null
    value: string | null
    created: Date | null
    updatedAt: Date | null
  }

  export type OptionCountAggregateOutputType = {
    id: number
    questionId: number
    label: number
    value: number
    created: number
    updatedAt: number
    _all: number
  }


  export type OptionAvgAggregateInputType = {
    id?: true
    questionId?: true
  }

  export type OptionSumAggregateInputType = {
    id?: true
    questionId?: true
  }

  export type OptionMinAggregateInputType = {
    id?: true
    questionId?: true
    label?: true
    value?: true
    created?: true
    updatedAt?: true
  }

  export type OptionMaxAggregateInputType = {
    id?: true
    questionId?: true
    label?: true
    value?: true
    created?: true
    updatedAt?: true
  }

  export type OptionCountAggregateInputType = {
    id?: true
    questionId?: true
    label?: true
    value?: true
    created?: true
    updatedAt?: true
    _all?: true
  }

  export type OptionAggregateArgs = {
    /**
     * Filter which Option to aggregate.
     * 
    **/
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     * 
    **/
    orderBy?: Enumerable<OptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Options
    **/
    _count?: true | OptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptionMaxAggregateInputType
  }

  export type GetOptionAggregateType<T extends OptionAggregateArgs> = {
        [P in keyof T & keyof AggregateOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOption[P]>
      : GetScalarType<T[P], AggregateOption[P]>
  }




  export type OptionGroupByArgs = {
    where?: OptionWhereInput
    orderBy?: Enumerable<OptionOrderByWithAggregationInput>
    by: Array<OptionScalarFieldEnum>
    having?: OptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptionCountAggregateInputType | true
    _avg?: OptionAvgAggregateInputType
    _sum?: OptionSumAggregateInputType
    _min?: OptionMinAggregateInputType
    _max?: OptionMaxAggregateInputType
  }


  export type OptionGroupByOutputType = {
    id: number
    questionId: number
    label: string
    value: string
    created: Date
    updatedAt: Date
    _count: OptionCountAggregateOutputType | null
    _avg: OptionAvgAggregateOutputType | null
    _sum: OptionSumAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  type GetOptionGroupByPayload<T extends OptionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptionGroupByOutputType[P]>
            : GetScalarType<T[P], OptionGroupByOutputType[P]>
        }
      >
    >


  export type OptionSelect = {
    id?: boolean
    questionId?: boolean
    label?: boolean
    value?: boolean
    created?: boolean
    updatedAt?: boolean
    rules?: boolean | OptionRuleFindManyArgs
    answer?: boolean | AnswerFindManyArgs
    question?: boolean | QuestionArgs
    _count?: boolean | OptionCountOutputTypeArgs
  }


  export type OptionInclude = {
    rules?: boolean | OptionRuleFindManyArgs
    answer?: boolean | AnswerFindManyArgs
    question?: boolean | QuestionArgs
    _count?: boolean | OptionCountOutputTypeArgs
  } 

  export type OptionGetPayload<S extends boolean | null | undefined | OptionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Option :
    S extends undefined ? never :
    S extends { include: any } & (OptionArgs | OptionFindManyArgs)
    ? Option  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'rules' ? Array < OptionRuleGetPayload<S['include'][P]>>  :
        P extends 'answer' ? Array < AnswerGetPayload<S['include'][P]>>  :
        P extends 'question' ? QuestionGetPayload<S['include'][P]> :
        P extends '_count' ? OptionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OptionArgs | OptionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'rules' ? Array < OptionRuleGetPayload<S['select'][P]>>  :
        P extends 'answer' ? Array < AnswerGetPayload<S['select'][P]>>  :
        P extends 'question' ? QuestionGetPayload<S['select'][P]> :
        P extends '_count' ? OptionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Option ? Option[P] : never
  } 
      : Option


  type OptionCountArgs = Merge<
    Omit<OptionFindManyArgs, 'select' | 'include'> & {
      select?: OptionCountAggregateInputType | true
    }
  >

  export interface OptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Option that matches the filter.
     * @param {OptionFindUniqueArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Option'> extends True ? Prisma__OptionClient<OptionGetPayload<T>> : Prisma__OptionClient<OptionGetPayload<T> | null, null>

    /**
     * Find one Option that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OptionFindUniqueOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OptionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OptionFindUniqueOrThrowArgs>
    ): Prisma__OptionClient<OptionGetPayload<T>>

    /**
     * Find the first Option that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindFirstArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Option'> extends True ? Prisma__OptionClient<OptionGetPayload<T>> : Prisma__OptionClient<OptionGetPayload<T> | null, null>

    /**
     * Find the first Option that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindFirstOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OptionFindFirstOrThrowArgs>
    ): Prisma__OptionClient<OptionGetPayload<T>>

    /**
     * Find zero or more Options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Options
     * const options = await prisma.option.findMany()
     * 
     * // Get first 10 Options
     * const options = await prisma.option.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optionWithIdOnly = await prisma.option.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OptionFindManyArgs>(
      args?: SelectSubset<T, OptionFindManyArgs>
    ): PrismaPromise<Array<OptionGetPayload<T>>>

    /**
     * Create a Option.
     * @param {OptionCreateArgs} args - Arguments to create a Option.
     * @example
     * // Create one Option
     * const Option = await prisma.option.create({
     *   data: {
     *     // ... data to create a Option
     *   }
     * })
     * 
    **/
    create<T extends OptionCreateArgs>(
      args: SelectSubset<T, OptionCreateArgs>
    ): Prisma__OptionClient<OptionGetPayload<T>>

    /**
     * Create many Options.
     *     @param {OptionCreateManyArgs} args - Arguments to create many Options.
     *     @example
     *     // Create many Options
     *     const option = await prisma.option.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OptionCreateManyArgs>(
      args?: SelectSubset<T, OptionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Option.
     * @param {OptionDeleteArgs} args - Arguments to delete one Option.
     * @example
     * // Delete one Option
     * const Option = await prisma.option.delete({
     *   where: {
     *     // ... filter to delete one Option
     *   }
     * })
     * 
    **/
    delete<T extends OptionDeleteArgs>(
      args: SelectSubset<T, OptionDeleteArgs>
    ): Prisma__OptionClient<OptionGetPayload<T>>

    /**
     * Update one Option.
     * @param {OptionUpdateArgs} args - Arguments to update one Option.
     * @example
     * // Update one Option
     * const option = await prisma.option.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OptionUpdateArgs>(
      args: SelectSubset<T, OptionUpdateArgs>
    ): Prisma__OptionClient<OptionGetPayload<T>>

    /**
     * Delete zero or more Options.
     * @param {OptionDeleteManyArgs} args - Arguments to filter Options to delete.
     * @example
     * // Delete a few Options
     * const { count } = await prisma.option.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OptionDeleteManyArgs>(
      args?: SelectSubset<T, OptionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Options
     * const option = await prisma.option.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OptionUpdateManyArgs>(
      args: SelectSubset<T, OptionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Option.
     * @param {OptionUpsertArgs} args - Arguments to update or create a Option.
     * @example
     * // Update or create a Option
     * const option = await prisma.option.upsert({
     *   create: {
     *     // ... data to create a Option
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Option we want to update
     *   }
     * })
    **/
    upsert<T extends OptionUpsertArgs>(
      args: SelectSubset<T, OptionUpsertArgs>
    ): Prisma__OptionClient<OptionGetPayload<T>>

    /**
     * Count the number of Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionCountArgs} args - Arguments to filter Options to count.
     * @example
     * // Count the number of Options
     * const count = await prisma.option.count({
     *   where: {
     *     // ... the filter for the Options we want to count
     *   }
     * })
    **/
    count<T extends OptionCountArgs>(
      args?: Subset<T, OptionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptionAggregateArgs>(args: Subset<T, OptionAggregateArgs>): PrismaPromise<GetOptionAggregateType<T>>

    /**
     * Group by Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptionGroupByArgs['orderBy'] }
        : { orderBy?: OptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Option.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OptionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    rules<T extends OptionRuleFindManyArgs= {}>(args?: Subset<T, OptionRuleFindManyArgs>): PrismaPromise<Array<OptionRuleGetPayload<T>>| Null>;

    answer<T extends AnswerFindManyArgs= {}>(args?: Subset<T, AnswerFindManyArgs>): PrismaPromise<Array<AnswerGetPayload<T>>| Null>;

    question<T extends QuestionArgs= {}>(args?: Subset<T, QuestionArgs>): Prisma__QuestionClient<QuestionGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Option base type for findUnique actions
   */
  export type OptionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Option
     * 
    **/
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionInclude | null
    /**
     * Filter, which Option to fetch.
     * 
    **/
    where: OptionWhereUniqueInput
  }

  /**
   * Option: findUnique
   */
  export interface OptionFindUniqueArgs extends OptionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Option findUniqueOrThrow
   */
  export type OptionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Option
     * 
    **/
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionInclude | null
    /**
     * Filter, which Option to fetch.
     * 
    **/
    where: OptionWhereUniqueInput
  }


  /**
   * Option base type for findFirst actions
   */
  export type OptionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Option
     * 
    **/
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionInclude | null
    /**
     * Filter, which Option to fetch.
     * 
    **/
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     * 
    **/
    orderBy?: Enumerable<OptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Options.
     * 
    **/
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Options.
     * 
    **/
    distinct?: Enumerable<OptionScalarFieldEnum>
  }

  /**
   * Option: findFirst
   */
  export interface OptionFindFirstArgs extends OptionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Option findFirstOrThrow
   */
  export type OptionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Option
     * 
    **/
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionInclude | null
    /**
     * Filter, which Option to fetch.
     * 
    **/
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     * 
    **/
    orderBy?: Enumerable<OptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Options.
     * 
    **/
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Options.
     * 
    **/
    distinct?: Enumerable<OptionScalarFieldEnum>
  }


  /**
   * Option findMany
   */
  export type OptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Option
     * 
    **/
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionInclude | null
    /**
     * Filter, which Options to fetch.
     * 
    **/
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     * 
    **/
    orderBy?: Enumerable<OptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Options.
     * 
    **/
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OptionScalarFieldEnum>
  }


  /**
   * Option create
   */
  export type OptionCreateArgs = {
    /**
     * Select specific fields to fetch from the Option
     * 
    **/
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionInclude | null
    /**
     * The data needed to create a Option.
     * 
    **/
    data: XOR<OptionCreateInput, OptionUncheckedCreateInput>
  }


  /**
   * Option createMany
   */
  export type OptionCreateManyArgs = {
    /**
     * The data used to create many Options.
     * 
    **/
    data: Enumerable<OptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Option update
   */
  export type OptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Option
     * 
    **/
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionInclude | null
    /**
     * The data needed to update a Option.
     * 
    **/
    data: XOR<OptionUpdateInput, OptionUncheckedUpdateInput>
    /**
     * Choose, which Option to update.
     * 
    **/
    where: OptionWhereUniqueInput
  }


  /**
   * Option updateMany
   */
  export type OptionUpdateManyArgs = {
    /**
     * The data used to update Options.
     * 
    **/
    data: XOR<OptionUpdateManyMutationInput, OptionUncheckedUpdateManyInput>
    /**
     * Filter which Options to update
     * 
    **/
    where?: OptionWhereInput
  }


  /**
   * Option upsert
   */
  export type OptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Option
     * 
    **/
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionInclude | null
    /**
     * The filter to search for the Option to update in case it exists.
     * 
    **/
    where: OptionWhereUniqueInput
    /**
     * In case the Option found by the `where` argument doesn't exist, create a new Option with this data.
     * 
    **/
    create: XOR<OptionCreateInput, OptionUncheckedCreateInput>
    /**
     * In case the Option was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OptionUpdateInput, OptionUncheckedUpdateInput>
  }


  /**
   * Option delete
   */
  export type OptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Option
     * 
    **/
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionInclude | null
    /**
     * Filter which Option to delete.
     * 
    **/
    where: OptionWhereUniqueInput
  }


  /**
   * Option deleteMany
   */
  export type OptionDeleteManyArgs = {
    /**
     * Filter which Options to delete
     * 
    **/
    where?: OptionWhereInput
  }


  /**
   * Option without action
   */
  export type OptionArgs = {
    /**
     * Select specific fields to fetch from the Option
     * 
    **/
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionInclude | null
  }



  /**
   * Model OptionRule
   */


  export type AggregateOptionRule = {
    _count: OptionRuleCountAggregateOutputType | null
    _avg: OptionRuleAvgAggregateOutputType | null
    _sum: OptionRuleSumAggregateOutputType | null
    _min: OptionRuleMinAggregateOutputType | null
    _max: OptionRuleMaxAggregateOutputType | null
  }

  export type OptionRuleAvgAggregateOutputType = {
    id: number | null
    optionId: number | null
    value: number | null
    functionId: number | null
    questionAnswerRefId: number | null
    ssaStatusId: number | null
  }

  export type OptionRuleSumAggregateOutputType = {
    id: number | null
    optionId: number | null
    value: number | null
    functionId: number | null
    questionAnswerRefId: number | null
    ssaStatusId: number | null
  }

  export type OptionRuleMinAggregateOutputType = {
    id: number | null
    optionId: number | null
    type: RuleType | null
    value: number | null
    operator: OperatorOption | null
    comparisonValue: string | null
    functionId: number | null
    questionAnswerRefId: number | null
    ssaStatusId: number | null
    isReferrerPayType: ReferrerPayTypes | null
    created: Date | null
    updated: Date | null
  }

  export type OptionRuleMaxAggregateOutputType = {
    id: number | null
    optionId: number | null
    type: RuleType | null
    value: number | null
    operator: OperatorOption | null
    comparisonValue: string | null
    functionId: number | null
    questionAnswerRefId: number | null
    ssaStatusId: number | null
    isReferrerPayType: ReferrerPayTypes | null
    created: Date | null
    updated: Date | null
  }

  export type OptionRuleCountAggregateOutputType = {
    id: number
    optionId: number
    type: number
    value: number
    operator: number
    comparisonValue: number
    functionId: number
    questionAnswerRefId: number
    ssaStatusId: number
    isReferrerPayType: number
    created: number
    updated: number
    _all: number
  }


  export type OptionRuleAvgAggregateInputType = {
    id?: true
    optionId?: true
    value?: true
    functionId?: true
    questionAnswerRefId?: true
    ssaStatusId?: true
  }

  export type OptionRuleSumAggregateInputType = {
    id?: true
    optionId?: true
    value?: true
    functionId?: true
    questionAnswerRefId?: true
    ssaStatusId?: true
  }

  export type OptionRuleMinAggregateInputType = {
    id?: true
    optionId?: true
    type?: true
    value?: true
    operator?: true
    comparisonValue?: true
    functionId?: true
    questionAnswerRefId?: true
    ssaStatusId?: true
    isReferrerPayType?: true
    created?: true
    updated?: true
  }

  export type OptionRuleMaxAggregateInputType = {
    id?: true
    optionId?: true
    type?: true
    value?: true
    operator?: true
    comparisonValue?: true
    functionId?: true
    questionAnswerRefId?: true
    ssaStatusId?: true
    isReferrerPayType?: true
    created?: true
    updated?: true
  }

  export type OptionRuleCountAggregateInputType = {
    id?: true
    optionId?: true
    type?: true
    value?: true
    operator?: true
    comparisonValue?: true
    functionId?: true
    questionAnswerRefId?: true
    ssaStatusId?: true
    isReferrerPayType?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type OptionRuleAggregateArgs = {
    /**
     * Filter which OptionRule to aggregate.
     * 
    **/
    where?: OptionRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionRules to fetch.
     * 
    **/
    orderBy?: Enumerable<OptionRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OptionRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionRules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OptionRules
    **/
    _count?: true | OptionRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OptionRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OptionRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptionRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptionRuleMaxAggregateInputType
  }

  export type GetOptionRuleAggregateType<T extends OptionRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateOptionRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOptionRule[P]>
      : GetScalarType<T[P], AggregateOptionRule[P]>
  }




  export type OptionRuleGroupByArgs = {
    where?: OptionRuleWhereInput
    orderBy?: Enumerable<OptionRuleOrderByWithAggregationInput>
    by: Array<OptionRuleScalarFieldEnum>
    having?: OptionRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptionRuleCountAggregateInputType | true
    _avg?: OptionRuleAvgAggregateInputType
    _sum?: OptionRuleSumAggregateInputType
    _min?: OptionRuleMinAggregateInputType
    _max?: OptionRuleMaxAggregateInputType
  }


  export type OptionRuleGroupByOutputType = {
    id: number
    optionId: number | null
    type: RuleType
    value: number | null
    operator: OperatorOption | null
    comparisonValue: string | null
    functionId: number | null
    questionAnswerRefId: number | null
    ssaStatusId: number | null
    isReferrerPayType: ReferrerPayTypes | null
    created: Date
    updated: Date
    _count: OptionRuleCountAggregateOutputType | null
    _avg: OptionRuleAvgAggregateOutputType | null
    _sum: OptionRuleSumAggregateOutputType | null
    _min: OptionRuleMinAggregateOutputType | null
    _max: OptionRuleMaxAggregateOutputType | null
  }

  type GetOptionRuleGroupByPayload<T extends OptionRuleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OptionRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptionRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptionRuleGroupByOutputType[P]>
            : GetScalarType<T[P], OptionRuleGroupByOutputType[P]>
        }
      >
    >


  export type OptionRuleSelect = {
    id?: boolean
    optionId?: boolean
    type?: boolean
    value?: boolean
    operator?: boolean
    comparisonValue?: boolean
    functionId?: boolean
    questionAnswerRefId?: boolean
    ssaStatusId?: boolean
    isReferrerPayType?: boolean
    created?: boolean
    updated?: boolean
    option?: boolean | OptionArgs
    questionAnswerRef?: boolean | QuestionArgs
    function?: boolean | FunctionArgs
    ssaStatus?: boolean | SSAStatusArgs
  }


  export type OptionRuleInclude = {
    option?: boolean | OptionArgs
    questionAnswerRef?: boolean | QuestionArgs
    function?: boolean | FunctionArgs
    ssaStatus?: boolean | SSAStatusArgs
  } 

  export type OptionRuleGetPayload<S extends boolean | null | undefined | OptionRuleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OptionRule :
    S extends undefined ? never :
    S extends { include: any } & (OptionRuleArgs | OptionRuleFindManyArgs)
    ? OptionRule  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'option' ? OptionGetPayload<S['include'][P]> | null :
        P extends 'questionAnswerRef' ? QuestionGetPayload<S['include'][P]> | null :
        P extends 'function' ? FunctionGetPayload<S['include'][P]> | null :
        P extends 'ssaStatus' ? SSAStatusGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (OptionRuleArgs | OptionRuleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'option' ? OptionGetPayload<S['select'][P]> | null :
        P extends 'questionAnswerRef' ? QuestionGetPayload<S['select'][P]> | null :
        P extends 'function' ? FunctionGetPayload<S['select'][P]> | null :
        P extends 'ssaStatus' ? SSAStatusGetPayload<S['select'][P]> | null :  P extends keyof OptionRule ? OptionRule[P] : never
  } 
      : OptionRule


  type OptionRuleCountArgs = Merge<
    Omit<OptionRuleFindManyArgs, 'select' | 'include'> & {
      select?: OptionRuleCountAggregateInputType | true
    }
  >

  export interface OptionRuleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one OptionRule that matches the filter.
     * @param {OptionRuleFindUniqueArgs} args - Arguments to find a OptionRule
     * @example
     * // Get one OptionRule
     * const optionRule = await prisma.optionRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OptionRuleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OptionRuleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OptionRule'> extends True ? Prisma__OptionRuleClient<OptionRuleGetPayload<T>> : Prisma__OptionRuleClient<OptionRuleGetPayload<T> | null, null>

    /**
     * Find one OptionRule that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OptionRuleFindUniqueOrThrowArgs} args - Arguments to find a OptionRule
     * @example
     * // Get one OptionRule
     * const optionRule = await prisma.optionRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OptionRuleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OptionRuleFindUniqueOrThrowArgs>
    ): Prisma__OptionRuleClient<OptionRuleGetPayload<T>>

    /**
     * Find the first OptionRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionRuleFindFirstArgs} args - Arguments to find a OptionRule
     * @example
     * // Get one OptionRule
     * const optionRule = await prisma.optionRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OptionRuleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OptionRuleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OptionRule'> extends True ? Prisma__OptionRuleClient<OptionRuleGetPayload<T>> : Prisma__OptionRuleClient<OptionRuleGetPayload<T> | null, null>

    /**
     * Find the first OptionRule that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionRuleFindFirstOrThrowArgs} args - Arguments to find a OptionRule
     * @example
     * // Get one OptionRule
     * const optionRule = await prisma.optionRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OptionRuleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OptionRuleFindFirstOrThrowArgs>
    ): Prisma__OptionRuleClient<OptionRuleGetPayload<T>>

    /**
     * Find zero or more OptionRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionRuleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OptionRules
     * const optionRules = await prisma.optionRule.findMany()
     * 
     * // Get first 10 OptionRules
     * const optionRules = await prisma.optionRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optionRuleWithIdOnly = await prisma.optionRule.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OptionRuleFindManyArgs>(
      args?: SelectSubset<T, OptionRuleFindManyArgs>
    ): PrismaPromise<Array<OptionRuleGetPayload<T>>>

    /**
     * Create a OptionRule.
     * @param {OptionRuleCreateArgs} args - Arguments to create a OptionRule.
     * @example
     * // Create one OptionRule
     * const OptionRule = await prisma.optionRule.create({
     *   data: {
     *     // ... data to create a OptionRule
     *   }
     * })
     * 
    **/
    create<T extends OptionRuleCreateArgs>(
      args: SelectSubset<T, OptionRuleCreateArgs>
    ): Prisma__OptionRuleClient<OptionRuleGetPayload<T>>

    /**
     * Create many OptionRules.
     *     @param {OptionRuleCreateManyArgs} args - Arguments to create many OptionRules.
     *     @example
     *     // Create many OptionRules
     *     const optionRule = await prisma.optionRule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OptionRuleCreateManyArgs>(
      args?: SelectSubset<T, OptionRuleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OptionRule.
     * @param {OptionRuleDeleteArgs} args - Arguments to delete one OptionRule.
     * @example
     * // Delete one OptionRule
     * const OptionRule = await prisma.optionRule.delete({
     *   where: {
     *     // ... filter to delete one OptionRule
     *   }
     * })
     * 
    **/
    delete<T extends OptionRuleDeleteArgs>(
      args: SelectSubset<T, OptionRuleDeleteArgs>
    ): Prisma__OptionRuleClient<OptionRuleGetPayload<T>>

    /**
     * Update one OptionRule.
     * @param {OptionRuleUpdateArgs} args - Arguments to update one OptionRule.
     * @example
     * // Update one OptionRule
     * const optionRule = await prisma.optionRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OptionRuleUpdateArgs>(
      args: SelectSubset<T, OptionRuleUpdateArgs>
    ): Prisma__OptionRuleClient<OptionRuleGetPayload<T>>

    /**
     * Delete zero or more OptionRules.
     * @param {OptionRuleDeleteManyArgs} args - Arguments to filter OptionRules to delete.
     * @example
     * // Delete a few OptionRules
     * const { count } = await prisma.optionRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OptionRuleDeleteManyArgs>(
      args?: SelectSubset<T, OptionRuleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptionRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OptionRules
     * const optionRule = await prisma.optionRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OptionRuleUpdateManyArgs>(
      args: SelectSubset<T, OptionRuleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OptionRule.
     * @param {OptionRuleUpsertArgs} args - Arguments to update or create a OptionRule.
     * @example
     * // Update or create a OptionRule
     * const optionRule = await prisma.optionRule.upsert({
     *   create: {
     *     // ... data to create a OptionRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OptionRule we want to update
     *   }
     * })
    **/
    upsert<T extends OptionRuleUpsertArgs>(
      args: SelectSubset<T, OptionRuleUpsertArgs>
    ): Prisma__OptionRuleClient<OptionRuleGetPayload<T>>

    /**
     * Count the number of OptionRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionRuleCountArgs} args - Arguments to filter OptionRules to count.
     * @example
     * // Count the number of OptionRules
     * const count = await prisma.optionRule.count({
     *   where: {
     *     // ... the filter for the OptionRules we want to count
     *   }
     * })
    **/
    count<T extends OptionRuleCountArgs>(
      args?: Subset<T, OptionRuleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptionRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OptionRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptionRuleAggregateArgs>(args: Subset<T, OptionRuleAggregateArgs>): PrismaPromise<GetOptionRuleAggregateType<T>>

    /**
     * Group by OptionRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptionRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptionRuleGroupByArgs['orderBy'] }
        : { orderBy?: OptionRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptionRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptionRuleGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OptionRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OptionRuleClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    option<T extends OptionArgs= {}>(args?: Subset<T, OptionArgs>): Prisma__OptionClient<OptionGetPayload<T> | Null>;

    questionAnswerRef<T extends QuestionArgs= {}>(args?: Subset<T, QuestionArgs>): Prisma__QuestionClient<QuestionGetPayload<T> | Null>;

    function<T extends FunctionArgs= {}>(args?: Subset<T, FunctionArgs>): Prisma__FunctionClient<FunctionGetPayload<T> | Null>;

    ssaStatus<T extends SSAStatusArgs= {}>(args?: Subset<T, SSAStatusArgs>): Prisma__SSAStatusClient<SSAStatusGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OptionRule base type for findUnique actions
   */
  export type OptionRuleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OptionRule
     * 
    **/
    select?: OptionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionRuleInclude | null
    /**
     * Filter, which OptionRule to fetch.
     * 
    **/
    where: OptionRuleWhereUniqueInput
  }

  /**
   * OptionRule: findUnique
   */
  export interface OptionRuleFindUniqueArgs extends OptionRuleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OptionRule findUniqueOrThrow
   */
  export type OptionRuleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OptionRule
     * 
    **/
    select?: OptionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionRuleInclude | null
    /**
     * Filter, which OptionRule to fetch.
     * 
    **/
    where: OptionRuleWhereUniqueInput
  }


  /**
   * OptionRule base type for findFirst actions
   */
  export type OptionRuleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OptionRule
     * 
    **/
    select?: OptionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionRuleInclude | null
    /**
     * Filter, which OptionRule to fetch.
     * 
    **/
    where?: OptionRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionRules to fetch.
     * 
    **/
    orderBy?: Enumerable<OptionRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptionRules.
     * 
    **/
    cursor?: OptionRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionRules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptionRules.
     * 
    **/
    distinct?: Enumerable<OptionRuleScalarFieldEnum>
  }

  /**
   * OptionRule: findFirst
   */
  export interface OptionRuleFindFirstArgs extends OptionRuleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OptionRule findFirstOrThrow
   */
  export type OptionRuleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OptionRule
     * 
    **/
    select?: OptionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionRuleInclude | null
    /**
     * Filter, which OptionRule to fetch.
     * 
    **/
    where?: OptionRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionRules to fetch.
     * 
    **/
    orderBy?: Enumerable<OptionRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptionRules.
     * 
    **/
    cursor?: OptionRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionRules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptionRules.
     * 
    **/
    distinct?: Enumerable<OptionRuleScalarFieldEnum>
  }


  /**
   * OptionRule findMany
   */
  export type OptionRuleFindManyArgs = {
    /**
     * Select specific fields to fetch from the OptionRule
     * 
    **/
    select?: OptionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionRuleInclude | null
    /**
     * Filter, which OptionRules to fetch.
     * 
    **/
    where?: OptionRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionRules to fetch.
     * 
    **/
    orderBy?: Enumerable<OptionRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OptionRules.
     * 
    **/
    cursor?: OptionRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionRules.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OptionRuleScalarFieldEnum>
  }


  /**
   * OptionRule create
   */
  export type OptionRuleCreateArgs = {
    /**
     * Select specific fields to fetch from the OptionRule
     * 
    **/
    select?: OptionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionRuleInclude | null
    /**
     * The data needed to create a OptionRule.
     * 
    **/
    data: XOR<OptionRuleCreateInput, OptionRuleUncheckedCreateInput>
  }


  /**
   * OptionRule createMany
   */
  export type OptionRuleCreateManyArgs = {
    /**
     * The data used to create many OptionRules.
     * 
    **/
    data: Enumerable<OptionRuleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OptionRule update
   */
  export type OptionRuleUpdateArgs = {
    /**
     * Select specific fields to fetch from the OptionRule
     * 
    **/
    select?: OptionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionRuleInclude | null
    /**
     * The data needed to update a OptionRule.
     * 
    **/
    data: XOR<OptionRuleUpdateInput, OptionRuleUncheckedUpdateInput>
    /**
     * Choose, which OptionRule to update.
     * 
    **/
    where: OptionRuleWhereUniqueInput
  }


  /**
   * OptionRule updateMany
   */
  export type OptionRuleUpdateManyArgs = {
    /**
     * The data used to update OptionRules.
     * 
    **/
    data: XOR<OptionRuleUpdateManyMutationInput, OptionRuleUncheckedUpdateManyInput>
    /**
     * Filter which OptionRules to update
     * 
    **/
    where?: OptionRuleWhereInput
  }


  /**
   * OptionRule upsert
   */
  export type OptionRuleUpsertArgs = {
    /**
     * Select specific fields to fetch from the OptionRule
     * 
    **/
    select?: OptionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionRuleInclude | null
    /**
     * The filter to search for the OptionRule to update in case it exists.
     * 
    **/
    where: OptionRuleWhereUniqueInput
    /**
     * In case the OptionRule found by the `where` argument doesn't exist, create a new OptionRule with this data.
     * 
    **/
    create: XOR<OptionRuleCreateInput, OptionRuleUncheckedCreateInput>
    /**
     * In case the OptionRule was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OptionRuleUpdateInput, OptionRuleUncheckedUpdateInput>
  }


  /**
   * OptionRule delete
   */
  export type OptionRuleDeleteArgs = {
    /**
     * Select specific fields to fetch from the OptionRule
     * 
    **/
    select?: OptionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionRuleInclude | null
    /**
     * Filter which OptionRule to delete.
     * 
    **/
    where: OptionRuleWhereUniqueInput
  }


  /**
   * OptionRule deleteMany
   */
  export type OptionRuleDeleteManyArgs = {
    /**
     * Filter which OptionRules to delete
     * 
    **/
    where?: OptionRuleWhereInput
  }


  /**
   * OptionRule without action
   */
  export type OptionRuleArgs = {
    /**
     * Select specific fields to fetch from the OptionRule
     * 
    **/
    select?: OptionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OptionRuleInclude | null
  }



  /**
   * Model QuestionRule
   */


  export type AggregateQuestionRule = {
    _count: QuestionRuleCountAggregateOutputType | null
    _avg: QuestionRuleAvgAggregateOutputType | null
    _sum: QuestionRuleSumAggregateOutputType | null
    _min: QuestionRuleMinAggregateOutputType | null
    _max: QuestionRuleMaxAggregateOutputType | null
  }

  export type QuestionRuleAvgAggregateOutputType = {
    id: number | null
    questionId: number | null
    value: number | null
    functionId: number | null
    questionAnswerRefId: number | null
    ssaStatusId: number | null
  }

  export type QuestionRuleSumAggregateOutputType = {
    id: number | null
    questionId: number | null
    value: number | null
    functionId: number | null
    questionAnswerRefId: number | null
    ssaStatusId: number | null
  }

  export type QuestionRuleMinAggregateOutputType = {
    id: number | null
    questionId: number | null
    optout: boolean | null
    type: RuleType | null
    value: number | null
    operator: OperatorOption | null
    comparisonValue: string | null
    functionId: number | null
    questionAnswerRefId: number | null
    ssaStatusId: number | null
    isReferrerPayType: ReferrerPayTypes | null
    created: Date | null
    updated: Date | null
  }

  export type QuestionRuleMaxAggregateOutputType = {
    id: number | null
    questionId: number | null
    optout: boolean | null
    type: RuleType | null
    value: number | null
    operator: OperatorOption | null
    comparisonValue: string | null
    functionId: number | null
    questionAnswerRefId: number | null
    ssaStatusId: number | null
    isReferrerPayType: ReferrerPayTypes | null
    created: Date | null
    updated: Date | null
  }

  export type QuestionRuleCountAggregateOutputType = {
    id: number
    questionId: number
    optout: number
    type: number
    value: number
    operator: number
    comparisonValue: number
    functionId: number
    questionAnswerRefId: number
    ssaStatusId: number
    isReferrerPayType: number
    created: number
    updated: number
    _all: number
  }


  export type QuestionRuleAvgAggregateInputType = {
    id?: true
    questionId?: true
    value?: true
    functionId?: true
    questionAnswerRefId?: true
    ssaStatusId?: true
  }

  export type QuestionRuleSumAggregateInputType = {
    id?: true
    questionId?: true
    value?: true
    functionId?: true
    questionAnswerRefId?: true
    ssaStatusId?: true
  }

  export type QuestionRuleMinAggregateInputType = {
    id?: true
    questionId?: true
    optout?: true
    type?: true
    value?: true
    operator?: true
    comparisonValue?: true
    functionId?: true
    questionAnswerRefId?: true
    ssaStatusId?: true
    isReferrerPayType?: true
    created?: true
    updated?: true
  }

  export type QuestionRuleMaxAggregateInputType = {
    id?: true
    questionId?: true
    optout?: true
    type?: true
    value?: true
    operator?: true
    comparisonValue?: true
    functionId?: true
    questionAnswerRefId?: true
    ssaStatusId?: true
    isReferrerPayType?: true
    created?: true
    updated?: true
  }

  export type QuestionRuleCountAggregateInputType = {
    id?: true
    questionId?: true
    optout?: true
    type?: true
    value?: true
    operator?: true
    comparisonValue?: true
    functionId?: true
    questionAnswerRefId?: true
    ssaStatusId?: true
    isReferrerPayType?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type QuestionRuleAggregateArgs = {
    /**
     * Filter which QuestionRule to aggregate.
     * 
    **/
    where?: QuestionRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionRules to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionRules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionRules
    **/
    _count?: true | QuestionRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionRuleMaxAggregateInputType
  }

  export type GetQuestionRuleAggregateType<T extends QuestionRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionRule[P]>
      : GetScalarType<T[P], AggregateQuestionRule[P]>
  }




  export type QuestionRuleGroupByArgs = {
    where?: QuestionRuleWhereInput
    orderBy?: Enumerable<QuestionRuleOrderByWithAggregationInput>
    by: Array<QuestionRuleScalarFieldEnum>
    having?: QuestionRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionRuleCountAggregateInputType | true
    _avg?: QuestionRuleAvgAggregateInputType
    _sum?: QuestionRuleSumAggregateInputType
    _min?: QuestionRuleMinAggregateInputType
    _max?: QuestionRuleMaxAggregateInputType
  }


  export type QuestionRuleGroupByOutputType = {
    id: number
    questionId: number | null
    optout: boolean | null
    type: RuleType
    value: number | null
    operator: OperatorOption | null
    comparisonValue: string | null
    functionId: number | null
    questionAnswerRefId: number | null
    ssaStatusId: number | null
    isReferrerPayType: ReferrerPayTypes | null
    created: Date
    updated: Date
    _count: QuestionRuleCountAggregateOutputType | null
    _avg: QuestionRuleAvgAggregateOutputType | null
    _sum: QuestionRuleSumAggregateOutputType | null
    _min: QuestionRuleMinAggregateOutputType | null
    _max: QuestionRuleMaxAggregateOutputType | null
  }

  type GetQuestionRuleGroupByPayload<T extends QuestionRuleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionRuleGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionRuleGroupByOutputType[P]>
        }
      >
    >


  export type QuestionRuleSelect = {
    id?: boolean
    questionId?: boolean
    optout?: boolean
    type?: boolean
    value?: boolean
    operator?: boolean
    comparisonValue?: boolean
    functionId?: boolean
    questionAnswerRefId?: boolean
    ssaStatusId?: boolean
    isReferrerPayType?: boolean
    created?: boolean
    updated?: boolean
    question?: boolean | QuestionArgs
    questionAnswerRef?: boolean | QuestionArgs
    function?: boolean | FunctionArgs
    ssaStatus?: boolean | SSAStatusArgs
  }


  export type QuestionRuleInclude = {
    question?: boolean | QuestionArgs
    questionAnswerRef?: boolean | QuestionArgs
    function?: boolean | FunctionArgs
    ssaStatus?: boolean | SSAStatusArgs
  } 

  export type QuestionRuleGetPayload<S extends boolean | null | undefined | QuestionRuleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuestionRule :
    S extends undefined ? never :
    S extends { include: any } & (QuestionRuleArgs | QuestionRuleFindManyArgs)
    ? QuestionRule  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'question' ? QuestionGetPayload<S['include'][P]> | null :
        P extends 'questionAnswerRef' ? QuestionGetPayload<S['include'][P]> | null :
        P extends 'function' ? FunctionGetPayload<S['include'][P]> | null :
        P extends 'ssaStatus' ? SSAStatusGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (QuestionRuleArgs | QuestionRuleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'question' ? QuestionGetPayload<S['select'][P]> | null :
        P extends 'questionAnswerRef' ? QuestionGetPayload<S['select'][P]> | null :
        P extends 'function' ? FunctionGetPayload<S['select'][P]> | null :
        P extends 'ssaStatus' ? SSAStatusGetPayload<S['select'][P]> | null :  P extends keyof QuestionRule ? QuestionRule[P] : never
  } 
      : QuestionRule


  type QuestionRuleCountArgs = Merge<
    Omit<QuestionRuleFindManyArgs, 'select' | 'include'> & {
      select?: QuestionRuleCountAggregateInputType | true
    }
  >

  export interface QuestionRuleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one QuestionRule that matches the filter.
     * @param {QuestionRuleFindUniqueArgs} args - Arguments to find a QuestionRule
     * @example
     * // Get one QuestionRule
     * const questionRule = await prisma.questionRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionRuleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionRuleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuestionRule'> extends True ? Prisma__QuestionRuleClient<QuestionRuleGetPayload<T>> : Prisma__QuestionRuleClient<QuestionRuleGetPayload<T> | null, null>

    /**
     * Find one QuestionRule that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuestionRuleFindUniqueOrThrowArgs} args - Arguments to find a QuestionRule
     * @example
     * // Get one QuestionRule
     * const questionRule = await prisma.questionRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionRuleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionRuleFindUniqueOrThrowArgs>
    ): Prisma__QuestionRuleClient<QuestionRuleGetPayload<T>>

    /**
     * Find the first QuestionRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionRuleFindFirstArgs} args - Arguments to find a QuestionRule
     * @example
     * // Get one QuestionRule
     * const questionRule = await prisma.questionRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionRuleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionRuleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuestionRule'> extends True ? Prisma__QuestionRuleClient<QuestionRuleGetPayload<T>> : Prisma__QuestionRuleClient<QuestionRuleGetPayload<T> | null, null>

    /**
     * Find the first QuestionRule that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionRuleFindFirstOrThrowArgs} args - Arguments to find a QuestionRule
     * @example
     * // Get one QuestionRule
     * const questionRule = await prisma.questionRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionRuleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionRuleFindFirstOrThrowArgs>
    ): Prisma__QuestionRuleClient<QuestionRuleGetPayload<T>>

    /**
     * Find zero or more QuestionRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionRuleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionRules
     * const questionRules = await prisma.questionRule.findMany()
     * 
     * // Get first 10 QuestionRules
     * const questionRules = await prisma.questionRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionRuleWithIdOnly = await prisma.questionRule.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionRuleFindManyArgs>(
      args?: SelectSubset<T, QuestionRuleFindManyArgs>
    ): PrismaPromise<Array<QuestionRuleGetPayload<T>>>

    /**
     * Create a QuestionRule.
     * @param {QuestionRuleCreateArgs} args - Arguments to create a QuestionRule.
     * @example
     * // Create one QuestionRule
     * const QuestionRule = await prisma.questionRule.create({
     *   data: {
     *     // ... data to create a QuestionRule
     *   }
     * })
     * 
    **/
    create<T extends QuestionRuleCreateArgs>(
      args: SelectSubset<T, QuestionRuleCreateArgs>
    ): Prisma__QuestionRuleClient<QuestionRuleGetPayload<T>>

    /**
     * Create many QuestionRules.
     *     @param {QuestionRuleCreateManyArgs} args - Arguments to create many QuestionRules.
     *     @example
     *     // Create many QuestionRules
     *     const questionRule = await prisma.questionRule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionRuleCreateManyArgs>(
      args?: SelectSubset<T, QuestionRuleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionRule.
     * @param {QuestionRuleDeleteArgs} args - Arguments to delete one QuestionRule.
     * @example
     * // Delete one QuestionRule
     * const QuestionRule = await prisma.questionRule.delete({
     *   where: {
     *     // ... filter to delete one QuestionRule
     *   }
     * })
     * 
    **/
    delete<T extends QuestionRuleDeleteArgs>(
      args: SelectSubset<T, QuestionRuleDeleteArgs>
    ): Prisma__QuestionRuleClient<QuestionRuleGetPayload<T>>

    /**
     * Update one QuestionRule.
     * @param {QuestionRuleUpdateArgs} args - Arguments to update one QuestionRule.
     * @example
     * // Update one QuestionRule
     * const questionRule = await prisma.questionRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionRuleUpdateArgs>(
      args: SelectSubset<T, QuestionRuleUpdateArgs>
    ): Prisma__QuestionRuleClient<QuestionRuleGetPayload<T>>

    /**
     * Delete zero or more QuestionRules.
     * @param {QuestionRuleDeleteManyArgs} args - Arguments to filter QuestionRules to delete.
     * @example
     * // Delete a few QuestionRules
     * const { count } = await prisma.questionRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionRuleDeleteManyArgs>(
      args?: SelectSubset<T, QuestionRuleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionRules
     * const questionRule = await prisma.questionRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionRuleUpdateManyArgs>(
      args: SelectSubset<T, QuestionRuleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionRule.
     * @param {QuestionRuleUpsertArgs} args - Arguments to update or create a QuestionRule.
     * @example
     * // Update or create a QuestionRule
     * const questionRule = await prisma.questionRule.upsert({
     *   create: {
     *     // ... data to create a QuestionRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionRule we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionRuleUpsertArgs>(
      args: SelectSubset<T, QuestionRuleUpsertArgs>
    ): Prisma__QuestionRuleClient<QuestionRuleGetPayload<T>>

    /**
     * Count the number of QuestionRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionRuleCountArgs} args - Arguments to filter QuestionRules to count.
     * @example
     * // Count the number of QuestionRules
     * const count = await prisma.questionRule.count({
     *   where: {
     *     // ... the filter for the QuestionRules we want to count
     *   }
     * })
    **/
    count<T extends QuestionRuleCountArgs>(
      args?: Subset<T, QuestionRuleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionRuleAggregateArgs>(args: Subset<T, QuestionRuleAggregateArgs>): PrismaPromise<GetQuestionRuleAggregateType<T>>

    /**
     * Group by QuestionRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionRuleGroupByArgs['orderBy'] }
        : { orderBy?: QuestionRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionRuleGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionRuleClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    question<T extends QuestionArgs= {}>(args?: Subset<T, QuestionArgs>): Prisma__QuestionClient<QuestionGetPayload<T> | Null>;

    questionAnswerRef<T extends QuestionArgs= {}>(args?: Subset<T, QuestionArgs>): Prisma__QuestionClient<QuestionGetPayload<T> | Null>;

    function<T extends FunctionArgs= {}>(args?: Subset<T, FunctionArgs>): Prisma__FunctionClient<FunctionGetPayload<T> | Null>;

    ssaStatus<T extends SSAStatusArgs= {}>(args?: Subset<T, SSAStatusArgs>): Prisma__SSAStatusClient<SSAStatusGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuestionRule base type for findUnique actions
   */
  export type QuestionRuleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionRule
     * 
    **/
    select?: QuestionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionRuleInclude | null
    /**
     * Filter, which QuestionRule to fetch.
     * 
    **/
    where: QuestionRuleWhereUniqueInput
  }

  /**
   * QuestionRule: findUnique
   */
  export interface QuestionRuleFindUniqueArgs extends QuestionRuleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionRule findUniqueOrThrow
   */
  export type QuestionRuleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuestionRule
     * 
    **/
    select?: QuestionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionRuleInclude | null
    /**
     * Filter, which QuestionRule to fetch.
     * 
    **/
    where: QuestionRuleWhereUniqueInput
  }


  /**
   * QuestionRule base type for findFirst actions
   */
  export type QuestionRuleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionRule
     * 
    **/
    select?: QuestionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionRuleInclude | null
    /**
     * Filter, which QuestionRule to fetch.
     * 
    **/
    where?: QuestionRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionRules to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionRules.
     * 
    **/
    cursor?: QuestionRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionRules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionRules.
     * 
    **/
    distinct?: Enumerable<QuestionRuleScalarFieldEnum>
  }

  /**
   * QuestionRule: findFirst
   */
  export interface QuestionRuleFindFirstArgs extends QuestionRuleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionRule findFirstOrThrow
   */
  export type QuestionRuleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuestionRule
     * 
    **/
    select?: QuestionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionRuleInclude | null
    /**
     * Filter, which QuestionRule to fetch.
     * 
    **/
    where?: QuestionRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionRules to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionRules.
     * 
    **/
    cursor?: QuestionRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionRules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionRules.
     * 
    **/
    distinct?: Enumerable<QuestionRuleScalarFieldEnum>
  }


  /**
   * QuestionRule findMany
   */
  export type QuestionRuleFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuestionRule
     * 
    **/
    select?: QuestionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionRuleInclude | null
    /**
     * Filter, which QuestionRules to fetch.
     * 
    **/
    where?: QuestionRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionRules to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionRules.
     * 
    **/
    cursor?: QuestionRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionRules.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionRuleScalarFieldEnum>
  }


  /**
   * QuestionRule create
   */
  export type QuestionRuleCreateArgs = {
    /**
     * Select specific fields to fetch from the QuestionRule
     * 
    **/
    select?: QuestionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionRuleInclude | null
    /**
     * The data needed to create a QuestionRule.
     * 
    **/
    data: XOR<QuestionRuleCreateInput, QuestionRuleUncheckedCreateInput>
  }


  /**
   * QuestionRule createMany
   */
  export type QuestionRuleCreateManyArgs = {
    /**
     * The data used to create many QuestionRules.
     * 
    **/
    data: Enumerable<QuestionRuleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuestionRule update
   */
  export type QuestionRuleUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuestionRule
     * 
    **/
    select?: QuestionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionRuleInclude | null
    /**
     * The data needed to update a QuestionRule.
     * 
    **/
    data: XOR<QuestionRuleUpdateInput, QuestionRuleUncheckedUpdateInput>
    /**
     * Choose, which QuestionRule to update.
     * 
    **/
    where: QuestionRuleWhereUniqueInput
  }


  /**
   * QuestionRule updateMany
   */
  export type QuestionRuleUpdateManyArgs = {
    /**
     * The data used to update QuestionRules.
     * 
    **/
    data: XOR<QuestionRuleUpdateManyMutationInput, QuestionRuleUncheckedUpdateManyInput>
    /**
     * Filter which QuestionRules to update
     * 
    **/
    where?: QuestionRuleWhereInput
  }


  /**
   * QuestionRule upsert
   */
  export type QuestionRuleUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuestionRule
     * 
    **/
    select?: QuestionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionRuleInclude | null
    /**
     * The filter to search for the QuestionRule to update in case it exists.
     * 
    **/
    where: QuestionRuleWhereUniqueInput
    /**
     * In case the QuestionRule found by the `where` argument doesn't exist, create a new QuestionRule with this data.
     * 
    **/
    create: XOR<QuestionRuleCreateInput, QuestionRuleUncheckedCreateInput>
    /**
     * In case the QuestionRule was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionRuleUpdateInput, QuestionRuleUncheckedUpdateInput>
  }


  /**
   * QuestionRule delete
   */
  export type QuestionRuleDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuestionRule
     * 
    **/
    select?: QuestionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionRuleInclude | null
    /**
     * Filter which QuestionRule to delete.
     * 
    **/
    where: QuestionRuleWhereUniqueInput
  }


  /**
   * QuestionRule deleteMany
   */
  export type QuestionRuleDeleteManyArgs = {
    /**
     * Filter which QuestionRules to delete
     * 
    **/
    where?: QuestionRuleWhereInput
  }


  /**
   * QuestionRule without action
   */
  export type QuestionRuleArgs = {
    /**
     * Select specific fields to fetch from the QuestionRule
     * 
    **/
    select?: QuestionRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionRuleInclude | null
  }



  /**
   * Model QuestionFormatRule
   */


  export type AggregateQuestionFormatRule = {
    _count: QuestionFormatRuleCountAggregateOutputType | null
    _avg: QuestionFormatRuleAvgAggregateOutputType | null
    _sum: QuestionFormatRuleSumAggregateOutputType | null
    _min: QuestionFormatRuleMinAggregateOutputType | null
    _max: QuestionFormatRuleMaxAggregateOutputType | null
  }

  export type QuestionFormatRuleAvgAggregateOutputType = {
    id: number | null
    questionId: number | null
    questionAnswerRefId: number | null
  }

  export type QuestionFormatRuleSumAggregateOutputType = {
    id: number | null
    questionId: number | null
    questionAnswerRefId: number | null
  }

  export type QuestionFormatRuleMinAggregateOutputType = {
    id: number | null
    questionId: number | null
    type: QuestionFormatTypes | null
    questionAnswerRefId: number | null
    claimantField: ClaimantFieldRefTypes | null
    created: Date | null
    updated: Date | null
  }

  export type QuestionFormatRuleMaxAggregateOutputType = {
    id: number | null
    questionId: number | null
    type: QuestionFormatTypes | null
    questionAnswerRefId: number | null
    claimantField: ClaimantFieldRefTypes | null
    created: Date | null
    updated: Date | null
  }

  export type QuestionFormatRuleCountAggregateOutputType = {
    id: number
    questionId: number
    type: number
    questionAnswerRefId: number
    claimantField: number
    created: number
    updated: number
    _all: number
  }


  export type QuestionFormatRuleAvgAggregateInputType = {
    id?: true
    questionId?: true
    questionAnswerRefId?: true
  }

  export type QuestionFormatRuleSumAggregateInputType = {
    id?: true
    questionId?: true
    questionAnswerRefId?: true
  }

  export type QuestionFormatRuleMinAggregateInputType = {
    id?: true
    questionId?: true
    type?: true
    questionAnswerRefId?: true
    claimantField?: true
    created?: true
    updated?: true
  }

  export type QuestionFormatRuleMaxAggregateInputType = {
    id?: true
    questionId?: true
    type?: true
    questionAnswerRefId?: true
    claimantField?: true
    created?: true
    updated?: true
  }

  export type QuestionFormatRuleCountAggregateInputType = {
    id?: true
    questionId?: true
    type?: true
    questionAnswerRefId?: true
    claimantField?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type QuestionFormatRuleAggregateArgs = {
    /**
     * Filter which QuestionFormatRule to aggregate.
     * 
    **/
    where?: QuestionFormatRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionFormatRules to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionFormatRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: QuestionFormatRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionFormatRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionFormatRules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionFormatRules
    **/
    _count?: true | QuestionFormatRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionFormatRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionFormatRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionFormatRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionFormatRuleMaxAggregateInputType
  }

  export type GetQuestionFormatRuleAggregateType<T extends QuestionFormatRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionFormatRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionFormatRule[P]>
      : GetScalarType<T[P], AggregateQuestionFormatRule[P]>
  }




  export type QuestionFormatRuleGroupByArgs = {
    where?: QuestionFormatRuleWhereInput
    orderBy?: Enumerable<QuestionFormatRuleOrderByWithAggregationInput>
    by: Array<QuestionFormatRuleScalarFieldEnum>
    having?: QuestionFormatRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionFormatRuleCountAggregateInputType | true
    _avg?: QuestionFormatRuleAvgAggregateInputType
    _sum?: QuestionFormatRuleSumAggregateInputType
    _min?: QuestionFormatRuleMinAggregateInputType
    _max?: QuestionFormatRuleMaxAggregateInputType
  }


  export type QuestionFormatRuleGroupByOutputType = {
    id: number
    questionId: number | null
    type: QuestionFormatTypes
    questionAnswerRefId: number | null
    claimantField: ClaimantFieldRefTypes | null
    created: Date
    updated: Date
    _count: QuestionFormatRuleCountAggregateOutputType | null
    _avg: QuestionFormatRuleAvgAggregateOutputType | null
    _sum: QuestionFormatRuleSumAggregateOutputType | null
    _min: QuestionFormatRuleMinAggregateOutputType | null
    _max: QuestionFormatRuleMaxAggregateOutputType | null
  }

  type GetQuestionFormatRuleGroupByPayload<T extends QuestionFormatRuleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionFormatRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionFormatRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionFormatRuleGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionFormatRuleGroupByOutputType[P]>
        }
      >
    >


  export type QuestionFormatRuleSelect = {
    id?: boolean
    questionId?: boolean
    type?: boolean
    questionAnswerRefId?: boolean
    claimantField?: boolean
    created?: boolean
    updated?: boolean
    question?: boolean | QuestionArgs
    questionAnswerRef?: boolean | QuestionArgs
  }


  export type QuestionFormatRuleInclude = {
    question?: boolean | QuestionArgs
    questionAnswerRef?: boolean | QuestionArgs
  } 

  export type QuestionFormatRuleGetPayload<S extends boolean | null | undefined | QuestionFormatRuleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuestionFormatRule :
    S extends undefined ? never :
    S extends { include: any } & (QuestionFormatRuleArgs | QuestionFormatRuleFindManyArgs)
    ? QuestionFormatRule  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'question' ? QuestionGetPayload<S['include'][P]> | null :
        P extends 'questionAnswerRef' ? QuestionGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (QuestionFormatRuleArgs | QuestionFormatRuleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'question' ? QuestionGetPayload<S['select'][P]> | null :
        P extends 'questionAnswerRef' ? QuestionGetPayload<S['select'][P]> | null :  P extends keyof QuestionFormatRule ? QuestionFormatRule[P] : never
  } 
      : QuestionFormatRule


  type QuestionFormatRuleCountArgs = Merge<
    Omit<QuestionFormatRuleFindManyArgs, 'select' | 'include'> & {
      select?: QuestionFormatRuleCountAggregateInputType | true
    }
  >

  export interface QuestionFormatRuleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one QuestionFormatRule that matches the filter.
     * @param {QuestionFormatRuleFindUniqueArgs} args - Arguments to find a QuestionFormatRule
     * @example
     * // Get one QuestionFormatRule
     * const questionFormatRule = await prisma.questionFormatRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestionFormatRuleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuestionFormatRuleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuestionFormatRule'> extends True ? Prisma__QuestionFormatRuleClient<QuestionFormatRuleGetPayload<T>> : Prisma__QuestionFormatRuleClient<QuestionFormatRuleGetPayload<T> | null, null>

    /**
     * Find one QuestionFormatRule that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuestionFormatRuleFindUniqueOrThrowArgs} args - Arguments to find a QuestionFormatRule
     * @example
     * // Get one QuestionFormatRule
     * const questionFormatRule = await prisma.questionFormatRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestionFormatRuleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, QuestionFormatRuleFindUniqueOrThrowArgs>
    ): Prisma__QuestionFormatRuleClient<QuestionFormatRuleGetPayload<T>>

    /**
     * Find the first QuestionFormatRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFormatRuleFindFirstArgs} args - Arguments to find a QuestionFormatRule
     * @example
     * // Get one QuestionFormatRule
     * const questionFormatRule = await prisma.questionFormatRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestionFormatRuleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuestionFormatRuleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuestionFormatRule'> extends True ? Prisma__QuestionFormatRuleClient<QuestionFormatRuleGetPayload<T>> : Prisma__QuestionFormatRuleClient<QuestionFormatRuleGetPayload<T> | null, null>

    /**
     * Find the first QuestionFormatRule that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFormatRuleFindFirstOrThrowArgs} args - Arguments to find a QuestionFormatRule
     * @example
     * // Get one QuestionFormatRule
     * const questionFormatRule = await prisma.questionFormatRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestionFormatRuleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QuestionFormatRuleFindFirstOrThrowArgs>
    ): Prisma__QuestionFormatRuleClient<QuestionFormatRuleGetPayload<T>>

    /**
     * Find zero or more QuestionFormatRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFormatRuleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionFormatRules
     * const questionFormatRules = await prisma.questionFormatRule.findMany()
     * 
     * // Get first 10 QuestionFormatRules
     * const questionFormatRules = await prisma.questionFormatRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionFormatRuleWithIdOnly = await prisma.questionFormatRule.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuestionFormatRuleFindManyArgs>(
      args?: SelectSubset<T, QuestionFormatRuleFindManyArgs>
    ): PrismaPromise<Array<QuestionFormatRuleGetPayload<T>>>

    /**
     * Create a QuestionFormatRule.
     * @param {QuestionFormatRuleCreateArgs} args - Arguments to create a QuestionFormatRule.
     * @example
     * // Create one QuestionFormatRule
     * const QuestionFormatRule = await prisma.questionFormatRule.create({
     *   data: {
     *     // ... data to create a QuestionFormatRule
     *   }
     * })
     * 
    **/
    create<T extends QuestionFormatRuleCreateArgs>(
      args: SelectSubset<T, QuestionFormatRuleCreateArgs>
    ): Prisma__QuestionFormatRuleClient<QuestionFormatRuleGetPayload<T>>

    /**
     * Create many QuestionFormatRules.
     *     @param {QuestionFormatRuleCreateManyArgs} args - Arguments to create many QuestionFormatRules.
     *     @example
     *     // Create many QuestionFormatRules
     *     const questionFormatRule = await prisma.questionFormatRule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestionFormatRuleCreateManyArgs>(
      args?: SelectSubset<T, QuestionFormatRuleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionFormatRule.
     * @param {QuestionFormatRuleDeleteArgs} args - Arguments to delete one QuestionFormatRule.
     * @example
     * // Delete one QuestionFormatRule
     * const QuestionFormatRule = await prisma.questionFormatRule.delete({
     *   where: {
     *     // ... filter to delete one QuestionFormatRule
     *   }
     * })
     * 
    **/
    delete<T extends QuestionFormatRuleDeleteArgs>(
      args: SelectSubset<T, QuestionFormatRuleDeleteArgs>
    ): Prisma__QuestionFormatRuleClient<QuestionFormatRuleGetPayload<T>>

    /**
     * Update one QuestionFormatRule.
     * @param {QuestionFormatRuleUpdateArgs} args - Arguments to update one QuestionFormatRule.
     * @example
     * // Update one QuestionFormatRule
     * const questionFormatRule = await prisma.questionFormatRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestionFormatRuleUpdateArgs>(
      args: SelectSubset<T, QuestionFormatRuleUpdateArgs>
    ): Prisma__QuestionFormatRuleClient<QuestionFormatRuleGetPayload<T>>

    /**
     * Delete zero or more QuestionFormatRules.
     * @param {QuestionFormatRuleDeleteManyArgs} args - Arguments to filter QuestionFormatRules to delete.
     * @example
     * // Delete a few QuestionFormatRules
     * const { count } = await prisma.questionFormatRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestionFormatRuleDeleteManyArgs>(
      args?: SelectSubset<T, QuestionFormatRuleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionFormatRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFormatRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionFormatRules
     * const questionFormatRule = await prisma.questionFormatRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestionFormatRuleUpdateManyArgs>(
      args: SelectSubset<T, QuestionFormatRuleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionFormatRule.
     * @param {QuestionFormatRuleUpsertArgs} args - Arguments to update or create a QuestionFormatRule.
     * @example
     * // Update or create a QuestionFormatRule
     * const questionFormatRule = await prisma.questionFormatRule.upsert({
     *   create: {
     *     // ... data to create a QuestionFormatRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionFormatRule we want to update
     *   }
     * })
    **/
    upsert<T extends QuestionFormatRuleUpsertArgs>(
      args: SelectSubset<T, QuestionFormatRuleUpsertArgs>
    ): Prisma__QuestionFormatRuleClient<QuestionFormatRuleGetPayload<T>>

    /**
     * Count the number of QuestionFormatRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFormatRuleCountArgs} args - Arguments to filter QuestionFormatRules to count.
     * @example
     * // Count the number of QuestionFormatRules
     * const count = await prisma.questionFormatRule.count({
     *   where: {
     *     // ... the filter for the QuestionFormatRules we want to count
     *   }
     * })
    **/
    count<T extends QuestionFormatRuleCountArgs>(
      args?: Subset<T, QuestionFormatRuleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionFormatRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionFormatRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFormatRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionFormatRuleAggregateArgs>(args: Subset<T, QuestionFormatRuleAggregateArgs>): PrismaPromise<GetQuestionFormatRuleAggregateType<T>>

    /**
     * Group by QuestionFormatRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFormatRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionFormatRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionFormatRuleGroupByArgs['orderBy'] }
        : { orderBy?: QuestionFormatRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionFormatRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionFormatRuleGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionFormatRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuestionFormatRuleClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    question<T extends QuestionArgs= {}>(args?: Subset<T, QuestionArgs>): Prisma__QuestionClient<QuestionGetPayload<T> | Null>;

    questionAnswerRef<T extends QuestionArgs= {}>(args?: Subset<T, QuestionArgs>): Prisma__QuestionClient<QuestionGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuestionFormatRule base type for findUnique actions
   */
  export type QuestionFormatRuleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionFormatRule
     * 
    **/
    select?: QuestionFormatRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionFormatRuleInclude | null
    /**
     * Filter, which QuestionFormatRule to fetch.
     * 
    **/
    where: QuestionFormatRuleWhereUniqueInput
  }

  /**
   * QuestionFormatRule: findUnique
   */
  export interface QuestionFormatRuleFindUniqueArgs extends QuestionFormatRuleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionFormatRule findUniqueOrThrow
   */
  export type QuestionFormatRuleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuestionFormatRule
     * 
    **/
    select?: QuestionFormatRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionFormatRuleInclude | null
    /**
     * Filter, which QuestionFormatRule to fetch.
     * 
    **/
    where: QuestionFormatRuleWhereUniqueInput
  }


  /**
   * QuestionFormatRule base type for findFirst actions
   */
  export type QuestionFormatRuleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the QuestionFormatRule
     * 
    **/
    select?: QuestionFormatRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionFormatRuleInclude | null
    /**
     * Filter, which QuestionFormatRule to fetch.
     * 
    **/
    where?: QuestionFormatRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionFormatRules to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionFormatRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionFormatRules.
     * 
    **/
    cursor?: QuestionFormatRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionFormatRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionFormatRules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionFormatRules.
     * 
    **/
    distinct?: Enumerable<QuestionFormatRuleScalarFieldEnum>
  }

  /**
   * QuestionFormatRule: findFirst
   */
  export interface QuestionFormatRuleFindFirstArgs extends QuestionFormatRuleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuestionFormatRule findFirstOrThrow
   */
  export type QuestionFormatRuleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the QuestionFormatRule
     * 
    **/
    select?: QuestionFormatRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionFormatRuleInclude | null
    /**
     * Filter, which QuestionFormatRule to fetch.
     * 
    **/
    where?: QuestionFormatRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionFormatRules to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionFormatRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionFormatRules.
     * 
    **/
    cursor?: QuestionFormatRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionFormatRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionFormatRules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionFormatRules.
     * 
    **/
    distinct?: Enumerable<QuestionFormatRuleScalarFieldEnum>
  }


  /**
   * QuestionFormatRule findMany
   */
  export type QuestionFormatRuleFindManyArgs = {
    /**
     * Select specific fields to fetch from the QuestionFormatRule
     * 
    **/
    select?: QuestionFormatRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionFormatRuleInclude | null
    /**
     * Filter, which QuestionFormatRules to fetch.
     * 
    **/
    where?: QuestionFormatRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionFormatRules to fetch.
     * 
    **/
    orderBy?: Enumerable<QuestionFormatRuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionFormatRules.
     * 
    **/
    cursor?: QuestionFormatRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionFormatRules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionFormatRules.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionFormatRuleScalarFieldEnum>
  }


  /**
   * QuestionFormatRule create
   */
  export type QuestionFormatRuleCreateArgs = {
    /**
     * Select specific fields to fetch from the QuestionFormatRule
     * 
    **/
    select?: QuestionFormatRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionFormatRuleInclude | null
    /**
     * The data needed to create a QuestionFormatRule.
     * 
    **/
    data: XOR<QuestionFormatRuleCreateInput, QuestionFormatRuleUncheckedCreateInput>
  }


  /**
   * QuestionFormatRule createMany
   */
  export type QuestionFormatRuleCreateManyArgs = {
    /**
     * The data used to create many QuestionFormatRules.
     * 
    **/
    data: Enumerable<QuestionFormatRuleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuestionFormatRule update
   */
  export type QuestionFormatRuleUpdateArgs = {
    /**
     * Select specific fields to fetch from the QuestionFormatRule
     * 
    **/
    select?: QuestionFormatRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionFormatRuleInclude | null
    /**
     * The data needed to update a QuestionFormatRule.
     * 
    **/
    data: XOR<QuestionFormatRuleUpdateInput, QuestionFormatRuleUncheckedUpdateInput>
    /**
     * Choose, which QuestionFormatRule to update.
     * 
    **/
    where: QuestionFormatRuleWhereUniqueInput
  }


  /**
   * QuestionFormatRule updateMany
   */
  export type QuestionFormatRuleUpdateManyArgs = {
    /**
     * The data used to update QuestionFormatRules.
     * 
    **/
    data: XOR<QuestionFormatRuleUpdateManyMutationInput, QuestionFormatRuleUncheckedUpdateManyInput>
    /**
     * Filter which QuestionFormatRules to update
     * 
    **/
    where?: QuestionFormatRuleWhereInput
  }


  /**
   * QuestionFormatRule upsert
   */
  export type QuestionFormatRuleUpsertArgs = {
    /**
     * Select specific fields to fetch from the QuestionFormatRule
     * 
    **/
    select?: QuestionFormatRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionFormatRuleInclude | null
    /**
     * The filter to search for the QuestionFormatRule to update in case it exists.
     * 
    **/
    where: QuestionFormatRuleWhereUniqueInput
    /**
     * In case the QuestionFormatRule found by the `where` argument doesn't exist, create a new QuestionFormatRule with this data.
     * 
    **/
    create: XOR<QuestionFormatRuleCreateInput, QuestionFormatRuleUncheckedCreateInput>
    /**
     * In case the QuestionFormatRule was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<QuestionFormatRuleUpdateInput, QuestionFormatRuleUncheckedUpdateInput>
  }


  /**
   * QuestionFormatRule delete
   */
  export type QuestionFormatRuleDeleteArgs = {
    /**
     * Select specific fields to fetch from the QuestionFormatRule
     * 
    **/
    select?: QuestionFormatRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionFormatRuleInclude | null
    /**
     * Filter which QuestionFormatRule to delete.
     * 
    **/
    where: QuestionFormatRuleWhereUniqueInput
  }


  /**
   * QuestionFormatRule deleteMany
   */
  export type QuestionFormatRuleDeleteManyArgs = {
    /**
     * Filter which QuestionFormatRules to delete
     * 
    **/
    where?: QuestionFormatRuleWhereInput
  }


  /**
   * QuestionFormatRule without action
   */
  export type QuestionFormatRuleArgs = {
    /**
     * Select specific fields to fetch from the QuestionFormatRule
     * 
    **/
    select?: QuestionFormatRuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: QuestionFormatRuleInclude | null
  }



  /**
   * Model Function
   */


  export type AggregateFunction = {
    _count: FunctionCountAggregateOutputType | null
    _avg: FunctionAvgAggregateOutputType | null
    _sum: FunctionSumAggregateOutputType | null
    _min: FunctionMinAggregateOutputType | null
    _max: FunctionMaxAggregateOutputType | null
  }

  export type FunctionAvgAggregateOutputType = {
    id: number | null
  }

  export type FunctionSumAggregateOutputType = {
    id: number | null
  }

  export type FunctionMinAggregateOutputType = {
    id: number | null
    name: string | null
    function: string | null
    created: Date | null
    updated: Date | null
  }

  export type FunctionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    function: string | null
    created: Date | null
    updated: Date | null
  }

  export type FunctionCountAggregateOutputType = {
    id: number
    name: number
    function: number
    created: number
    updated: number
    _all: number
  }


  export type FunctionAvgAggregateInputType = {
    id?: true
  }

  export type FunctionSumAggregateInputType = {
    id?: true
  }

  export type FunctionMinAggregateInputType = {
    id?: true
    name?: true
    function?: true
    created?: true
    updated?: true
  }

  export type FunctionMaxAggregateInputType = {
    id?: true
    name?: true
    function?: true
    created?: true
    updated?: true
  }

  export type FunctionCountAggregateInputType = {
    id?: true
    name?: true
    function?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type FunctionAggregateArgs = {
    /**
     * Filter which Function to aggregate.
     * 
    **/
    where?: FunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Functions to fetch.
     * 
    **/
    orderBy?: Enumerable<FunctionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Functions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Functions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Functions
    **/
    _count?: true | FunctionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FunctionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FunctionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FunctionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FunctionMaxAggregateInputType
  }

  export type GetFunctionAggregateType<T extends FunctionAggregateArgs> = {
        [P in keyof T & keyof AggregateFunction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunction[P]>
      : GetScalarType<T[P], AggregateFunction[P]>
  }




  export type FunctionGroupByArgs = {
    where?: FunctionWhereInput
    orderBy?: Enumerable<FunctionOrderByWithAggregationInput>
    by: Array<FunctionScalarFieldEnum>
    having?: FunctionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FunctionCountAggregateInputType | true
    _avg?: FunctionAvgAggregateInputType
    _sum?: FunctionSumAggregateInputType
    _min?: FunctionMinAggregateInputType
    _max?: FunctionMaxAggregateInputType
  }


  export type FunctionGroupByOutputType = {
    id: number
    name: string
    function: string
    created: Date
    updated: Date
    _count: FunctionCountAggregateOutputType | null
    _avg: FunctionAvgAggregateOutputType | null
    _sum: FunctionSumAggregateOutputType | null
    _min: FunctionMinAggregateOutputType | null
    _max: FunctionMaxAggregateOutputType | null
  }

  type GetFunctionGroupByPayload<T extends FunctionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FunctionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FunctionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FunctionGroupByOutputType[P]>
            : GetScalarType<T[P], FunctionGroupByOutputType[P]>
        }
      >
    >


  export type FunctionSelect = {
    id?: boolean
    name?: boolean
    function?: boolean
    created?: boolean
    updated?: boolean
    QuestionRule?: boolean | QuestionRuleFindManyArgs
    OptionRule?: boolean | OptionRuleFindManyArgs
    _count?: boolean | FunctionCountOutputTypeArgs
  }


  export type FunctionInclude = {
    QuestionRule?: boolean | QuestionRuleFindManyArgs
    OptionRule?: boolean | OptionRuleFindManyArgs
    _count?: boolean | FunctionCountOutputTypeArgs
  } 

  export type FunctionGetPayload<S extends boolean | null | undefined | FunctionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Function :
    S extends undefined ? never :
    S extends { include: any } & (FunctionArgs | FunctionFindManyArgs)
    ? Function  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'QuestionRule' ? Array < QuestionRuleGetPayload<S['include'][P]>>  :
        P extends 'OptionRule' ? Array < OptionRuleGetPayload<S['include'][P]>>  :
        P extends '_count' ? FunctionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FunctionArgs | FunctionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'QuestionRule' ? Array < QuestionRuleGetPayload<S['select'][P]>>  :
        P extends 'OptionRule' ? Array < OptionRuleGetPayload<S['select'][P]>>  :
        P extends '_count' ? FunctionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Function ? Function[P] : never
  } 
      : Function


  type FunctionCountArgs = Merge<
    Omit<FunctionFindManyArgs, 'select' | 'include'> & {
      select?: FunctionCountAggregateInputType | true
    }
  >

  export interface FunctionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Function that matches the filter.
     * @param {FunctionFindUniqueArgs} args - Arguments to find a Function
     * @example
     * // Get one Function
     * const function = await prisma.function.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FunctionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FunctionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Function'> extends True ? Prisma__FunctionClient<FunctionGetPayload<T>> : Prisma__FunctionClient<FunctionGetPayload<T> | null, null>

    /**
     * Find one Function that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FunctionFindUniqueOrThrowArgs} args - Arguments to find a Function
     * @example
     * // Get one Function
     * const function = await prisma.function.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FunctionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FunctionFindUniqueOrThrowArgs>
    ): Prisma__FunctionClient<FunctionGetPayload<T>>

    /**
     * Find the first Function that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionFindFirstArgs} args - Arguments to find a Function
     * @example
     * // Get one Function
     * const function = await prisma.function.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FunctionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FunctionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Function'> extends True ? Prisma__FunctionClient<FunctionGetPayload<T>> : Prisma__FunctionClient<FunctionGetPayload<T> | null, null>

    /**
     * Find the first Function that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionFindFirstOrThrowArgs} args - Arguments to find a Function
     * @example
     * // Get one Function
     * const function = await prisma.function.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FunctionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FunctionFindFirstOrThrowArgs>
    ): Prisma__FunctionClient<FunctionGetPayload<T>>

    /**
     * Find zero or more Functions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Functions
     * const functions = await prisma.function.findMany()
     * 
     * // Get first 10 Functions
     * const functions = await prisma.function.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const functionWithIdOnly = await prisma.function.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FunctionFindManyArgs>(
      args?: SelectSubset<T, FunctionFindManyArgs>
    ): PrismaPromise<Array<FunctionGetPayload<T>>>

    /**
     * Create a Function.
     * @param {FunctionCreateArgs} args - Arguments to create a Function.
     * @example
     * // Create one Function
     * const Function = await prisma.function.create({
     *   data: {
     *     // ... data to create a Function
     *   }
     * })
     * 
    **/
    create<T extends FunctionCreateArgs>(
      args: SelectSubset<T, FunctionCreateArgs>
    ): Prisma__FunctionClient<FunctionGetPayload<T>>

    /**
     * Create many Functions.
     *     @param {FunctionCreateManyArgs} args - Arguments to create many Functions.
     *     @example
     *     // Create many Functions
     *     const function = await prisma.function.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FunctionCreateManyArgs>(
      args?: SelectSubset<T, FunctionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Function.
     * @param {FunctionDeleteArgs} args - Arguments to delete one Function.
     * @example
     * // Delete one Function
     * const Function = await prisma.function.delete({
     *   where: {
     *     // ... filter to delete one Function
     *   }
     * })
     * 
    **/
    delete<T extends FunctionDeleteArgs>(
      args: SelectSubset<T, FunctionDeleteArgs>
    ): Prisma__FunctionClient<FunctionGetPayload<T>>

    /**
     * Update one Function.
     * @param {FunctionUpdateArgs} args - Arguments to update one Function.
     * @example
     * // Update one Function
     * const function = await prisma.function.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FunctionUpdateArgs>(
      args: SelectSubset<T, FunctionUpdateArgs>
    ): Prisma__FunctionClient<FunctionGetPayload<T>>

    /**
     * Delete zero or more Functions.
     * @param {FunctionDeleteManyArgs} args - Arguments to filter Functions to delete.
     * @example
     * // Delete a few Functions
     * const { count } = await prisma.function.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FunctionDeleteManyArgs>(
      args?: SelectSubset<T, FunctionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Functions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Functions
     * const function = await prisma.function.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FunctionUpdateManyArgs>(
      args: SelectSubset<T, FunctionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Function.
     * @param {FunctionUpsertArgs} args - Arguments to update or create a Function.
     * @example
     * // Update or create a Function
     * const function = await prisma.function.upsert({
     *   create: {
     *     // ... data to create a Function
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Function we want to update
     *   }
     * })
    **/
    upsert<T extends FunctionUpsertArgs>(
      args: SelectSubset<T, FunctionUpsertArgs>
    ): Prisma__FunctionClient<FunctionGetPayload<T>>

    /**
     * Count the number of Functions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionCountArgs} args - Arguments to filter Functions to count.
     * @example
     * // Count the number of Functions
     * const count = await prisma.function.count({
     *   where: {
     *     // ... the filter for the Functions we want to count
     *   }
     * })
    **/
    count<T extends FunctionCountArgs>(
      args?: Subset<T, FunctionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FunctionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Function.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FunctionAggregateArgs>(args: Subset<T, FunctionAggregateArgs>): PrismaPromise<GetFunctionAggregateType<T>>

    /**
     * Group by Function.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FunctionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FunctionGroupByArgs['orderBy'] }
        : { orderBy?: FunctionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FunctionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunctionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Function.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FunctionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    QuestionRule<T extends QuestionRuleFindManyArgs= {}>(args?: Subset<T, QuestionRuleFindManyArgs>): PrismaPromise<Array<QuestionRuleGetPayload<T>>| Null>;

    OptionRule<T extends OptionRuleFindManyArgs= {}>(args?: Subset<T, OptionRuleFindManyArgs>): PrismaPromise<Array<OptionRuleGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Function base type for findUnique actions
   */
  export type FunctionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Function
     * 
    **/
    select?: FunctionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FunctionInclude | null
    /**
     * Filter, which Function to fetch.
     * 
    **/
    where: FunctionWhereUniqueInput
  }

  /**
   * Function: findUnique
   */
  export interface FunctionFindUniqueArgs extends FunctionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Function findUniqueOrThrow
   */
  export type FunctionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Function
     * 
    **/
    select?: FunctionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FunctionInclude | null
    /**
     * Filter, which Function to fetch.
     * 
    **/
    where: FunctionWhereUniqueInput
  }


  /**
   * Function base type for findFirst actions
   */
  export type FunctionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Function
     * 
    **/
    select?: FunctionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FunctionInclude | null
    /**
     * Filter, which Function to fetch.
     * 
    **/
    where?: FunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Functions to fetch.
     * 
    **/
    orderBy?: Enumerable<FunctionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Functions.
     * 
    **/
    cursor?: FunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Functions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Functions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Functions.
     * 
    **/
    distinct?: Enumerable<FunctionScalarFieldEnum>
  }

  /**
   * Function: findFirst
   */
  export interface FunctionFindFirstArgs extends FunctionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Function findFirstOrThrow
   */
  export type FunctionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Function
     * 
    **/
    select?: FunctionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FunctionInclude | null
    /**
     * Filter, which Function to fetch.
     * 
    **/
    where?: FunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Functions to fetch.
     * 
    **/
    orderBy?: Enumerable<FunctionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Functions.
     * 
    **/
    cursor?: FunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Functions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Functions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Functions.
     * 
    **/
    distinct?: Enumerable<FunctionScalarFieldEnum>
  }


  /**
   * Function findMany
   */
  export type FunctionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Function
     * 
    **/
    select?: FunctionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FunctionInclude | null
    /**
     * Filter, which Functions to fetch.
     * 
    **/
    where?: FunctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Functions to fetch.
     * 
    **/
    orderBy?: Enumerable<FunctionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Functions.
     * 
    **/
    cursor?: FunctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Functions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Functions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FunctionScalarFieldEnum>
  }


  /**
   * Function create
   */
  export type FunctionCreateArgs = {
    /**
     * Select specific fields to fetch from the Function
     * 
    **/
    select?: FunctionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FunctionInclude | null
    /**
     * The data needed to create a Function.
     * 
    **/
    data: XOR<FunctionCreateInput, FunctionUncheckedCreateInput>
  }


  /**
   * Function createMany
   */
  export type FunctionCreateManyArgs = {
    /**
     * The data used to create many Functions.
     * 
    **/
    data: Enumerable<FunctionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Function update
   */
  export type FunctionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Function
     * 
    **/
    select?: FunctionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FunctionInclude | null
    /**
     * The data needed to update a Function.
     * 
    **/
    data: XOR<FunctionUpdateInput, FunctionUncheckedUpdateInput>
    /**
     * Choose, which Function to update.
     * 
    **/
    where: FunctionWhereUniqueInput
  }


  /**
   * Function updateMany
   */
  export type FunctionUpdateManyArgs = {
    /**
     * The data used to update Functions.
     * 
    **/
    data: XOR<FunctionUpdateManyMutationInput, FunctionUncheckedUpdateManyInput>
    /**
     * Filter which Functions to update
     * 
    **/
    where?: FunctionWhereInput
  }


  /**
   * Function upsert
   */
  export type FunctionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Function
     * 
    **/
    select?: FunctionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FunctionInclude | null
    /**
     * The filter to search for the Function to update in case it exists.
     * 
    **/
    where: FunctionWhereUniqueInput
    /**
     * In case the Function found by the `where` argument doesn't exist, create a new Function with this data.
     * 
    **/
    create: XOR<FunctionCreateInput, FunctionUncheckedCreateInput>
    /**
     * In case the Function was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FunctionUpdateInput, FunctionUncheckedUpdateInput>
  }


  /**
   * Function delete
   */
  export type FunctionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Function
     * 
    **/
    select?: FunctionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FunctionInclude | null
    /**
     * Filter which Function to delete.
     * 
    **/
    where: FunctionWhereUniqueInput
  }


  /**
   * Function deleteMany
   */
  export type FunctionDeleteManyArgs = {
    /**
     * Filter which Functions to delete
     * 
    **/
    where?: FunctionWhereInput
  }


  /**
   * Function without action
   */
  export type FunctionArgs = {
    /**
     * Select specific fields to fetch from the Function
     * 
    **/
    select?: FunctionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FunctionInclude | null
  }



  /**
   * Model TouchPoint
   */


  export type AggregateTouchPoint = {
    _count: TouchPointCountAggregateOutputType | null
    _avg: TouchPointAvgAggregateOutputType | null
    _sum: TouchPointSumAggregateOutputType | null
    _min: TouchPointMinAggregateOutputType | null
    _max: TouchPointMaxAggregateOutputType | null
  }

  export type TouchPointAvgAggregateOutputType = {
    id: number | null
    claimantId: number | null
  }

  export type TouchPointSumAggregateOutputType = {
    id: number | null
    claimantId: number | null
  }

  export type TouchPointMinAggregateOutputType = {
    id: number | null
    claimantId: number | null
    type: TouchPointType | null
    created: Date | null
    updated: Date | null
  }

  export type TouchPointMaxAggregateOutputType = {
    id: number | null
    claimantId: number | null
    type: TouchPointType | null
    created: Date | null
    updated: Date | null
  }

  export type TouchPointCountAggregateOutputType = {
    id: number
    claimantId: number
    type: number
    created: number
    updated: number
    _all: number
  }


  export type TouchPointAvgAggregateInputType = {
    id?: true
    claimantId?: true
  }

  export type TouchPointSumAggregateInputType = {
    id?: true
    claimantId?: true
  }

  export type TouchPointMinAggregateInputType = {
    id?: true
    claimantId?: true
    type?: true
    created?: true
    updated?: true
  }

  export type TouchPointMaxAggregateInputType = {
    id?: true
    claimantId?: true
    type?: true
    created?: true
    updated?: true
  }

  export type TouchPointCountAggregateInputType = {
    id?: true
    claimantId?: true
    type?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type TouchPointAggregateArgs = {
    /**
     * Filter which TouchPoint to aggregate.
     * 
    **/
    where?: TouchPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TouchPoints to fetch.
     * 
    **/
    orderBy?: Enumerable<TouchPointOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TouchPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TouchPoints from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TouchPoints.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TouchPoints
    **/
    _count?: true | TouchPointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TouchPointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TouchPointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TouchPointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TouchPointMaxAggregateInputType
  }

  export type GetTouchPointAggregateType<T extends TouchPointAggregateArgs> = {
        [P in keyof T & keyof AggregateTouchPoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTouchPoint[P]>
      : GetScalarType<T[P], AggregateTouchPoint[P]>
  }




  export type TouchPointGroupByArgs = {
    where?: TouchPointWhereInput
    orderBy?: Enumerable<TouchPointOrderByWithAggregationInput>
    by: Array<TouchPointScalarFieldEnum>
    having?: TouchPointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TouchPointCountAggregateInputType | true
    _avg?: TouchPointAvgAggregateInputType
    _sum?: TouchPointSumAggregateInputType
    _min?: TouchPointMinAggregateInputType
    _max?: TouchPointMaxAggregateInputType
  }


  export type TouchPointGroupByOutputType = {
    id: number
    claimantId: number
    type: TouchPointType
    created: Date
    updated: Date
    _count: TouchPointCountAggregateOutputType | null
    _avg: TouchPointAvgAggregateOutputType | null
    _sum: TouchPointSumAggregateOutputType | null
    _min: TouchPointMinAggregateOutputType | null
    _max: TouchPointMaxAggregateOutputType | null
  }

  type GetTouchPointGroupByPayload<T extends TouchPointGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TouchPointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TouchPointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TouchPointGroupByOutputType[P]>
            : GetScalarType<T[P], TouchPointGroupByOutputType[P]>
        }
      >
    >


  export type TouchPointSelect = {
    id?: boolean
    claimantId?: boolean
    type?: boolean
    created?: boolean
    updated?: boolean
    claimant?: boolean | ClaimantArgs
  }


  export type TouchPointInclude = {
    claimant?: boolean | ClaimantArgs
  } 

  export type TouchPointGetPayload<S extends boolean | null | undefined | TouchPointArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TouchPoint :
    S extends undefined ? never :
    S extends { include: any } & (TouchPointArgs | TouchPointFindManyArgs)
    ? TouchPoint  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'claimant' ? ClaimantGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TouchPointArgs | TouchPointFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'claimant' ? ClaimantGetPayload<S['select'][P]> :  P extends keyof TouchPoint ? TouchPoint[P] : never
  } 
      : TouchPoint


  type TouchPointCountArgs = Merge<
    Omit<TouchPointFindManyArgs, 'select' | 'include'> & {
      select?: TouchPointCountAggregateInputType | true
    }
  >

  export interface TouchPointDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one TouchPoint that matches the filter.
     * @param {TouchPointFindUniqueArgs} args - Arguments to find a TouchPoint
     * @example
     * // Get one TouchPoint
     * const touchPoint = await prisma.touchPoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TouchPointFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TouchPointFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TouchPoint'> extends True ? Prisma__TouchPointClient<TouchPointGetPayload<T>> : Prisma__TouchPointClient<TouchPointGetPayload<T> | null, null>

    /**
     * Find one TouchPoint that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TouchPointFindUniqueOrThrowArgs} args - Arguments to find a TouchPoint
     * @example
     * // Get one TouchPoint
     * const touchPoint = await prisma.touchPoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TouchPointFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TouchPointFindUniqueOrThrowArgs>
    ): Prisma__TouchPointClient<TouchPointGetPayload<T>>

    /**
     * Find the first TouchPoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchPointFindFirstArgs} args - Arguments to find a TouchPoint
     * @example
     * // Get one TouchPoint
     * const touchPoint = await prisma.touchPoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TouchPointFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TouchPointFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TouchPoint'> extends True ? Prisma__TouchPointClient<TouchPointGetPayload<T>> : Prisma__TouchPointClient<TouchPointGetPayload<T> | null, null>

    /**
     * Find the first TouchPoint that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchPointFindFirstOrThrowArgs} args - Arguments to find a TouchPoint
     * @example
     * // Get one TouchPoint
     * const touchPoint = await prisma.touchPoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TouchPointFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TouchPointFindFirstOrThrowArgs>
    ): Prisma__TouchPointClient<TouchPointGetPayload<T>>

    /**
     * Find zero or more TouchPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchPointFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TouchPoints
     * const touchPoints = await prisma.touchPoint.findMany()
     * 
     * // Get first 10 TouchPoints
     * const touchPoints = await prisma.touchPoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const touchPointWithIdOnly = await prisma.touchPoint.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TouchPointFindManyArgs>(
      args?: SelectSubset<T, TouchPointFindManyArgs>
    ): PrismaPromise<Array<TouchPointGetPayload<T>>>

    /**
     * Create a TouchPoint.
     * @param {TouchPointCreateArgs} args - Arguments to create a TouchPoint.
     * @example
     * // Create one TouchPoint
     * const TouchPoint = await prisma.touchPoint.create({
     *   data: {
     *     // ... data to create a TouchPoint
     *   }
     * })
     * 
    **/
    create<T extends TouchPointCreateArgs>(
      args: SelectSubset<T, TouchPointCreateArgs>
    ): Prisma__TouchPointClient<TouchPointGetPayload<T>>

    /**
     * Create many TouchPoints.
     *     @param {TouchPointCreateManyArgs} args - Arguments to create many TouchPoints.
     *     @example
     *     // Create many TouchPoints
     *     const touchPoint = await prisma.touchPoint.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TouchPointCreateManyArgs>(
      args?: SelectSubset<T, TouchPointCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TouchPoint.
     * @param {TouchPointDeleteArgs} args - Arguments to delete one TouchPoint.
     * @example
     * // Delete one TouchPoint
     * const TouchPoint = await prisma.touchPoint.delete({
     *   where: {
     *     // ... filter to delete one TouchPoint
     *   }
     * })
     * 
    **/
    delete<T extends TouchPointDeleteArgs>(
      args: SelectSubset<T, TouchPointDeleteArgs>
    ): Prisma__TouchPointClient<TouchPointGetPayload<T>>

    /**
     * Update one TouchPoint.
     * @param {TouchPointUpdateArgs} args - Arguments to update one TouchPoint.
     * @example
     * // Update one TouchPoint
     * const touchPoint = await prisma.touchPoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TouchPointUpdateArgs>(
      args: SelectSubset<T, TouchPointUpdateArgs>
    ): Prisma__TouchPointClient<TouchPointGetPayload<T>>

    /**
     * Delete zero or more TouchPoints.
     * @param {TouchPointDeleteManyArgs} args - Arguments to filter TouchPoints to delete.
     * @example
     * // Delete a few TouchPoints
     * const { count } = await prisma.touchPoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TouchPointDeleteManyArgs>(
      args?: SelectSubset<T, TouchPointDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TouchPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchPointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TouchPoints
     * const touchPoint = await prisma.touchPoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TouchPointUpdateManyArgs>(
      args: SelectSubset<T, TouchPointUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TouchPoint.
     * @param {TouchPointUpsertArgs} args - Arguments to update or create a TouchPoint.
     * @example
     * // Update or create a TouchPoint
     * const touchPoint = await prisma.touchPoint.upsert({
     *   create: {
     *     // ... data to create a TouchPoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TouchPoint we want to update
     *   }
     * })
    **/
    upsert<T extends TouchPointUpsertArgs>(
      args: SelectSubset<T, TouchPointUpsertArgs>
    ): Prisma__TouchPointClient<TouchPointGetPayload<T>>

    /**
     * Count the number of TouchPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchPointCountArgs} args - Arguments to filter TouchPoints to count.
     * @example
     * // Count the number of TouchPoints
     * const count = await prisma.touchPoint.count({
     *   where: {
     *     // ... the filter for the TouchPoints we want to count
     *   }
     * })
    **/
    count<T extends TouchPointCountArgs>(
      args?: Subset<T, TouchPointCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TouchPointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TouchPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchPointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TouchPointAggregateArgs>(args: Subset<T, TouchPointAggregateArgs>): PrismaPromise<GetTouchPointAggregateType<T>>

    /**
     * Group by TouchPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TouchPointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TouchPointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TouchPointGroupByArgs['orderBy'] }
        : { orderBy?: TouchPointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TouchPointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTouchPointGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TouchPoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TouchPointClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    claimant<T extends ClaimantArgs= {}>(args?: Subset<T, ClaimantArgs>): Prisma__ClaimantClient<ClaimantGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TouchPoint base type for findUnique actions
   */
  export type TouchPointFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TouchPoint
     * 
    **/
    select?: TouchPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchPointInclude | null
    /**
     * Filter, which TouchPoint to fetch.
     * 
    **/
    where: TouchPointWhereUniqueInput
  }

  /**
   * TouchPoint: findUnique
   */
  export interface TouchPointFindUniqueArgs extends TouchPointFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TouchPoint findUniqueOrThrow
   */
  export type TouchPointFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TouchPoint
     * 
    **/
    select?: TouchPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchPointInclude | null
    /**
     * Filter, which TouchPoint to fetch.
     * 
    **/
    where: TouchPointWhereUniqueInput
  }


  /**
   * TouchPoint base type for findFirst actions
   */
  export type TouchPointFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TouchPoint
     * 
    **/
    select?: TouchPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchPointInclude | null
    /**
     * Filter, which TouchPoint to fetch.
     * 
    **/
    where?: TouchPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TouchPoints to fetch.
     * 
    **/
    orderBy?: Enumerable<TouchPointOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TouchPoints.
     * 
    **/
    cursor?: TouchPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TouchPoints from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TouchPoints.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TouchPoints.
     * 
    **/
    distinct?: Enumerable<TouchPointScalarFieldEnum>
  }

  /**
   * TouchPoint: findFirst
   */
  export interface TouchPointFindFirstArgs extends TouchPointFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TouchPoint findFirstOrThrow
   */
  export type TouchPointFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TouchPoint
     * 
    **/
    select?: TouchPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchPointInclude | null
    /**
     * Filter, which TouchPoint to fetch.
     * 
    **/
    where?: TouchPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TouchPoints to fetch.
     * 
    **/
    orderBy?: Enumerable<TouchPointOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TouchPoints.
     * 
    **/
    cursor?: TouchPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TouchPoints from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TouchPoints.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TouchPoints.
     * 
    **/
    distinct?: Enumerable<TouchPointScalarFieldEnum>
  }


  /**
   * TouchPoint findMany
   */
  export type TouchPointFindManyArgs = {
    /**
     * Select specific fields to fetch from the TouchPoint
     * 
    **/
    select?: TouchPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchPointInclude | null
    /**
     * Filter, which TouchPoints to fetch.
     * 
    **/
    where?: TouchPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TouchPoints to fetch.
     * 
    **/
    orderBy?: Enumerable<TouchPointOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TouchPoints.
     * 
    **/
    cursor?: TouchPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TouchPoints from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TouchPoints.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TouchPointScalarFieldEnum>
  }


  /**
   * TouchPoint create
   */
  export type TouchPointCreateArgs = {
    /**
     * Select specific fields to fetch from the TouchPoint
     * 
    **/
    select?: TouchPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchPointInclude | null
    /**
     * The data needed to create a TouchPoint.
     * 
    **/
    data: XOR<TouchPointCreateInput, TouchPointUncheckedCreateInput>
  }


  /**
   * TouchPoint createMany
   */
  export type TouchPointCreateManyArgs = {
    /**
     * The data used to create many TouchPoints.
     * 
    **/
    data: Enumerable<TouchPointCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TouchPoint update
   */
  export type TouchPointUpdateArgs = {
    /**
     * Select specific fields to fetch from the TouchPoint
     * 
    **/
    select?: TouchPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchPointInclude | null
    /**
     * The data needed to update a TouchPoint.
     * 
    **/
    data: XOR<TouchPointUpdateInput, TouchPointUncheckedUpdateInput>
    /**
     * Choose, which TouchPoint to update.
     * 
    **/
    where: TouchPointWhereUniqueInput
  }


  /**
   * TouchPoint updateMany
   */
  export type TouchPointUpdateManyArgs = {
    /**
     * The data used to update TouchPoints.
     * 
    **/
    data: XOR<TouchPointUpdateManyMutationInput, TouchPointUncheckedUpdateManyInput>
    /**
     * Filter which TouchPoints to update
     * 
    **/
    where?: TouchPointWhereInput
  }


  /**
   * TouchPoint upsert
   */
  export type TouchPointUpsertArgs = {
    /**
     * Select specific fields to fetch from the TouchPoint
     * 
    **/
    select?: TouchPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchPointInclude | null
    /**
     * The filter to search for the TouchPoint to update in case it exists.
     * 
    **/
    where: TouchPointWhereUniqueInput
    /**
     * In case the TouchPoint found by the `where` argument doesn't exist, create a new TouchPoint with this data.
     * 
    **/
    create: XOR<TouchPointCreateInput, TouchPointUncheckedCreateInput>
    /**
     * In case the TouchPoint was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TouchPointUpdateInput, TouchPointUncheckedUpdateInput>
  }


  /**
   * TouchPoint delete
   */
  export type TouchPointDeleteArgs = {
    /**
     * Select specific fields to fetch from the TouchPoint
     * 
    **/
    select?: TouchPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchPointInclude | null
    /**
     * Filter which TouchPoint to delete.
     * 
    **/
    where: TouchPointWhereUniqueInput
  }


  /**
   * TouchPoint deleteMany
   */
  export type TouchPointDeleteManyArgs = {
    /**
     * Filter which TouchPoints to delete
     * 
    **/
    where?: TouchPointWhereInput
  }


  /**
   * TouchPoint without action
   */
  export type TouchPointArgs = {
    /**
     * Select specific fields to fetch from the TouchPoint
     * 
    **/
    select?: TouchPointSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TouchPointInclude | null
  }



  /**
   * Model Referrer
   */


  export type AggregateReferrer = {
    _count: ReferrerCountAggregateOutputType | null
    _avg: ReferrerAvgAggregateOutputType | null
    _sum: ReferrerSumAggregateOutputType | null
    _min: ReferrerMinAggregateOutputType | null
    _max: ReferrerMaxAggregateOutputType | null
  }

  export type ReferrerAvgAggregateOutputType = {
    id: number | null
    preIntakeTimer: number | null
  }

  export type ReferrerSumAggregateOutputType = {
    id: number | null
    preIntakeTimer: number | null
  }

  export type ReferrerMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: ReferrerTypes | null
    payType: ReferrerPayTypes | null
    preIntakeTimer: number | null
    created: Date | null
    updated: Date | null
  }

  export type ReferrerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: ReferrerTypes | null
    payType: ReferrerPayTypes | null
    preIntakeTimer: number | null
    created: Date | null
    updated: Date | null
  }

  export type ReferrerCountAggregateOutputType = {
    id: number
    name: number
    type: number
    payType: number
    preIntakeTimer: number
    created: number
    updated: number
    _all: number
  }


  export type ReferrerAvgAggregateInputType = {
    id?: true
    preIntakeTimer?: true
  }

  export type ReferrerSumAggregateInputType = {
    id?: true
    preIntakeTimer?: true
  }

  export type ReferrerMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    payType?: true
    preIntakeTimer?: true
    created?: true
    updated?: true
  }

  export type ReferrerMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    payType?: true
    preIntakeTimer?: true
    created?: true
    updated?: true
  }

  export type ReferrerCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    payType?: true
    preIntakeTimer?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type ReferrerAggregateArgs = {
    /**
     * Filter which Referrer to aggregate.
     * 
    **/
    where?: ReferrerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrers to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferrerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ReferrerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrers
    **/
    _count?: true | ReferrerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferrerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferrerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferrerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferrerMaxAggregateInputType
  }

  export type GetReferrerAggregateType<T extends ReferrerAggregateArgs> = {
        [P in keyof T & keyof AggregateReferrer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferrer[P]>
      : GetScalarType<T[P], AggregateReferrer[P]>
  }




  export type ReferrerGroupByArgs = {
    where?: ReferrerWhereInput
    orderBy?: Enumerable<ReferrerOrderByWithAggregationInput>
    by: Array<ReferrerScalarFieldEnum>
    having?: ReferrerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferrerCountAggregateInputType | true
    _avg?: ReferrerAvgAggregateInputType
    _sum?: ReferrerSumAggregateInputType
    _min?: ReferrerMinAggregateInputType
    _max?: ReferrerMaxAggregateInputType
  }


  export type ReferrerGroupByOutputType = {
    id: number
    name: string
    type: ReferrerTypes
    payType: ReferrerPayTypes
    preIntakeTimer: number
    created: Date
    updated: Date
    _count: ReferrerCountAggregateOutputType | null
    _avg: ReferrerAvgAggregateOutputType | null
    _sum: ReferrerSumAggregateOutputType | null
    _min: ReferrerMinAggregateOutputType | null
    _max: ReferrerMaxAggregateOutputType | null
  }

  type GetReferrerGroupByPayload<T extends ReferrerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReferrerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferrerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferrerGroupByOutputType[P]>
            : GetScalarType<T[P], ReferrerGroupByOutputType[P]>
        }
      >
    >


  export type ReferrerSelect = {
    id?: boolean
    name?: boolean
    type?: boolean
    payType?: boolean
    preIntakeTimer?: boolean
    created?: boolean
    updated?: boolean
    Claimant?: boolean | ClaimantFindManyArgs
    _count?: boolean | ReferrerCountOutputTypeArgs
  }


  export type ReferrerInclude = {
    Claimant?: boolean | ClaimantFindManyArgs
    _count?: boolean | ReferrerCountOutputTypeArgs
  } 

  export type ReferrerGetPayload<S extends boolean | null | undefined | ReferrerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Referrer :
    S extends undefined ? never :
    S extends { include: any } & (ReferrerArgs | ReferrerFindManyArgs)
    ? Referrer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Claimant' ? Array < ClaimantGetPayload<S['include'][P]>>  :
        P extends '_count' ? ReferrerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ReferrerArgs | ReferrerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Claimant' ? Array < ClaimantGetPayload<S['select'][P]>>  :
        P extends '_count' ? ReferrerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Referrer ? Referrer[P] : never
  } 
      : Referrer


  type ReferrerCountArgs = Merge<
    Omit<ReferrerFindManyArgs, 'select' | 'include'> & {
      select?: ReferrerCountAggregateInputType | true
    }
  >

  export interface ReferrerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Referrer that matches the filter.
     * @param {ReferrerFindUniqueArgs} args - Arguments to find a Referrer
     * @example
     * // Get one Referrer
     * const referrer = await prisma.referrer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReferrerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReferrerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Referrer'> extends True ? Prisma__ReferrerClient<ReferrerGetPayload<T>> : Prisma__ReferrerClient<ReferrerGetPayload<T> | null, null>

    /**
     * Find one Referrer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReferrerFindUniqueOrThrowArgs} args - Arguments to find a Referrer
     * @example
     * // Get one Referrer
     * const referrer = await prisma.referrer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReferrerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReferrerFindUniqueOrThrowArgs>
    ): Prisma__ReferrerClient<ReferrerGetPayload<T>>

    /**
     * Find the first Referrer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferrerFindFirstArgs} args - Arguments to find a Referrer
     * @example
     * // Get one Referrer
     * const referrer = await prisma.referrer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReferrerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReferrerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Referrer'> extends True ? Prisma__ReferrerClient<ReferrerGetPayload<T>> : Prisma__ReferrerClient<ReferrerGetPayload<T> | null, null>

    /**
     * Find the first Referrer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferrerFindFirstOrThrowArgs} args - Arguments to find a Referrer
     * @example
     * // Get one Referrer
     * const referrer = await prisma.referrer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReferrerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReferrerFindFirstOrThrowArgs>
    ): Prisma__ReferrerClient<ReferrerGetPayload<T>>

    /**
     * Find zero or more Referrers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferrerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrers
     * const referrers = await prisma.referrer.findMany()
     * 
     * // Get first 10 Referrers
     * const referrers = await prisma.referrer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referrerWithIdOnly = await prisma.referrer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReferrerFindManyArgs>(
      args?: SelectSubset<T, ReferrerFindManyArgs>
    ): PrismaPromise<Array<ReferrerGetPayload<T>>>

    /**
     * Create a Referrer.
     * @param {ReferrerCreateArgs} args - Arguments to create a Referrer.
     * @example
     * // Create one Referrer
     * const Referrer = await prisma.referrer.create({
     *   data: {
     *     // ... data to create a Referrer
     *   }
     * })
     * 
    **/
    create<T extends ReferrerCreateArgs>(
      args: SelectSubset<T, ReferrerCreateArgs>
    ): Prisma__ReferrerClient<ReferrerGetPayload<T>>

    /**
     * Create many Referrers.
     *     @param {ReferrerCreateManyArgs} args - Arguments to create many Referrers.
     *     @example
     *     // Create many Referrers
     *     const referrer = await prisma.referrer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReferrerCreateManyArgs>(
      args?: SelectSubset<T, ReferrerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Referrer.
     * @param {ReferrerDeleteArgs} args - Arguments to delete one Referrer.
     * @example
     * // Delete one Referrer
     * const Referrer = await prisma.referrer.delete({
     *   where: {
     *     // ... filter to delete one Referrer
     *   }
     * })
     * 
    **/
    delete<T extends ReferrerDeleteArgs>(
      args: SelectSubset<T, ReferrerDeleteArgs>
    ): Prisma__ReferrerClient<ReferrerGetPayload<T>>

    /**
     * Update one Referrer.
     * @param {ReferrerUpdateArgs} args - Arguments to update one Referrer.
     * @example
     * // Update one Referrer
     * const referrer = await prisma.referrer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReferrerUpdateArgs>(
      args: SelectSubset<T, ReferrerUpdateArgs>
    ): Prisma__ReferrerClient<ReferrerGetPayload<T>>

    /**
     * Delete zero or more Referrers.
     * @param {ReferrerDeleteManyArgs} args - Arguments to filter Referrers to delete.
     * @example
     * // Delete a few Referrers
     * const { count } = await prisma.referrer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReferrerDeleteManyArgs>(
      args?: SelectSubset<T, ReferrerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferrerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrers
     * const referrer = await prisma.referrer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReferrerUpdateManyArgs>(
      args: SelectSubset<T, ReferrerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Referrer.
     * @param {ReferrerUpsertArgs} args - Arguments to update or create a Referrer.
     * @example
     * // Update or create a Referrer
     * const referrer = await prisma.referrer.upsert({
     *   create: {
     *     // ... data to create a Referrer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referrer we want to update
     *   }
     * })
    **/
    upsert<T extends ReferrerUpsertArgs>(
      args: SelectSubset<T, ReferrerUpsertArgs>
    ): Prisma__ReferrerClient<ReferrerGetPayload<T>>

    /**
     * Count the number of Referrers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferrerCountArgs} args - Arguments to filter Referrers to count.
     * @example
     * // Count the number of Referrers
     * const count = await prisma.referrer.count({
     *   where: {
     *     // ... the filter for the Referrers we want to count
     *   }
     * })
    **/
    count<T extends ReferrerCountArgs>(
      args?: Subset<T, ReferrerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferrerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referrer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferrerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferrerAggregateArgs>(args: Subset<T, ReferrerAggregateArgs>): PrismaPromise<GetReferrerAggregateType<T>>

    /**
     * Group by Referrer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferrerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferrerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferrerGroupByArgs['orderBy'] }
        : { orderBy?: ReferrerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferrerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferrerGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Referrer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReferrerClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Claimant<T extends ClaimantFindManyArgs= {}>(args?: Subset<T, ClaimantFindManyArgs>): PrismaPromise<Array<ClaimantGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Referrer base type for findUnique actions
   */
  export type ReferrerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Referrer
     * 
    **/
    select?: ReferrerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferrerInclude | null
    /**
     * Filter, which Referrer to fetch.
     * 
    **/
    where: ReferrerWhereUniqueInput
  }

  /**
   * Referrer: findUnique
   */
  export interface ReferrerFindUniqueArgs extends ReferrerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Referrer findUniqueOrThrow
   */
  export type ReferrerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Referrer
     * 
    **/
    select?: ReferrerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferrerInclude | null
    /**
     * Filter, which Referrer to fetch.
     * 
    **/
    where: ReferrerWhereUniqueInput
  }


  /**
   * Referrer base type for findFirst actions
   */
  export type ReferrerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Referrer
     * 
    **/
    select?: ReferrerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferrerInclude | null
    /**
     * Filter, which Referrer to fetch.
     * 
    **/
    where?: ReferrerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrers to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferrerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrers.
     * 
    **/
    cursor?: ReferrerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrers.
     * 
    **/
    distinct?: Enumerable<ReferrerScalarFieldEnum>
  }

  /**
   * Referrer: findFirst
   */
  export interface ReferrerFindFirstArgs extends ReferrerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Referrer findFirstOrThrow
   */
  export type ReferrerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Referrer
     * 
    **/
    select?: ReferrerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferrerInclude | null
    /**
     * Filter, which Referrer to fetch.
     * 
    **/
    where?: ReferrerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrers to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferrerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrers.
     * 
    **/
    cursor?: ReferrerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrers.
     * 
    **/
    distinct?: Enumerable<ReferrerScalarFieldEnum>
  }


  /**
   * Referrer findMany
   */
  export type ReferrerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Referrer
     * 
    **/
    select?: ReferrerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferrerInclude | null
    /**
     * Filter, which Referrers to fetch.
     * 
    **/
    where?: ReferrerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrers to fetch.
     * 
    **/
    orderBy?: Enumerable<ReferrerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrers.
     * 
    **/
    cursor?: ReferrerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReferrerScalarFieldEnum>
  }


  /**
   * Referrer create
   */
  export type ReferrerCreateArgs = {
    /**
     * Select specific fields to fetch from the Referrer
     * 
    **/
    select?: ReferrerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferrerInclude | null
    /**
     * The data needed to create a Referrer.
     * 
    **/
    data: XOR<ReferrerCreateInput, ReferrerUncheckedCreateInput>
  }


  /**
   * Referrer createMany
   */
  export type ReferrerCreateManyArgs = {
    /**
     * The data used to create many Referrers.
     * 
    **/
    data: Enumerable<ReferrerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Referrer update
   */
  export type ReferrerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Referrer
     * 
    **/
    select?: ReferrerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferrerInclude | null
    /**
     * The data needed to update a Referrer.
     * 
    **/
    data: XOR<ReferrerUpdateInput, ReferrerUncheckedUpdateInput>
    /**
     * Choose, which Referrer to update.
     * 
    **/
    where: ReferrerWhereUniqueInput
  }


  /**
   * Referrer updateMany
   */
  export type ReferrerUpdateManyArgs = {
    /**
     * The data used to update Referrers.
     * 
    **/
    data: XOR<ReferrerUpdateManyMutationInput, ReferrerUncheckedUpdateManyInput>
    /**
     * Filter which Referrers to update
     * 
    **/
    where?: ReferrerWhereInput
  }


  /**
   * Referrer upsert
   */
  export type ReferrerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Referrer
     * 
    **/
    select?: ReferrerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferrerInclude | null
    /**
     * The filter to search for the Referrer to update in case it exists.
     * 
    **/
    where: ReferrerWhereUniqueInput
    /**
     * In case the Referrer found by the `where` argument doesn't exist, create a new Referrer with this data.
     * 
    **/
    create: XOR<ReferrerCreateInput, ReferrerUncheckedCreateInput>
    /**
     * In case the Referrer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ReferrerUpdateInput, ReferrerUncheckedUpdateInput>
  }


  /**
   * Referrer delete
   */
  export type ReferrerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Referrer
     * 
    **/
    select?: ReferrerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferrerInclude | null
    /**
     * Filter which Referrer to delete.
     * 
    **/
    where: ReferrerWhereUniqueInput
  }


  /**
   * Referrer deleteMany
   */
  export type ReferrerDeleteManyArgs = {
    /**
     * Filter which Referrers to delete
     * 
    **/
    where?: ReferrerWhereInput
  }


  /**
   * Referrer without action
   */
  export type ReferrerArgs = {
    /**
     * Select specific fields to fetch from the Referrer
     * 
    **/
    select?: ReferrerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ReferrerInclude | null
  }



  /**
   * Model SSAStatus
   */


  export type AggregateSSAStatus = {
    _count: SSAStatusCountAggregateOutputType | null
    _avg: SSAStatusAvgAggregateOutputType | null
    _sum: SSAStatusSumAggregateOutputType | null
    _min: SSAStatusMinAggregateOutputType | null
    _max: SSAStatusMaxAggregateOutputType | null
  }

  export type SSAStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type SSAStatusSumAggregateOutputType = {
    id: number | null
  }

  export type SSAStatusMinAggregateOutputType = {
    id: number | null
    name: string | null
    created: Date | null
    updated: Date | null
  }

  export type SSAStatusMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created: Date | null
    updated: Date | null
  }

  export type SSAStatusCountAggregateOutputType = {
    id: number
    name: number
    created: number
    updated: number
    _all: number
  }


  export type SSAStatusAvgAggregateInputType = {
    id?: true
  }

  export type SSAStatusSumAggregateInputType = {
    id?: true
  }

  export type SSAStatusMinAggregateInputType = {
    id?: true
    name?: true
    created?: true
    updated?: true
  }

  export type SSAStatusMaxAggregateInputType = {
    id?: true
    name?: true
    created?: true
    updated?: true
  }

  export type SSAStatusCountAggregateInputType = {
    id?: true
    name?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type SSAStatusAggregateArgs = {
    /**
     * Filter which SSAStatus to aggregate.
     * 
    **/
    where?: SSAStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSAStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<SSAStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SSAStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSAStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSAStatuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SSAStatuses
    **/
    _count?: true | SSAStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SSAStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SSAStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SSAStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SSAStatusMaxAggregateInputType
  }

  export type GetSSAStatusAggregateType<T extends SSAStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateSSAStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSSAStatus[P]>
      : GetScalarType<T[P], AggregateSSAStatus[P]>
  }




  export type SSAStatusGroupByArgs = {
    where?: SSAStatusWhereInput
    orderBy?: Enumerable<SSAStatusOrderByWithAggregationInput>
    by: Array<SSAStatusScalarFieldEnum>
    having?: SSAStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SSAStatusCountAggregateInputType | true
    _avg?: SSAStatusAvgAggregateInputType
    _sum?: SSAStatusSumAggregateInputType
    _min?: SSAStatusMinAggregateInputType
    _max?: SSAStatusMaxAggregateInputType
  }


  export type SSAStatusGroupByOutputType = {
    id: number
    name: string
    created: Date
    updated: Date
    _count: SSAStatusCountAggregateOutputType | null
    _avg: SSAStatusAvgAggregateOutputType | null
    _sum: SSAStatusSumAggregateOutputType | null
    _min: SSAStatusMinAggregateOutputType | null
    _max: SSAStatusMaxAggregateOutputType | null
  }

  type GetSSAStatusGroupByPayload<T extends SSAStatusGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SSAStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SSAStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SSAStatusGroupByOutputType[P]>
            : GetScalarType<T[P], SSAStatusGroupByOutputType[P]>
        }
      >
    >


  export type SSAStatusSelect = {
    id?: boolean
    name?: boolean
    created?: boolean
    updated?: boolean
    claimant?: boolean | ClaimantFindManyArgs
    OptionRule?: boolean | OptionRuleFindManyArgs
    QuestionRule?: boolean | QuestionRuleFindManyArgs
    _count?: boolean | SSAStatusCountOutputTypeArgs
  }


  export type SSAStatusInclude = {
    claimant?: boolean | ClaimantFindManyArgs
    OptionRule?: boolean | OptionRuleFindManyArgs
    QuestionRule?: boolean | QuestionRuleFindManyArgs
    _count?: boolean | SSAStatusCountOutputTypeArgs
  } 

  export type SSAStatusGetPayload<S extends boolean | null | undefined | SSAStatusArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SSAStatus :
    S extends undefined ? never :
    S extends { include: any } & (SSAStatusArgs | SSAStatusFindManyArgs)
    ? SSAStatus  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'claimant' ? Array < ClaimantGetPayload<S['include'][P]>>  :
        P extends 'OptionRule' ? Array < OptionRuleGetPayload<S['include'][P]>>  :
        P extends 'QuestionRule' ? Array < QuestionRuleGetPayload<S['include'][P]>>  :
        P extends '_count' ? SSAStatusCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SSAStatusArgs | SSAStatusFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'claimant' ? Array < ClaimantGetPayload<S['select'][P]>>  :
        P extends 'OptionRule' ? Array < OptionRuleGetPayload<S['select'][P]>>  :
        P extends 'QuestionRule' ? Array < QuestionRuleGetPayload<S['select'][P]>>  :
        P extends '_count' ? SSAStatusCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SSAStatus ? SSAStatus[P] : never
  } 
      : SSAStatus


  type SSAStatusCountArgs = Merge<
    Omit<SSAStatusFindManyArgs, 'select' | 'include'> & {
      select?: SSAStatusCountAggregateInputType | true
    }
  >

  export interface SSAStatusDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one SSAStatus that matches the filter.
     * @param {SSAStatusFindUniqueArgs} args - Arguments to find a SSAStatus
     * @example
     * // Get one SSAStatus
     * const sSAStatus = await prisma.sSAStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SSAStatusFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SSAStatusFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SSAStatus'> extends True ? Prisma__SSAStatusClient<SSAStatusGetPayload<T>> : Prisma__SSAStatusClient<SSAStatusGetPayload<T> | null, null>

    /**
     * Find one SSAStatus that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SSAStatusFindUniqueOrThrowArgs} args - Arguments to find a SSAStatus
     * @example
     * // Get one SSAStatus
     * const sSAStatus = await prisma.sSAStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SSAStatusFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SSAStatusFindUniqueOrThrowArgs>
    ): Prisma__SSAStatusClient<SSAStatusGetPayload<T>>

    /**
     * Find the first SSAStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSAStatusFindFirstArgs} args - Arguments to find a SSAStatus
     * @example
     * // Get one SSAStatus
     * const sSAStatus = await prisma.sSAStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SSAStatusFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SSAStatusFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SSAStatus'> extends True ? Prisma__SSAStatusClient<SSAStatusGetPayload<T>> : Prisma__SSAStatusClient<SSAStatusGetPayload<T> | null, null>

    /**
     * Find the first SSAStatus that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSAStatusFindFirstOrThrowArgs} args - Arguments to find a SSAStatus
     * @example
     * // Get one SSAStatus
     * const sSAStatus = await prisma.sSAStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SSAStatusFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SSAStatusFindFirstOrThrowArgs>
    ): Prisma__SSAStatusClient<SSAStatusGetPayload<T>>

    /**
     * Find zero or more SSAStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSAStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SSAStatuses
     * const sSAStatuses = await prisma.sSAStatus.findMany()
     * 
     * // Get first 10 SSAStatuses
     * const sSAStatuses = await prisma.sSAStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sSAStatusWithIdOnly = await prisma.sSAStatus.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SSAStatusFindManyArgs>(
      args?: SelectSubset<T, SSAStatusFindManyArgs>
    ): PrismaPromise<Array<SSAStatusGetPayload<T>>>

    /**
     * Create a SSAStatus.
     * @param {SSAStatusCreateArgs} args - Arguments to create a SSAStatus.
     * @example
     * // Create one SSAStatus
     * const SSAStatus = await prisma.sSAStatus.create({
     *   data: {
     *     // ... data to create a SSAStatus
     *   }
     * })
     * 
    **/
    create<T extends SSAStatusCreateArgs>(
      args: SelectSubset<T, SSAStatusCreateArgs>
    ): Prisma__SSAStatusClient<SSAStatusGetPayload<T>>

    /**
     * Create many SSAStatuses.
     *     @param {SSAStatusCreateManyArgs} args - Arguments to create many SSAStatuses.
     *     @example
     *     // Create many SSAStatuses
     *     const sSAStatus = await prisma.sSAStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SSAStatusCreateManyArgs>(
      args?: SelectSubset<T, SSAStatusCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SSAStatus.
     * @param {SSAStatusDeleteArgs} args - Arguments to delete one SSAStatus.
     * @example
     * // Delete one SSAStatus
     * const SSAStatus = await prisma.sSAStatus.delete({
     *   where: {
     *     // ... filter to delete one SSAStatus
     *   }
     * })
     * 
    **/
    delete<T extends SSAStatusDeleteArgs>(
      args: SelectSubset<T, SSAStatusDeleteArgs>
    ): Prisma__SSAStatusClient<SSAStatusGetPayload<T>>

    /**
     * Update one SSAStatus.
     * @param {SSAStatusUpdateArgs} args - Arguments to update one SSAStatus.
     * @example
     * // Update one SSAStatus
     * const sSAStatus = await prisma.sSAStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SSAStatusUpdateArgs>(
      args: SelectSubset<T, SSAStatusUpdateArgs>
    ): Prisma__SSAStatusClient<SSAStatusGetPayload<T>>

    /**
     * Delete zero or more SSAStatuses.
     * @param {SSAStatusDeleteManyArgs} args - Arguments to filter SSAStatuses to delete.
     * @example
     * // Delete a few SSAStatuses
     * const { count } = await prisma.sSAStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SSAStatusDeleteManyArgs>(
      args?: SelectSubset<T, SSAStatusDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SSAStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSAStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SSAStatuses
     * const sSAStatus = await prisma.sSAStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SSAStatusUpdateManyArgs>(
      args: SelectSubset<T, SSAStatusUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SSAStatus.
     * @param {SSAStatusUpsertArgs} args - Arguments to update or create a SSAStatus.
     * @example
     * // Update or create a SSAStatus
     * const sSAStatus = await prisma.sSAStatus.upsert({
     *   create: {
     *     // ... data to create a SSAStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SSAStatus we want to update
     *   }
     * })
    **/
    upsert<T extends SSAStatusUpsertArgs>(
      args: SelectSubset<T, SSAStatusUpsertArgs>
    ): Prisma__SSAStatusClient<SSAStatusGetPayload<T>>

    /**
     * Count the number of SSAStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSAStatusCountArgs} args - Arguments to filter SSAStatuses to count.
     * @example
     * // Count the number of SSAStatuses
     * const count = await prisma.sSAStatus.count({
     *   where: {
     *     // ... the filter for the SSAStatuses we want to count
     *   }
     * })
    **/
    count<T extends SSAStatusCountArgs>(
      args?: Subset<T, SSAStatusCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SSAStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SSAStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSAStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SSAStatusAggregateArgs>(args: Subset<T, SSAStatusAggregateArgs>): PrismaPromise<GetSSAStatusAggregateType<T>>

    /**
     * Group by SSAStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SSAStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SSAStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SSAStatusGroupByArgs['orderBy'] }
        : { orderBy?: SSAStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SSAStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSSAStatusGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SSAStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SSAStatusClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    claimant<T extends ClaimantFindManyArgs= {}>(args?: Subset<T, ClaimantFindManyArgs>): PrismaPromise<Array<ClaimantGetPayload<T>>| Null>;

    OptionRule<T extends OptionRuleFindManyArgs= {}>(args?: Subset<T, OptionRuleFindManyArgs>): PrismaPromise<Array<OptionRuleGetPayload<T>>| Null>;

    QuestionRule<T extends QuestionRuleFindManyArgs= {}>(args?: Subset<T, QuestionRuleFindManyArgs>): PrismaPromise<Array<QuestionRuleGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SSAStatus base type for findUnique actions
   */
  export type SSAStatusFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SSAStatus
     * 
    **/
    select?: SSAStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SSAStatusInclude | null
    /**
     * Filter, which SSAStatus to fetch.
     * 
    **/
    where: SSAStatusWhereUniqueInput
  }

  /**
   * SSAStatus: findUnique
   */
  export interface SSAStatusFindUniqueArgs extends SSAStatusFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SSAStatus findUniqueOrThrow
   */
  export type SSAStatusFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SSAStatus
     * 
    **/
    select?: SSAStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SSAStatusInclude | null
    /**
     * Filter, which SSAStatus to fetch.
     * 
    **/
    where: SSAStatusWhereUniqueInput
  }


  /**
   * SSAStatus base type for findFirst actions
   */
  export type SSAStatusFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SSAStatus
     * 
    **/
    select?: SSAStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SSAStatusInclude | null
    /**
     * Filter, which SSAStatus to fetch.
     * 
    **/
    where?: SSAStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSAStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<SSAStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SSAStatuses.
     * 
    **/
    cursor?: SSAStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSAStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSAStatuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SSAStatuses.
     * 
    **/
    distinct?: Enumerable<SSAStatusScalarFieldEnum>
  }

  /**
   * SSAStatus: findFirst
   */
  export interface SSAStatusFindFirstArgs extends SSAStatusFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SSAStatus findFirstOrThrow
   */
  export type SSAStatusFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SSAStatus
     * 
    **/
    select?: SSAStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SSAStatusInclude | null
    /**
     * Filter, which SSAStatus to fetch.
     * 
    **/
    where?: SSAStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSAStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<SSAStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SSAStatuses.
     * 
    **/
    cursor?: SSAStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSAStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSAStatuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SSAStatuses.
     * 
    **/
    distinct?: Enumerable<SSAStatusScalarFieldEnum>
  }


  /**
   * SSAStatus findMany
   */
  export type SSAStatusFindManyArgs = {
    /**
     * Select specific fields to fetch from the SSAStatus
     * 
    **/
    select?: SSAStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SSAStatusInclude | null
    /**
     * Filter, which SSAStatuses to fetch.
     * 
    **/
    where?: SSAStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SSAStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<SSAStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SSAStatuses.
     * 
    **/
    cursor?: SSAStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SSAStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SSAStatuses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SSAStatusScalarFieldEnum>
  }


  /**
   * SSAStatus create
   */
  export type SSAStatusCreateArgs = {
    /**
     * Select specific fields to fetch from the SSAStatus
     * 
    **/
    select?: SSAStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SSAStatusInclude | null
    /**
     * The data needed to create a SSAStatus.
     * 
    **/
    data: XOR<SSAStatusCreateInput, SSAStatusUncheckedCreateInput>
  }


  /**
   * SSAStatus createMany
   */
  export type SSAStatusCreateManyArgs = {
    /**
     * The data used to create many SSAStatuses.
     * 
    **/
    data: Enumerable<SSAStatusCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SSAStatus update
   */
  export type SSAStatusUpdateArgs = {
    /**
     * Select specific fields to fetch from the SSAStatus
     * 
    **/
    select?: SSAStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SSAStatusInclude | null
    /**
     * The data needed to update a SSAStatus.
     * 
    **/
    data: XOR<SSAStatusUpdateInput, SSAStatusUncheckedUpdateInput>
    /**
     * Choose, which SSAStatus to update.
     * 
    **/
    where: SSAStatusWhereUniqueInput
  }


  /**
   * SSAStatus updateMany
   */
  export type SSAStatusUpdateManyArgs = {
    /**
     * The data used to update SSAStatuses.
     * 
    **/
    data: XOR<SSAStatusUpdateManyMutationInput, SSAStatusUncheckedUpdateManyInput>
    /**
     * Filter which SSAStatuses to update
     * 
    **/
    where?: SSAStatusWhereInput
  }


  /**
   * SSAStatus upsert
   */
  export type SSAStatusUpsertArgs = {
    /**
     * Select specific fields to fetch from the SSAStatus
     * 
    **/
    select?: SSAStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SSAStatusInclude | null
    /**
     * The filter to search for the SSAStatus to update in case it exists.
     * 
    **/
    where: SSAStatusWhereUniqueInput
    /**
     * In case the SSAStatus found by the `where` argument doesn't exist, create a new SSAStatus with this data.
     * 
    **/
    create: XOR<SSAStatusCreateInput, SSAStatusUncheckedCreateInput>
    /**
     * In case the SSAStatus was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SSAStatusUpdateInput, SSAStatusUncheckedUpdateInput>
  }


  /**
   * SSAStatus delete
   */
  export type SSAStatusDeleteArgs = {
    /**
     * Select specific fields to fetch from the SSAStatus
     * 
    **/
    select?: SSAStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SSAStatusInclude | null
    /**
     * Filter which SSAStatus to delete.
     * 
    **/
    where: SSAStatusWhereUniqueInput
  }


  /**
   * SSAStatus deleteMany
   */
  export type SSAStatusDeleteManyArgs = {
    /**
     * Filter which SSAStatuses to delete
     * 
    **/
    where?: SSAStatusWhereInput
  }


  /**
   * SSAStatus without action
   */
  export type SSAStatusArgs = {
    /**
     * Select specific fields to fetch from the SSAStatus
     * 
    **/
    select?: SSAStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SSAStatusInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AnswerScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    claimantId: 'claimantId',
    sessionId: 'sessionId',
    optionId: 'optionId',
    value: 'value',
    created: 'created',
    updated: 'updated'
  };

  export type AnswerScalarFieldEnum = (typeof AnswerScalarFieldEnum)[keyof typeof AnswerScalarFieldEnum]


  export const CallSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    claimantId: 'claimantId',
    sessionType: 'sessionType',
    sessionStatus: 'sessionStatus',
    created: 'created',
    ended: 'ended',
    updated: 'updated',
    recordingUrl: 'recordingUrl',
    outgoingPhone: 'outgoingPhone'
  };

  export type CallSessionScalarFieldEnum = (typeof CallSessionScalarFieldEnum)[keyof typeof CallSessionScalarFieldEnum]


  export const ClaimantScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    phone: 'phone',
    email: 'email',
    referrerId: 'referrerId',
    ssaStatusId: 'ssaStatusId',
    created: 'created',
    updated: 'updated'
  };

  export type ClaimantScalarFieldEnum = (typeof ClaimantScalarFieldEnum)[keyof typeof ClaimantScalarFieldEnum]


  export const CursorScalarFieldEnum: {
    id: 'id',
    formSectionId: 'formSectionId',
    questionId: 'questionId',
    claimantId: 'claimantId',
    created: 'created',
    updatedAt: 'updatedAt'
  };

  export type CursorScalarFieldEnum = (typeof CursorScalarFieldEnum)[keyof typeof CursorScalarFieldEnum]


  export const FormScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    created: 'created',
    updated: 'updated'
  };

  export type FormScalarFieldEnum = (typeof FormScalarFieldEnum)[keyof typeof FormScalarFieldEnum]


  export const FormSectionScalarFieldEnum: {
    id: 'id',
    formId: 'formId',
    name: 'name',
    order: 'order',
    showTimer: 'showTimer',
    created: 'created',
    updated: 'updated'
  };

  export type FormSectionScalarFieldEnum = (typeof FormSectionScalarFieldEnum)[keyof typeof FormSectionScalarFieldEnum]


  export const FunctionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    function: 'function',
    created: 'created',
    updated: 'updated'
  };

  export type FunctionScalarFieldEnum = (typeof FunctionScalarFieldEnum)[keyof typeof FunctionScalarFieldEnum]


  export const OptionRuleScalarFieldEnum: {
    id: 'id',
    optionId: 'optionId',
    type: 'type',
    value: 'value',
    operator: 'operator',
    comparisonValue: 'comparisonValue',
    functionId: 'functionId',
    questionAnswerRefId: 'questionAnswerRefId',
    ssaStatusId: 'ssaStatusId',
    isReferrerPayType: 'isReferrerPayType',
    created: 'created',
    updated: 'updated'
  };

  export type OptionRuleScalarFieldEnum = (typeof OptionRuleScalarFieldEnum)[keyof typeof OptionRuleScalarFieldEnum]


  export const OptionScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    label: 'label',
    value: 'value',
    created: 'created',
    updatedAt: 'updatedAt'
  };

  export type OptionScalarFieldEnum = (typeof OptionScalarFieldEnum)[keyof typeof OptionScalarFieldEnum]


  export const QuestionFormatRuleScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    type: 'type',
    questionAnswerRefId: 'questionAnswerRefId',
    claimantField: 'claimantField',
    created: 'created',
    updated: 'updated'
  };

  export type QuestionFormatRuleScalarFieldEnum = (typeof QuestionFormatRuleScalarFieldEnum)[keyof typeof QuestionFormatRuleScalarFieldEnum]


  export const QuestionRuleScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    optout: 'optout',
    type: 'type',
    value: 'value',
    operator: 'operator',
    comparisonValue: 'comparisonValue',
    functionId: 'functionId',
    questionAnswerRefId: 'questionAnswerRefId',
    ssaStatusId: 'ssaStatusId',
    isReferrerPayType: 'isReferrerPayType',
    created: 'created',
    updated: 'updated'
  };

  export type QuestionRuleScalarFieldEnum = (typeof QuestionRuleScalarFieldEnum)[keyof typeof QuestionRuleScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    formSectionId: 'formSectionId',
    question: 'question',
    questionType: 'questionType',
    inputType: 'inputType',
    order: 'order',
    scriptText: 'scriptText',
    optout: 'optout',
    optoutText: 'optoutText',
    created: 'created',
    updated: 'updated'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const ReferrerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    payType: 'payType',
    preIntakeTimer: 'preIntakeTimer',
    created: 'created',
    updated: 'updated'
  };

  export type ReferrerScalarFieldEnum = (typeof ReferrerScalarFieldEnum)[keyof typeof ReferrerScalarFieldEnum]


  export const SSAStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created: 'created',
    updated: 'updated'
  };

  export type SSAStatusScalarFieldEnum = (typeof SSAStatusScalarFieldEnum)[keyof typeof SSAStatusScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SubformFieldAnswerScalarFieldEnum: {
    id: 'id',
    subformFieldId: 'subformFieldId',
    claimantId: 'claimantId',
    sessionId: 'sessionId',
    value: 'value',
    optionId: 'optionId',
    created: 'created',
    updated: 'updated'
  };

  export type SubformFieldAnswerScalarFieldEnum = (typeof SubformFieldAnswerScalarFieldEnum)[keyof typeof SubformFieldAnswerScalarFieldEnum]


  export const SubformFieldOptionScalarFieldEnum: {
    id: 'id',
    subformFieldId: 'subformFieldId',
    label: 'label',
    value: 'value',
    created: 'created',
    updated: 'updated'
  };

  export type SubformFieldOptionScalarFieldEnum = (typeof SubformFieldOptionScalarFieldEnum)[keyof typeof SubformFieldOptionScalarFieldEnum]


  export const SubformFieldScalarFieldEnum: {
    id: 'id',
    subformId: 'subformId',
    fieldType: 'fieldType',
    inputType: 'inputType',
    max: 'max',
    name: 'name',
    label: 'label',
    required: 'required',
    created: 'created',
    updated: 'updated'
  };

  export type SubformFieldScalarFieldEnum = (typeof SubformFieldScalarFieldEnum)[keyof typeof SubformFieldScalarFieldEnum]


  export const SubformScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    name: 'name',
    created: 'created',
    updated: 'updated'
  };

  export type SubformScalarFieldEnum = (typeof SubformScalarFieldEnum)[keyof typeof SubformScalarFieldEnum]


  export const TouchPointScalarFieldEnum: {
    id: 'id',
    claimantId: 'claimantId',
    type: 'type',
    created: 'created',
    updated: 'updated'
  };

  export type TouchPointScalarFieldEnum = (typeof TouchPointScalarFieldEnum)[keyof typeof TouchPointScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    auth0Id: 'auth0Id',
    email: 'email',
    phone: 'phone',
    firstName: 'firstName',
    lastName: 'lastName',
    active: 'active',
    lastActive: 'lastActive',
    created: 'created',
    updated: 'updated'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VoiceMailScalarFieldEnum: {
    id: 'id',
    claimantId: 'claimantId',
    created: 'created',
    updated: 'updated',
    recordingUrl: 'recordingUrl',
    transcription: 'transcription'
  };

  export type VoiceMailScalarFieldEnum = (typeof VoiceMailScalarFieldEnum)[keyof typeof VoiceMailScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    auth0Id?: StringFilter | string
    email?: StringFilter | string
    phone?: StringNullableFilter | string | null
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    active?: BoolFilter | boolean
    lastActive?: DateTimeFilter | Date | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    callSessions?: CallSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    active?: SortOrder
    lastActive?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    callSessions?: CallSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    active?: SortOrder
    lastActive?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    auth0Id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phone?: StringNullableWithAggregatesFilter | string | null
    firstName?: StringNullableWithAggregatesFilter | string | null
    lastName?: StringNullableWithAggregatesFilter | string | null
    active?: BoolWithAggregatesFilter | boolean
    lastActive?: DateTimeWithAggregatesFilter | Date | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ClaimantWhereInput = {
    AND?: Enumerable<ClaimantWhereInput>
    OR?: Enumerable<ClaimantWhereInput>
    NOT?: Enumerable<ClaimantWhereInput>
    id?: IntFilter | number
    firstName?: StringNullableFilter | string | null
    middleName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    referrerId?: IntNullableFilter | number | null
    ssaStatusId?: IntNullableFilter | number | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    cursor?: CursorListRelationFilter
    answers?: AnswerListRelationFilter
    touchPoint?: TouchPointListRelationFilter
    callSessions?: CallSessionListRelationFilter
    subformFieldAnswer?: SubformFieldAnswerListRelationFilter
    ssaStatus?: XOR<SSAStatusRelationFilter, SSAStatusWhereInput> | null
    referrer?: XOR<ReferrerRelationFilter, ReferrerWhereInput> | null
    VoiceMail?: VoiceMailListRelationFilter
  }

  export type ClaimantOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    referrerId?: SortOrder
    ssaStatusId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    cursor?: CursorOrderByRelationAggregateInput
    answers?: AnswerOrderByRelationAggregateInput
    touchPoint?: TouchPointOrderByRelationAggregateInput
    callSessions?: CallSessionOrderByRelationAggregateInput
    subformFieldAnswer?: SubformFieldAnswerOrderByRelationAggregateInput
    ssaStatus?: SSAStatusOrderByWithRelationInput
    referrer?: ReferrerOrderByWithRelationInput
    VoiceMail?: VoiceMailOrderByRelationAggregateInput
  }

  export type ClaimantWhereUniqueInput = {
    id?: number
  }

  export type ClaimantOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    referrerId?: SortOrder
    ssaStatusId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: ClaimantCountOrderByAggregateInput
    _avg?: ClaimantAvgOrderByAggregateInput
    _max?: ClaimantMaxOrderByAggregateInput
    _min?: ClaimantMinOrderByAggregateInput
    _sum?: ClaimantSumOrderByAggregateInput
  }

  export type ClaimantScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClaimantScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClaimantScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClaimantScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    firstName?: StringNullableWithAggregatesFilter | string | null
    middleName?: StringNullableWithAggregatesFilter | string | null
    lastName?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    referrerId?: IntNullableWithAggregatesFilter | number | null
    ssaStatusId?: IntNullableWithAggregatesFilter | number | null
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CallSessionWhereInput = {
    AND?: Enumerable<CallSessionWhereInput>
    OR?: Enumerable<CallSessionWhereInput>
    NOT?: Enumerable<CallSessionWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    claimantId?: IntFilter | number
    sessionType?: EnumSessionTypesFilter | SessionTypes
    sessionStatus?: EnumSessionStatusesNullableFilter | SessionStatuses | null
    created?: DateTimeFilter | Date | string
    ended?: DateTimeNullableFilter | Date | string | null
    updated?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    claimant?: XOR<ClaimantRelationFilter, ClaimantWhereInput>
    answer?: AnswerListRelationFilter
    subformFieldAnswer?: SubformFieldAnswerListRelationFilter
    recordingUrl?: StringNullableFilter | string | null
    outgoingPhone?: StringFilter | string
  }

  export type CallSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    claimantId?: SortOrder
    sessionType?: SortOrder
    sessionStatus?: SortOrder
    created?: SortOrder
    ended?: SortOrder
    updated?: SortOrder
    user?: UserOrderByWithRelationInput
    claimant?: ClaimantOrderByWithRelationInput
    answer?: AnswerOrderByRelationAggregateInput
    subformFieldAnswer?: SubformFieldAnswerOrderByRelationAggregateInput
    recordingUrl?: SortOrder
    outgoingPhone?: SortOrder
  }

  export type CallSessionWhereUniqueInput = {
    id?: number
  }

  export type CallSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    claimantId?: SortOrder
    sessionType?: SortOrder
    sessionStatus?: SortOrder
    created?: SortOrder
    ended?: SortOrder
    updated?: SortOrder
    recordingUrl?: SortOrder
    outgoingPhone?: SortOrder
    _count?: CallSessionCountOrderByAggregateInput
    _avg?: CallSessionAvgOrderByAggregateInput
    _max?: CallSessionMaxOrderByAggregateInput
    _min?: CallSessionMinOrderByAggregateInput
    _sum?: CallSessionSumOrderByAggregateInput
  }

  export type CallSessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CallSessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<CallSessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CallSessionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    claimantId?: IntWithAggregatesFilter | number
    sessionType?: EnumSessionTypesWithAggregatesFilter | SessionTypes
    sessionStatus?: EnumSessionStatusesNullableWithAggregatesFilter | SessionStatuses | null
    created?: DateTimeWithAggregatesFilter | Date | string
    ended?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updated?: DateTimeWithAggregatesFilter | Date | string
    recordingUrl?: StringNullableWithAggregatesFilter | string | null
    outgoingPhone?: StringWithAggregatesFilter | string
  }

  export type VoiceMailWhereInput = {
    AND?: Enumerable<VoiceMailWhereInput>
    OR?: Enumerable<VoiceMailWhereInput>
    NOT?: Enumerable<VoiceMailWhereInput>
    id?: IntFilter | number
    claimantId?: IntNullableFilter | number | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    claimant?: XOR<ClaimantRelationFilter, ClaimantWhereInput> | null
    recordingUrl?: StringNullableFilter | string | null
    transcription?: StringNullableFilter | string | null
  }

  export type VoiceMailOrderByWithRelationInput = {
    id?: SortOrder
    claimantId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    claimant?: ClaimantOrderByWithRelationInput
    recordingUrl?: SortOrder
    transcription?: SortOrder
  }

  export type VoiceMailWhereUniqueInput = {
    id?: number
  }

  export type VoiceMailOrderByWithAggregationInput = {
    id?: SortOrder
    claimantId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    recordingUrl?: SortOrder
    transcription?: SortOrder
    _count?: VoiceMailCountOrderByAggregateInput
    _avg?: VoiceMailAvgOrderByAggregateInput
    _max?: VoiceMailMaxOrderByAggregateInput
    _min?: VoiceMailMinOrderByAggregateInput
    _sum?: VoiceMailSumOrderByAggregateInput
  }

  export type VoiceMailScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VoiceMailScalarWhereWithAggregatesInput>
    OR?: Enumerable<VoiceMailScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VoiceMailScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    claimantId?: IntNullableWithAggregatesFilter | number | null
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    recordingUrl?: StringNullableWithAggregatesFilter | string | null
    transcription?: StringNullableWithAggregatesFilter | string | null
  }

  export type FormWhereInput = {
    AND?: Enumerable<FormWhereInput>
    OR?: Enumerable<FormWhereInput>
    NOT?: Enumerable<FormWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    formSection?: FormSectionListRelationFilter
  }

  export type FormOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    formSection?: FormSectionOrderByRelationAggregateInput
  }

  export type FormWhereUniqueInput = {
    id?: number
  }

  export type FormOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: FormCountOrderByAggregateInput
    _avg?: FormAvgOrderByAggregateInput
    _max?: FormMaxOrderByAggregateInput
    _min?: FormMinOrderByAggregateInput
    _sum?: FormSumOrderByAggregateInput
  }

  export type FormScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FormScalarWhereWithAggregatesInput>
    OR?: Enumerable<FormScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FormScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FormSectionWhereInput = {
    AND?: Enumerable<FormSectionWhereInput>
    OR?: Enumerable<FormSectionWhereInput>
    NOT?: Enumerable<FormSectionWhereInput>
    id?: IntFilter | number
    formId?: IntFilter | number
    name?: StringFilter | string
    order?: IntFilter | number
    showTimer?: BoolFilter | boolean
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    questions?: QuestionListRelationFilter
    cursor?: CursorListRelationFilter
    form?: XOR<FormRelationFilter, FormWhereInput>
  }

  export type FormSectionOrderByWithRelationInput = {
    id?: SortOrder
    formId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    showTimer?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    questions?: QuestionOrderByRelationAggregateInput
    cursor?: CursorOrderByRelationAggregateInput
    form?: FormOrderByWithRelationInput
  }

  export type FormSectionWhereUniqueInput = {
    id?: number
  }

  export type FormSectionOrderByWithAggregationInput = {
    id?: SortOrder
    formId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    showTimer?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: FormSectionCountOrderByAggregateInput
    _avg?: FormSectionAvgOrderByAggregateInput
    _max?: FormSectionMaxOrderByAggregateInput
    _min?: FormSectionMinOrderByAggregateInput
    _sum?: FormSectionSumOrderByAggregateInput
  }

  export type FormSectionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FormSectionScalarWhereWithAggregatesInput>
    OR?: Enumerable<FormSectionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FormSectionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    formId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    order?: IntWithAggregatesFilter | number
    showTimer?: BoolWithAggregatesFilter | boolean
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionWhereInput = {
    AND?: Enumerable<QuestionWhereInput>
    OR?: Enumerable<QuestionWhereInput>
    NOT?: Enumerable<QuestionWhereInput>
    id?: IntFilter | number
    formSectionId?: IntFilter | number
    question?: StringFilter | string
    questionType?: EnumQuestionTypeFilter | QuestionType
    inputType?: EnumInputTypeNullableFilter | InputType | null
    order?: IntFilter | number
    scriptText?: StringFilter | string
    optout?: BoolFilter | boolean
    optoutText?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    answers?: AnswerListRelationFilter
    options?: OptionListRelationFilter
    subform?: XOR<SubformRelationFilter, SubformWhereInput> | null
    formSection?: XOR<FormSectionRelationFilter, FormSectionWhereInput>
    optionRule?: OptionRuleListRelationFilter
    rules?: QuestionRuleListRelationFilter
    questionAnswerRef?: QuestionRuleListRelationFilter
    questionFormatRule?: QuestionFormatRuleListRelationFilter
    questionFormatAnswerRef?: QuestionFormatRuleListRelationFilter
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    formSectionId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    inputType?: SortOrder
    order?: SortOrder
    scriptText?: SortOrder
    optout?: SortOrder
    optoutText?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    answers?: AnswerOrderByRelationAggregateInput
    options?: OptionOrderByRelationAggregateInput
    subform?: SubformOrderByWithRelationInput
    formSection?: FormSectionOrderByWithRelationInput
    optionRule?: OptionRuleOrderByRelationAggregateInput
    rules?: QuestionRuleOrderByRelationAggregateInput
    questionAnswerRef?: QuestionRuleOrderByRelationAggregateInput
    questionFormatRule?: QuestionFormatRuleOrderByRelationAggregateInput
    questionFormatAnswerRef?: QuestionFormatRuleOrderByRelationAggregateInput
  }

  export type QuestionWhereUniqueInput = {
    id?: number
  }

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    formSectionId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    inputType?: SortOrder
    order?: SortOrder
    scriptText?: SortOrder
    optout?: SortOrder
    optoutText?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _avg?: QuestionAvgOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
    _sum?: QuestionSumOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    formSectionId?: IntWithAggregatesFilter | number
    question?: StringWithAggregatesFilter | string
    questionType?: EnumQuestionTypeWithAggregatesFilter | QuestionType
    inputType?: EnumInputTypeNullableWithAggregatesFilter | InputType | null
    order?: IntWithAggregatesFilter | number
    scriptText?: StringWithAggregatesFilter | string
    optout?: BoolWithAggregatesFilter | boolean
    optoutText?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AnswerWhereInput = {
    AND?: Enumerable<AnswerWhereInput>
    OR?: Enumerable<AnswerWhereInput>
    NOT?: Enumerable<AnswerWhereInput>
    id?: IntFilter | number
    questionId?: IntFilter | number
    claimantId?: IntFilter | number
    sessionId?: IntFilter | number
    optionId?: IntNullableFilter | number | null
    value?: StringNullableFilter | string | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    question?: XOR<QuestionRelationFilter, QuestionWhereInput>
    claimant?: XOR<ClaimantRelationFilter, ClaimantWhereInput>
    option?: XOR<OptionRelationFilter, OptionWhereInput> | null
    callSession?: XOR<CallSessionRelationFilter, CallSessionWhereInput>
  }

  export type AnswerOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    claimantId?: SortOrder
    sessionId?: SortOrder
    optionId?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    question?: QuestionOrderByWithRelationInput
    claimant?: ClaimantOrderByWithRelationInput
    option?: OptionOrderByWithRelationInput
    callSession?: CallSessionOrderByWithRelationInput
  }

  export type AnswerWhereUniqueInput = {
    id?: number
    questionId_sessionId_claimantId?: AnswerQuestionIdSessionIdClaimantIdCompoundUniqueInput
  }

  export type AnswerOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    claimantId?: SortOrder
    sessionId?: SortOrder
    optionId?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: AnswerCountOrderByAggregateInput
    _avg?: AnswerAvgOrderByAggregateInput
    _max?: AnswerMaxOrderByAggregateInput
    _min?: AnswerMinOrderByAggregateInput
    _sum?: AnswerSumOrderByAggregateInput
  }

  export type AnswerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AnswerScalarWhereWithAggregatesInput>
    OR?: Enumerable<AnswerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AnswerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    questionId?: IntWithAggregatesFilter | number
    claimantId?: IntWithAggregatesFilter | number
    sessionId?: IntWithAggregatesFilter | number
    optionId?: IntNullableWithAggregatesFilter | number | null
    value?: StringNullableWithAggregatesFilter | string | null
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubformWhereInput = {
    AND?: Enumerable<SubformWhereInput>
    OR?: Enumerable<SubformWhereInput>
    NOT?: Enumerable<SubformWhereInput>
    id?: IntFilter | number
    questionId?: IntFilter | number
    name?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    subformFields?: SubformFieldListRelationFilter
    question?: XOR<QuestionRelationFilter, QuestionWhereInput>
  }

  export type SubformOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    subformFields?: SubformFieldOrderByRelationAggregateInput
    question?: QuestionOrderByWithRelationInput
  }

  export type SubformWhereUniqueInput = {
    id?: number
    questionId?: number
  }

  export type SubformOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: SubformCountOrderByAggregateInput
    _avg?: SubformAvgOrderByAggregateInput
    _max?: SubformMaxOrderByAggregateInput
    _min?: SubformMinOrderByAggregateInput
    _sum?: SubformSumOrderByAggregateInput
  }

  export type SubformScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubformScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubformScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubformScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    questionId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubformFieldWhereInput = {
    AND?: Enumerable<SubformFieldWhereInput>
    OR?: Enumerable<SubformFieldWhereInput>
    NOT?: Enumerable<SubformFieldWhereInput>
    id?: IntFilter | number
    subformId?: IntFilter | number
    fieldType?: EnumSubFormFieldTypeFilter | SubFormFieldType
    inputType?: EnumInputTypeNullableFilter | InputType | null
    max?: IntNullableFilter | number | null
    name?: StringFilter | string
    label?: StringFilter | string
    required?: BoolFilter | boolean
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    subformFieldOptions?: SubformFieldOptionListRelationFilter
    subformFieldAnswer?: SubformFieldAnswerListRelationFilter
    subForm?: XOR<SubformRelationFilter, SubformWhereInput>
  }

  export type SubformFieldOrderByWithRelationInput = {
    id?: SortOrder
    subformId?: SortOrder
    fieldType?: SortOrder
    inputType?: SortOrder
    max?: SortOrder
    name?: SortOrder
    label?: SortOrder
    required?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    subformFieldOptions?: SubformFieldOptionOrderByRelationAggregateInput
    subformFieldAnswer?: SubformFieldAnswerOrderByRelationAggregateInput
    subForm?: SubformOrderByWithRelationInput
  }

  export type SubformFieldWhereUniqueInput = {
    id?: number
  }

  export type SubformFieldOrderByWithAggregationInput = {
    id?: SortOrder
    subformId?: SortOrder
    fieldType?: SortOrder
    inputType?: SortOrder
    max?: SortOrder
    name?: SortOrder
    label?: SortOrder
    required?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: SubformFieldCountOrderByAggregateInput
    _avg?: SubformFieldAvgOrderByAggregateInput
    _max?: SubformFieldMaxOrderByAggregateInput
    _min?: SubformFieldMinOrderByAggregateInput
    _sum?: SubformFieldSumOrderByAggregateInput
  }

  export type SubformFieldScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubformFieldScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubformFieldScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubformFieldScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    subformId?: IntWithAggregatesFilter | number
    fieldType?: EnumSubFormFieldTypeWithAggregatesFilter | SubFormFieldType
    inputType?: EnumInputTypeNullableWithAggregatesFilter | InputType | null
    max?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    label?: StringWithAggregatesFilter | string
    required?: BoolWithAggregatesFilter | boolean
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubformFieldOptionWhereInput = {
    AND?: Enumerable<SubformFieldOptionWhereInput>
    OR?: Enumerable<SubformFieldOptionWhereInput>
    NOT?: Enumerable<SubformFieldOptionWhereInput>
    id?: IntFilter | number
    subformFieldId?: IntFilter | number
    label?: StringFilter | string
    value?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    subformFieldAnswer?: SubformFieldAnswerListRelationFilter
    subformField?: XOR<SubformFieldRelationFilter, SubformFieldWhereInput>
  }

  export type SubformFieldOptionOrderByWithRelationInput = {
    id?: SortOrder
    subformFieldId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    subformFieldAnswer?: SubformFieldAnswerOrderByRelationAggregateInput
    subformField?: SubformFieldOrderByWithRelationInput
  }

  export type SubformFieldOptionWhereUniqueInput = {
    id?: number
  }

  export type SubformFieldOptionOrderByWithAggregationInput = {
    id?: SortOrder
    subformFieldId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: SubformFieldOptionCountOrderByAggregateInput
    _avg?: SubformFieldOptionAvgOrderByAggregateInput
    _max?: SubformFieldOptionMaxOrderByAggregateInput
    _min?: SubformFieldOptionMinOrderByAggregateInput
    _sum?: SubformFieldOptionSumOrderByAggregateInput
  }

  export type SubformFieldOptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubformFieldOptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubformFieldOptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubformFieldOptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    subformFieldId?: IntWithAggregatesFilter | number
    label?: StringWithAggregatesFilter | string
    value?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubformFieldAnswerWhereInput = {
    AND?: Enumerable<SubformFieldAnswerWhereInput>
    OR?: Enumerable<SubformFieldAnswerWhereInput>
    NOT?: Enumerable<SubformFieldAnswerWhereInput>
    id?: IntFilter | number
    subformFieldId?: IntFilter | number
    claimantId?: IntFilter | number
    sessionId?: IntFilter | number
    value?: StringNullableFilter | string | null
    optionId?: IntNullableFilter | number | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    subformField?: XOR<SubformFieldRelationFilter, SubformFieldWhereInput>
    subformFieldOpion?: XOR<SubformFieldOptionRelationFilter, SubformFieldOptionWhereInput> | null
    claimant?: XOR<ClaimantRelationFilter, ClaimantWhereInput>
    session?: XOR<CallSessionRelationFilter, CallSessionWhereInput>
  }

  export type SubformFieldAnswerOrderByWithRelationInput = {
    id?: SortOrder
    subformFieldId?: SortOrder
    claimantId?: SortOrder
    sessionId?: SortOrder
    value?: SortOrder
    optionId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    subformField?: SubformFieldOrderByWithRelationInput
    subformFieldOpion?: SubformFieldOptionOrderByWithRelationInput
    claimant?: ClaimantOrderByWithRelationInput
    session?: CallSessionOrderByWithRelationInput
  }

  export type SubformFieldAnswerWhereUniqueInput = {
    id?: number
  }

  export type SubformFieldAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    subformFieldId?: SortOrder
    claimantId?: SortOrder
    sessionId?: SortOrder
    value?: SortOrder
    optionId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: SubformFieldAnswerCountOrderByAggregateInput
    _avg?: SubformFieldAnswerAvgOrderByAggregateInput
    _max?: SubformFieldAnswerMaxOrderByAggregateInput
    _min?: SubformFieldAnswerMinOrderByAggregateInput
    _sum?: SubformFieldAnswerSumOrderByAggregateInput
  }

  export type SubformFieldAnswerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubformFieldAnswerScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubformFieldAnswerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubformFieldAnswerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    subformFieldId?: IntWithAggregatesFilter | number
    claimantId?: IntWithAggregatesFilter | number
    sessionId?: IntWithAggregatesFilter | number
    value?: StringNullableWithAggregatesFilter | string | null
    optionId?: IntNullableWithAggregatesFilter | number | null
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CursorWhereInput = {
    AND?: Enumerable<CursorWhereInput>
    OR?: Enumerable<CursorWhereInput>
    NOT?: Enumerable<CursorWhereInput>
    id?: IntFilter | number
    formSectionId?: IntFilter | number
    questionId?: IntFilter | number
    claimantId?: IntFilter | number
    created?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    claimant?: XOR<ClaimantRelationFilter, ClaimantWhereInput>
    formSection?: XOR<FormSectionRelationFilter, FormSectionWhereInput>
  }

  export type CursorOrderByWithRelationInput = {
    id?: SortOrder
    formSectionId?: SortOrder
    questionId?: SortOrder
    claimantId?: SortOrder
    created?: SortOrder
    updatedAt?: SortOrder
    claimant?: ClaimantOrderByWithRelationInput
    formSection?: FormSectionOrderByWithRelationInput
  }

  export type CursorWhereUniqueInput = {
    id?: number
  }

  export type CursorOrderByWithAggregationInput = {
    id?: SortOrder
    formSectionId?: SortOrder
    questionId?: SortOrder
    claimantId?: SortOrder
    created?: SortOrder
    updatedAt?: SortOrder
    _count?: CursorCountOrderByAggregateInput
    _avg?: CursorAvgOrderByAggregateInput
    _max?: CursorMaxOrderByAggregateInput
    _min?: CursorMinOrderByAggregateInput
    _sum?: CursorSumOrderByAggregateInput
  }

  export type CursorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CursorScalarWhereWithAggregatesInput>
    OR?: Enumerable<CursorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CursorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    formSectionId?: IntWithAggregatesFilter | number
    questionId?: IntWithAggregatesFilter | number
    claimantId?: IntWithAggregatesFilter | number
    created?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OptionWhereInput = {
    AND?: Enumerable<OptionWhereInput>
    OR?: Enumerable<OptionWhereInput>
    NOT?: Enumerable<OptionWhereInput>
    id?: IntFilter | number
    questionId?: IntFilter | number
    label?: StringFilter | string
    value?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    rules?: OptionRuleListRelationFilter
    answer?: AnswerListRelationFilter
    question?: XOR<QuestionRelationFilter, QuestionWhereInput>
  }

  export type OptionOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updatedAt?: SortOrder
    rules?: OptionRuleOrderByRelationAggregateInput
    answer?: AnswerOrderByRelationAggregateInput
    question?: QuestionOrderByWithRelationInput
  }

  export type OptionWhereUniqueInput = {
    id?: number
  }

  export type OptionOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updatedAt?: SortOrder
    _count?: OptionCountOrderByAggregateInput
    _avg?: OptionAvgOrderByAggregateInput
    _max?: OptionMaxOrderByAggregateInput
    _min?: OptionMinOrderByAggregateInput
    _sum?: OptionSumOrderByAggregateInput
  }

  export type OptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<OptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    questionId?: IntWithAggregatesFilter | number
    label?: StringWithAggregatesFilter | string
    value?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OptionRuleWhereInput = {
    AND?: Enumerable<OptionRuleWhereInput>
    OR?: Enumerable<OptionRuleWhereInput>
    NOT?: Enumerable<OptionRuleWhereInput>
    id?: IntFilter | number
    optionId?: IntNullableFilter | number | null
    type?: EnumRuleTypeFilter | RuleType
    value?: IntNullableFilter | number | null
    operator?: EnumOperatorOptionNullableFilter | OperatorOption | null
    comparisonValue?: StringNullableFilter | string | null
    functionId?: IntNullableFilter | number | null
    questionAnswerRefId?: IntNullableFilter | number | null
    ssaStatusId?: IntNullableFilter | number | null
    isReferrerPayType?: EnumReferrerPayTypesNullableFilter | ReferrerPayTypes | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    option?: XOR<OptionRelationFilter, OptionWhereInput> | null
    questionAnswerRef?: XOR<QuestionRelationFilter, QuestionWhereInput> | null
    function?: XOR<FunctionRelationFilter, FunctionWhereInput> | null
    ssaStatus?: XOR<SSAStatusRelationFilter, SSAStatusWhereInput> | null
  }

  export type OptionRuleOrderByWithRelationInput = {
    id?: SortOrder
    optionId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    functionId?: SortOrder
    questionAnswerRefId?: SortOrder
    ssaStatusId?: SortOrder
    isReferrerPayType?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    option?: OptionOrderByWithRelationInput
    questionAnswerRef?: QuestionOrderByWithRelationInput
    function?: FunctionOrderByWithRelationInput
    ssaStatus?: SSAStatusOrderByWithRelationInput
  }

  export type OptionRuleWhereUniqueInput = {
    id?: number
  }

  export type OptionRuleOrderByWithAggregationInput = {
    id?: SortOrder
    optionId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    functionId?: SortOrder
    questionAnswerRefId?: SortOrder
    ssaStatusId?: SortOrder
    isReferrerPayType?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: OptionRuleCountOrderByAggregateInput
    _avg?: OptionRuleAvgOrderByAggregateInput
    _max?: OptionRuleMaxOrderByAggregateInput
    _min?: OptionRuleMinOrderByAggregateInput
    _sum?: OptionRuleSumOrderByAggregateInput
  }

  export type OptionRuleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OptionRuleScalarWhereWithAggregatesInput>
    OR?: Enumerable<OptionRuleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OptionRuleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    optionId?: IntNullableWithAggregatesFilter | number | null
    type?: EnumRuleTypeWithAggregatesFilter | RuleType
    value?: IntNullableWithAggregatesFilter | number | null
    operator?: EnumOperatorOptionNullableWithAggregatesFilter | OperatorOption | null
    comparisonValue?: StringNullableWithAggregatesFilter | string | null
    functionId?: IntNullableWithAggregatesFilter | number | null
    questionAnswerRefId?: IntNullableWithAggregatesFilter | number | null
    ssaStatusId?: IntNullableWithAggregatesFilter | number | null
    isReferrerPayType?: EnumReferrerPayTypesNullableWithAggregatesFilter | ReferrerPayTypes | null
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionRuleWhereInput = {
    AND?: Enumerable<QuestionRuleWhereInput>
    OR?: Enumerable<QuestionRuleWhereInput>
    NOT?: Enumerable<QuestionRuleWhereInput>
    id?: IntFilter | number
    questionId?: IntNullableFilter | number | null
    optout?: BoolNullableFilter | boolean | null
    type?: EnumRuleTypeFilter | RuleType
    value?: IntNullableFilter | number | null
    operator?: EnumOperatorOptionNullableFilter | OperatorOption | null
    comparisonValue?: StringNullableFilter | string | null
    functionId?: IntNullableFilter | number | null
    questionAnswerRefId?: IntNullableFilter | number | null
    ssaStatusId?: IntNullableFilter | number | null
    isReferrerPayType?: EnumReferrerPayTypesNullableFilter | ReferrerPayTypes | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    question?: XOR<QuestionRelationFilter, QuestionWhereInput> | null
    questionAnswerRef?: XOR<QuestionRelationFilter, QuestionWhereInput> | null
    function?: XOR<FunctionRelationFilter, FunctionWhereInput> | null
    ssaStatus?: XOR<SSAStatusRelationFilter, SSAStatusWhereInput> | null
  }

  export type QuestionRuleOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    optout?: SortOrder
    type?: SortOrder
    value?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    functionId?: SortOrder
    questionAnswerRefId?: SortOrder
    ssaStatusId?: SortOrder
    isReferrerPayType?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    question?: QuestionOrderByWithRelationInput
    questionAnswerRef?: QuestionOrderByWithRelationInput
    function?: FunctionOrderByWithRelationInput
    ssaStatus?: SSAStatusOrderByWithRelationInput
  }

  export type QuestionRuleWhereUniqueInput = {
    id?: number
  }

  export type QuestionRuleOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    optout?: SortOrder
    type?: SortOrder
    value?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    functionId?: SortOrder
    questionAnswerRefId?: SortOrder
    ssaStatusId?: SortOrder
    isReferrerPayType?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: QuestionRuleCountOrderByAggregateInput
    _avg?: QuestionRuleAvgOrderByAggregateInput
    _max?: QuestionRuleMaxOrderByAggregateInput
    _min?: QuestionRuleMinOrderByAggregateInput
    _sum?: QuestionRuleSumOrderByAggregateInput
  }

  export type QuestionRuleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionRuleScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionRuleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionRuleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    questionId?: IntNullableWithAggregatesFilter | number | null
    optout?: BoolNullableWithAggregatesFilter | boolean | null
    type?: EnumRuleTypeWithAggregatesFilter | RuleType
    value?: IntNullableWithAggregatesFilter | number | null
    operator?: EnumOperatorOptionNullableWithAggregatesFilter | OperatorOption | null
    comparisonValue?: StringNullableWithAggregatesFilter | string | null
    functionId?: IntNullableWithAggregatesFilter | number | null
    questionAnswerRefId?: IntNullableWithAggregatesFilter | number | null
    ssaStatusId?: IntNullableWithAggregatesFilter | number | null
    isReferrerPayType?: EnumReferrerPayTypesNullableWithAggregatesFilter | ReferrerPayTypes | null
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type QuestionFormatRuleWhereInput = {
    AND?: Enumerable<QuestionFormatRuleWhereInput>
    OR?: Enumerable<QuestionFormatRuleWhereInput>
    NOT?: Enumerable<QuestionFormatRuleWhereInput>
    id?: IntFilter | number
    questionId?: IntNullableFilter | number | null
    type?: EnumQuestionFormatTypesFilter | QuestionFormatTypes
    questionAnswerRefId?: IntNullableFilter | number | null
    claimantField?: EnumClaimantFieldRefTypesNullableFilter | ClaimantFieldRefTypes | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    question?: XOR<QuestionRelationFilter, QuestionWhereInput> | null
    questionAnswerRef?: XOR<QuestionRelationFilter, QuestionWhereInput> | null
  }

  export type QuestionFormatRuleOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    type?: SortOrder
    questionAnswerRefId?: SortOrder
    claimantField?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    question?: QuestionOrderByWithRelationInput
    questionAnswerRef?: QuestionOrderByWithRelationInput
  }

  export type QuestionFormatRuleWhereUniqueInput = {
    id?: number
  }

  export type QuestionFormatRuleOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    type?: SortOrder
    questionAnswerRefId?: SortOrder
    claimantField?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: QuestionFormatRuleCountOrderByAggregateInput
    _avg?: QuestionFormatRuleAvgOrderByAggregateInput
    _max?: QuestionFormatRuleMaxOrderByAggregateInput
    _min?: QuestionFormatRuleMinOrderByAggregateInput
    _sum?: QuestionFormatRuleSumOrderByAggregateInput
  }

  export type QuestionFormatRuleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuestionFormatRuleScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuestionFormatRuleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuestionFormatRuleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    questionId?: IntNullableWithAggregatesFilter | number | null
    type?: EnumQuestionFormatTypesWithAggregatesFilter | QuestionFormatTypes
    questionAnswerRefId?: IntNullableWithAggregatesFilter | number | null
    claimantField?: EnumClaimantFieldRefTypesNullableWithAggregatesFilter | ClaimantFieldRefTypes | null
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FunctionWhereInput = {
    AND?: Enumerable<FunctionWhereInput>
    OR?: Enumerable<FunctionWhereInput>
    NOT?: Enumerable<FunctionWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    function?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    QuestionRule?: QuestionRuleListRelationFilter
    OptionRule?: OptionRuleListRelationFilter
  }

  export type FunctionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    function?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    QuestionRule?: QuestionRuleOrderByRelationAggregateInput
    OptionRule?: OptionRuleOrderByRelationAggregateInput
  }

  export type FunctionWhereUniqueInput = {
    id?: number
  }

  export type FunctionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    function?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: FunctionCountOrderByAggregateInput
    _avg?: FunctionAvgOrderByAggregateInput
    _max?: FunctionMaxOrderByAggregateInput
    _min?: FunctionMinOrderByAggregateInput
    _sum?: FunctionSumOrderByAggregateInput
  }

  export type FunctionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FunctionScalarWhereWithAggregatesInput>
    OR?: Enumerable<FunctionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FunctionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    function?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TouchPointWhereInput = {
    AND?: Enumerable<TouchPointWhereInput>
    OR?: Enumerable<TouchPointWhereInput>
    NOT?: Enumerable<TouchPointWhereInput>
    id?: IntFilter | number
    claimantId?: IntFilter | number
    type?: EnumTouchPointTypeFilter | TouchPointType
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    claimant?: XOR<ClaimantRelationFilter, ClaimantWhereInput>
  }

  export type TouchPointOrderByWithRelationInput = {
    id?: SortOrder
    claimantId?: SortOrder
    type?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    claimant?: ClaimantOrderByWithRelationInput
  }

  export type TouchPointWhereUniqueInput = {
    id?: number
  }

  export type TouchPointOrderByWithAggregationInput = {
    id?: SortOrder
    claimantId?: SortOrder
    type?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: TouchPointCountOrderByAggregateInput
    _avg?: TouchPointAvgOrderByAggregateInput
    _max?: TouchPointMaxOrderByAggregateInput
    _min?: TouchPointMinOrderByAggregateInput
    _sum?: TouchPointSumOrderByAggregateInput
  }

  export type TouchPointScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TouchPointScalarWhereWithAggregatesInput>
    OR?: Enumerable<TouchPointScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TouchPointScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    claimantId?: IntWithAggregatesFilter | number
    type?: EnumTouchPointTypeWithAggregatesFilter | TouchPointType
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ReferrerWhereInput = {
    AND?: Enumerable<ReferrerWhereInput>
    OR?: Enumerable<ReferrerWhereInput>
    NOT?: Enumerable<ReferrerWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    type?: EnumReferrerTypesFilter | ReferrerTypes
    payType?: EnumReferrerPayTypesFilter | ReferrerPayTypes
    preIntakeTimer?: IntFilter | number
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    Claimant?: ClaimantListRelationFilter
  }

  export type ReferrerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    payType?: SortOrder
    preIntakeTimer?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    Claimant?: ClaimantOrderByRelationAggregateInput
  }

  export type ReferrerWhereUniqueInput = {
    id?: number
  }

  export type ReferrerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    payType?: SortOrder
    preIntakeTimer?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: ReferrerCountOrderByAggregateInput
    _avg?: ReferrerAvgOrderByAggregateInput
    _max?: ReferrerMaxOrderByAggregateInput
    _min?: ReferrerMinOrderByAggregateInput
    _sum?: ReferrerSumOrderByAggregateInput
  }

  export type ReferrerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReferrerScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReferrerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReferrerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    type?: EnumReferrerTypesWithAggregatesFilter | ReferrerTypes
    payType?: EnumReferrerPayTypesWithAggregatesFilter | ReferrerPayTypes
    preIntakeTimer?: IntWithAggregatesFilter | number
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SSAStatusWhereInput = {
    AND?: Enumerable<SSAStatusWhereInput>
    OR?: Enumerable<SSAStatusWhereInput>
    NOT?: Enumerable<SSAStatusWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    claimant?: ClaimantListRelationFilter
    OptionRule?: OptionRuleListRelationFilter
    QuestionRule?: QuestionRuleListRelationFilter
  }

  export type SSAStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    claimant?: ClaimantOrderByRelationAggregateInput
    OptionRule?: OptionRuleOrderByRelationAggregateInput
    QuestionRule?: QuestionRuleOrderByRelationAggregateInput
  }

  export type SSAStatusWhereUniqueInput = {
    id?: number
  }

  export type SSAStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: SSAStatusCountOrderByAggregateInput
    _avg?: SSAStatusAvgOrderByAggregateInput
    _max?: SSAStatusMaxOrderByAggregateInput
    _min?: SSAStatusMinOrderByAggregateInput
    _sum?: SSAStatusSumOrderByAggregateInput
  }

  export type SSAStatusScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SSAStatusScalarWhereWithAggregatesInput>
    OR?: Enumerable<SSAStatusScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SSAStatusScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserCreateInput = {
    auth0Id?: string
    email?: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    active?: boolean
    lastActive?: Date | string
    created?: Date | string
    updated?: Date | string
    callSessions?: CallSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    auth0Id?: string
    email?: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    active?: boolean
    lastActive?: Date | string
    created?: Date | string
    updated?: Date | string
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    callSessions?: CallSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    callSessions?: CallSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    auth0Id?: string
    email?: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    active?: boolean
    lastActive?: Date | string
    created?: Date | string
    updated?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimantCreateInput = {
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorCreateNestedManyWithoutClaimantInput
    answers?: AnswerCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutClaimantInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutClaimantInput
    referrer?: ReferrerCreateNestedOneWithoutClaimantInput
    VoiceMail?: VoiceMailCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantUncheckedCreateInput = {
    id?: number
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    referrerId?: number | null
    ssaStatusId?: number | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorUncheckedCreateNestedManyWithoutClaimantInput
    answers?: AnswerUncheckedCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointUncheckedCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutClaimantInput
    VoiceMail?: VoiceMailUncheckedCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantUpdateInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUpdateManyWithoutClaimantNestedInput
    answers?: AnswerUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutClaimantNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutClaimantNestedInput
    referrer?: ReferrerUpdateOneWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUpdateManyWithoutClaimantNestedInput
  }

  export type ClaimantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUncheckedUpdateManyWithoutClaimantNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUncheckedUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUncheckedUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUncheckedUpdateManyWithoutClaimantNestedInput
  }

  export type ClaimantCreateManyInput = {
    id?: number
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    referrerId?: number | null
    ssaStatusId?: number | null
    created?: Date | string
    updated?: Date | string
  }

  export type ClaimantUpdateManyMutationInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSessionCreateInput = {
    sessionType: SessionTypes
    sessionStatus?: SessionStatuses | null
    created?: Date | string
    ended?: Date | string | null
    updated?: Date | string
    user: UserCreateNestedOneWithoutCallSessionsInput
    claimant: ClaimantCreateNestedOneWithoutCallSessionsInput
    answer?: AnswerCreateNestedManyWithoutCallSessionInput
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutSessionInput
    recordingUrl?: string | null
    outgoingPhone: string
  }

  export type CallSessionUncheckedCreateInput = {
    id?: number
    userId: number
    claimantId: number
    sessionType: SessionTypes
    sessionStatus?: SessionStatuses | null
    created?: Date | string
    ended?: Date | string | null
    updated?: Date | string
    answer?: AnswerUncheckedCreateNestedManyWithoutCallSessionInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutSessionInput
    recordingUrl?: string | null
    outgoingPhone: string
  }

  export type CallSessionUpdateInput = {
    sessionType?: EnumSessionTypesFieldUpdateOperationsInput | SessionTypes
    sessionStatus?: NullableEnumSessionStatusesFieldUpdateOperationsInput | SessionStatuses | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCallSessionsNestedInput
    claimant?: ClaimantUpdateOneRequiredWithoutCallSessionsNestedInput
    answer?: AnswerUpdateManyWithoutCallSessionNestedInput
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutSessionNestedInput
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    outgoingPhone?: StringFieldUpdateOperationsInput | string
  }

  export type CallSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    sessionType?: EnumSessionTypesFieldUpdateOperationsInput | SessionTypes
    sessionStatus?: NullableEnumSessionStatusesFieldUpdateOperationsInput | SessionStatuses | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: AnswerUncheckedUpdateManyWithoutCallSessionNestedInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutSessionNestedInput
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    outgoingPhone?: StringFieldUpdateOperationsInput | string
  }

  export type CallSessionCreateManyInput = {
    id?: number
    userId: number
    claimantId: number
    sessionType: SessionTypes
    sessionStatus?: SessionStatuses | null
    created?: Date | string
    ended?: Date | string | null
    updated?: Date | string
    recordingUrl?: string | null
    outgoingPhone: string
  }

  export type CallSessionUpdateManyMutationInput = {
    sessionType?: EnumSessionTypesFieldUpdateOperationsInput | SessionTypes
    sessionStatus?: NullableEnumSessionStatusesFieldUpdateOperationsInput | SessionStatuses | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    outgoingPhone?: StringFieldUpdateOperationsInput | string
  }

  export type CallSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    sessionType?: EnumSessionTypesFieldUpdateOperationsInput | SessionTypes
    sessionStatus?: NullableEnumSessionStatusesFieldUpdateOperationsInput | SessionStatuses | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    outgoingPhone?: StringFieldUpdateOperationsInput | string
  }

  export type VoiceMailCreateInput = {
    created?: Date | string
    updated?: Date | string
    claimant?: ClaimantCreateNestedOneWithoutVoiceMailInput
    recordingUrl?: string | null
    transcription?: string | null
  }

  export type VoiceMailUncheckedCreateInput = {
    id?: number
    claimantId?: number | null
    created?: Date | string
    updated?: Date | string
    recordingUrl?: string | null
    transcription?: string | null
  }

  export type VoiceMailUpdateInput = {
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    claimant?: ClaimantUpdateOneWithoutVoiceMailNestedInput
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoiceMailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimantId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoiceMailCreateManyInput = {
    id?: number
    claimantId?: number | null
    created?: Date | string
    updated?: Date | string
    recordingUrl?: string | null
    transcription?: string | null
  }

  export type VoiceMailUpdateManyMutationInput = {
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoiceMailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimantId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FormCreateInput = {
    name: string
    description?: string | null
    created?: Date | string
    updated?: Date | string
    formSection?: FormSectionCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    created?: Date | string
    updated?: Date | string
    formSection?: FormSectionUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    formSection?: FormSectionUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    formSection?: FormSectionUncheckedUpdateManyWithoutFormNestedInput
  }

  export type FormCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type FormUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSectionCreateInput = {
    name: string
    order?: number
    showTimer?: boolean
    created?: Date | string
    updated?: Date | string
    questions?: QuestionCreateNestedManyWithoutFormSectionInput
    cursor?: CursorCreateNestedManyWithoutFormSectionInput
    form: FormCreateNestedOneWithoutFormSectionInput
  }

  export type FormSectionUncheckedCreateInput = {
    id?: number
    formId: number
    name: string
    order?: number
    showTimer?: boolean
    created?: Date | string
    updated?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutFormSectionInput
    cursor?: CursorUncheckedCreateNestedManyWithoutFormSectionInput
  }

  export type FormSectionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    showTimer?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUpdateManyWithoutFormSectionNestedInput
    cursor?: CursorUpdateManyWithoutFormSectionNestedInput
    form?: FormUpdateOneRequiredWithoutFormSectionNestedInput
  }

  export type FormSectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    showTimer?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutFormSectionNestedInput
    cursor?: CursorUncheckedUpdateManyWithoutFormSectionNestedInput
  }

  export type FormSectionCreateManyInput = {
    id?: number
    formId: number
    name: string
    order?: number
    showTimer?: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type FormSectionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    showTimer?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    showTimer?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateInput = {
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerCreateNestedManyWithoutQuestionInput
    options?: OptionCreateNestedManyWithoutQuestionInput
    subform?: SubformCreateNestedOneWithoutQuestionInput
    formSection: FormSectionCreateNestedOneWithoutQuestionsInput
    optionRule?: OptionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: number
    formSectionId: number
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
    options?: OptionUncheckedCreateNestedManyWithoutQuestionInput
    subform?: SubformUncheckedCreateNestedOneWithoutQuestionInput
    optionRule?: OptionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
    options?: OptionUpdateManyWithoutQuestionNestedInput
    subform?: SubformUpdateOneWithoutQuestionNestedInput
    formSection?: FormSectionUpdateOneRequiredWithoutQuestionsNestedInput
    optionRule?: OptionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    formSectionId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
    options?: OptionUncheckedUpdateManyWithoutQuestionNestedInput
    subform?: SubformUncheckedUpdateOneWithoutQuestionNestedInput
    optionRule?: OptionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type QuestionCreateManyInput = {
    id?: number
    formSectionId: number
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    formSectionId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerCreateInput = {
    value?: string | null
    created?: Date | string
    updated?: Date | string
    question: QuestionCreateNestedOneWithoutAnswersInput
    claimant: ClaimantCreateNestedOneWithoutAnswersInput
    option?: OptionCreateNestedOneWithoutAnswerInput
    callSession: CallSessionCreateNestedOneWithoutAnswerInput
  }

  export type AnswerUncheckedCreateInput = {
    id?: number
    questionId: number
    claimantId: number
    sessionId: number
    optionId?: number | null
    value?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type AnswerUpdateInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutAnswersNestedInput
    claimant?: ClaimantUpdateOneRequiredWithoutAnswersNestedInput
    option?: OptionUpdateOneWithoutAnswerNestedInput
    callSession?: CallSessionUpdateOneRequiredWithoutAnswerNestedInput
  }

  export type AnswerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerCreateManyInput = {
    id?: number
    questionId: number
    claimantId: number
    sessionId: number
    optionId?: number | null
    value?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type AnswerUpdateManyMutationInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformCreateInput = {
    name: string
    created?: Date | string
    updated?: Date | string
    subformFields?: SubformFieldCreateNestedManyWithoutSubFormInput
    question: QuestionCreateNestedOneWithoutSubformInput
  }

  export type SubformUncheckedCreateInput = {
    id?: number
    questionId: number
    name: string
    created?: Date | string
    updated?: Date | string
    subformFields?: SubformFieldUncheckedCreateNestedManyWithoutSubFormInput
  }

  export type SubformUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFields?: SubformFieldUpdateManyWithoutSubFormNestedInput
    question?: QuestionUpdateOneRequiredWithoutSubformNestedInput
  }

  export type SubformUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFields?: SubformFieldUncheckedUpdateManyWithoutSubFormNestedInput
  }

  export type SubformCreateManyInput = {
    id?: number
    questionId: number
    name: string
    created?: Date | string
    updated?: Date | string
  }

  export type SubformUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformFieldCreateInput = {
    fieldType: SubFormFieldType
    inputType?: InputType | null
    max?: number | null
    name: string
    label: string
    required?: boolean
    created?: Date | string
    updated?: Date | string
    subformFieldOptions?: SubformFieldOptionCreateNestedManyWithoutSubformFieldInput
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutSubformFieldInput
    subForm: SubformCreateNestedOneWithoutSubformFieldsInput
  }

  export type SubformFieldUncheckedCreateInput = {
    id?: number
    subformId: number
    fieldType: SubFormFieldType
    inputType?: InputType | null
    max?: number | null
    name: string
    label: string
    required?: boolean
    created?: Date | string
    updated?: Date | string
    subformFieldOptions?: SubformFieldOptionUncheckedCreateNestedManyWithoutSubformFieldInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutSubformFieldInput
  }

  export type SubformFieldUpdateInput = {
    fieldType?: EnumSubFormFieldTypeFieldUpdateOperationsInput | SubFormFieldType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    max?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFieldOptions?: SubformFieldOptionUpdateManyWithoutSubformFieldNestedInput
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutSubformFieldNestedInput
    subForm?: SubformUpdateOneRequiredWithoutSubformFieldsNestedInput
  }

  export type SubformFieldUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subformId?: IntFieldUpdateOperationsInput | number
    fieldType?: EnumSubFormFieldTypeFieldUpdateOperationsInput | SubFormFieldType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    max?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFieldOptions?: SubformFieldOptionUncheckedUpdateManyWithoutSubformFieldNestedInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutSubformFieldNestedInput
  }

  export type SubformFieldCreateManyInput = {
    id?: number
    subformId: number
    fieldType: SubFormFieldType
    inputType?: InputType | null
    max?: number | null
    name: string
    label: string
    required?: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type SubformFieldUpdateManyMutationInput = {
    fieldType?: EnumSubFormFieldTypeFieldUpdateOperationsInput | SubFormFieldType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    max?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformFieldUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subformId?: IntFieldUpdateOperationsInput | number
    fieldType?: EnumSubFormFieldTypeFieldUpdateOperationsInput | SubFormFieldType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    max?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformFieldOptionCreateInput = {
    label: string
    value: string
    created?: Date | string
    updated?: Date | string
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutSubformFieldOpionInput
    subformField: SubformFieldCreateNestedOneWithoutSubformFieldOptionsInput
  }

  export type SubformFieldOptionUncheckedCreateInput = {
    id?: number
    subformFieldId: number
    label: string
    value: string
    created?: Date | string
    updated?: Date | string
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutSubformFieldOpionInput
  }

  export type SubformFieldOptionUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutSubformFieldOpionNestedInput
    subformField?: SubformFieldUpdateOneRequiredWithoutSubformFieldOptionsNestedInput
  }

  export type SubformFieldOptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subformFieldId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutSubformFieldOpionNestedInput
  }

  export type SubformFieldOptionCreateManyInput = {
    id?: number
    subformFieldId: number
    label: string
    value: string
    created?: Date | string
    updated?: Date | string
  }

  export type SubformFieldOptionUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformFieldOptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subformFieldId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformFieldAnswerCreateInput = {
    value?: string | null
    created?: Date | string
    updated?: Date | string
    subformField: SubformFieldCreateNestedOneWithoutSubformFieldAnswerInput
    subformFieldOpion?: SubformFieldOptionCreateNestedOneWithoutSubformFieldAnswerInput
    claimant: ClaimantCreateNestedOneWithoutSubformFieldAnswerInput
    session: CallSessionCreateNestedOneWithoutSubformFieldAnswerInput
  }

  export type SubformFieldAnswerUncheckedCreateInput = {
    id?: number
    subformFieldId: number
    claimantId: number
    sessionId: number
    value?: string | null
    optionId?: number | null
    created?: Date | string
    updated?: Date | string
  }

  export type SubformFieldAnswerUpdateInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformField?: SubformFieldUpdateOneRequiredWithoutSubformFieldAnswerNestedInput
    subformFieldOpion?: SubformFieldOptionUpdateOneWithoutSubformFieldAnswerNestedInput
    claimant?: ClaimantUpdateOneRequiredWithoutSubformFieldAnswerNestedInput
    session?: CallSessionUpdateOneRequiredWithoutSubformFieldAnswerNestedInput
  }

  export type SubformFieldAnswerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subformFieldId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformFieldAnswerCreateManyInput = {
    id?: number
    subformFieldId: number
    claimantId: number
    sessionId: number
    value?: string | null
    optionId?: number | null
    created?: Date | string
    updated?: Date | string
  }

  export type SubformFieldAnswerUpdateManyMutationInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformFieldAnswerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subformFieldId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursorCreateInput = {
    questionId: number
    created?: Date | string
    updatedAt?: Date | string
    claimant: ClaimantCreateNestedOneWithoutCursorInput
    formSection: FormSectionCreateNestedOneWithoutCursorInput
  }

  export type CursorUncheckedCreateInput = {
    id?: number
    formSectionId: number
    questionId: number
    claimantId: number
    created?: Date | string
    updatedAt?: Date | string
  }

  export type CursorUpdateInput = {
    questionId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimant?: ClaimantUpdateOneRequiredWithoutCursorNestedInput
    formSection?: FormSectionUpdateOneRequiredWithoutCursorNestedInput
  }

  export type CursorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    formSectionId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursorCreateManyInput = {
    id?: number
    formSectionId: number
    questionId: number
    claimantId: number
    created?: Date | string
    updatedAt?: Date | string
  }

  export type CursorUpdateManyMutationInput = {
    questionId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    formSectionId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionCreateInput = {
    label?: string
    value: string
    created?: Date | string
    updatedAt?: Date | string
    rules?: OptionRuleCreateNestedManyWithoutOptionInput
    answer?: AnswerCreateNestedManyWithoutOptionInput
    question: QuestionCreateNestedOneWithoutOptionsInput
  }

  export type OptionUncheckedCreateInput = {
    id?: number
    questionId: number
    label?: string
    value: string
    created?: Date | string
    updatedAt?: Date | string
    rules?: OptionRuleUncheckedCreateNestedManyWithoutOptionInput
    answer?: AnswerUncheckedCreateNestedManyWithoutOptionInput
  }

  export type OptionUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: OptionRuleUpdateManyWithoutOptionNestedInput
    answer?: AnswerUpdateManyWithoutOptionNestedInput
    question?: QuestionUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type OptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: OptionRuleUncheckedUpdateManyWithoutOptionNestedInput
    answer?: AnswerUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type OptionCreateManyInput = {
    id?: number
    questionId: number
    label?: string
    value: string
    created?: Date | string
    updatedAt?: Date | string
  }

  export type OptionUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionRuleCreateInput = {
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
    option?: OptionCreateNestedOneWithoutRulesInput
    questionAnswerRef?: QuestionCreateNestedOneWithoutOptionRuleInput
    function?: FunctionCreateNestedOneWithoutOptionRuleInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutOptionRuleInput
  }

  export type OptionRuleUncheckedCreateInput = {
    id?: number
    optionId?: number | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    questionAnswerRefId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type OptionRuleUpdateInput = {
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    option?: OptionUpdateOneWithoutRulesNestedInput
    questionAnswerRef?: QuestionUpdateOneWithoutOptionRuleNestedInput
    function?: FunctionUpdateOneWithoutOptionRuleNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutOptionRuleNestedInput
  }

  export type OptionRuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionRuleCreateManyInput = {
    id?: number
    optionId?: number | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    questionAnswerRefId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type OptionRuleUpdateManyMutationInput = {
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionRuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionRuleCreateInput = {
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
    question?: QuestionCreateNestedOneWithoutRulesInput
    questionAnswerRef?: QuestionCreateNestedOneWithoutQuestionAnswerRefInput
    function?: FunctionCreateNestedOneWithoutQuestionRuleInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutQuestionRuleInput
  }

  export type QuestionRuleUncheckedCreateInput = {
    id?: number
    questionId?: number | null
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    questionAnswerRefId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionRuleUpdateInput = {
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneWithoutRulesNestedInput
    questionAnswerRef?: QuestionUpdateOneWithoutQuestionAnswerRefNestedInput
    function?: FunctionUpdateOneWithoutQuestionRuleNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutQuestionRuleNestedInput
  }

  export type QuestionRuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionRuleCreateManyInput = {
    id?: number
    questionId?: number | null
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    questionAnswerRefId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionRuleUpdateManyMutationInput = {
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionRuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionFormatRuleCreateInput = {
    type: QuestionFormatTypes
    claimantField?: ClaimantFieldRefTypes | null
    created?: Date | string
    updated?: Date | string
    question?: QuestionCreateNestedOneWithoutQuestionFormatRuleInput
    questionAnswerRef?: QuestionCreateNestedOneWithoutQuestionFormatAnswerRefInput
  }

  export type QuestionFormatRuleUncheckedCreateInput = {
    id?: number
    questionId?: number | null
    type: QuestionFormatTypes
    questionAnswerRefId?: number | null
    claimantField?: ClaimantFieldRefTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionFormatRuleUpdateInput = {
    type?: EnumQuestionFormatTypesFieldUpdateOperationsInput | QuestionFormatTypes
    claimantField?: NullableEnumClaimantFieldRefTypesFieldUpdateOperationsInput | ClaimantFieldRefTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneWithoutQuestionFormatRuleNestedInput
    questionAnswerRef?: QuestionUpdateOneWithoutQuestionFormatAnswerRefNestedInput
  }

  export type QuestionFormatRuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumQuestionFormatTypesFieldUpdateOperationsInput | QuestionFormatTypes
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    claimantField?: NullableEnumClaimantFieldRefTypesFieldUpdateOperationsInput | ClaimantFieldRefTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionFormatRuleCreateManyInput = {
    id?: number
    questionId?: number | null
    type: QuestionFormatTypes
    questionAnswerRefId?: number | null
    claimantField?: ClaimantFieldRefTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionFormatRuleUpdateManyMutationInput = {
    type?: EnumQuestionFormatTypesFieldUpdateOperationsInput | QuestionFormatTypes
    claimantField?: NullableEnumClaimantFieldRefTypesFieldUpdateOperationsInput | ClaimantFieldRefTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionFormatRuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumQuestionFormatTypesFieldUpdateOperationsInput | QuestionFormatTypes
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    claimantField?: NullableEnumClaimantFieldRefTypesFieldUpdateOperationsInput | ClaimantFieldRefTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunctionCreateInput = {
    name: string
    function: string
    created?: Date | string
    updated?: Date | string
    QuestionRule?: QuestionRuleCreateNestedManyWithoutFunctionInput
    OptionRule?: OptionRuleCreateNestedManyWithoutFunctionInput
  }

  export type FunctionUncheckedCreateInput = {
    id?: number
    name: string
    function: string
    created?: Date | string
    updated?: Date | string
    QuestionRule?: QuestionRuleUncheckedCreateNestedManyWithoutFunctionInput
    OptionRule?: OptionRuleUncheckedCreateNestedManyWithoutFunctionInput
  }

  export type FunctionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    function?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    QuestionRule?: QuestionRuleUpdateManyWithoutFunctionNestedInput
    OptionRule?: OptionRuleUpdateManyWithoutFunctionNestedInput
  }

  export type FunctionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    function?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    QuestionRule?: QuestionRuleUncheckedUpdateManyWithoutFunctionNestedInput
    OptionRule?: OptionRuleUncheckedUpdateManyWithoutFunctionNestedInput
  }

  export type FunctionCreateManyInput = {
    id?: number
    name: string
    function: string
    created?: Date | string
    updated?: Date | string
  }

  export type FunctionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    function?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunctionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    function?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TouchPointCreateInput = {
    type: TouchPointType
    created?: Date | string
    updated?: Date | string
    claimant: ClaimantCreateNestedOneWithoutTouchPointInput
  }

  export type TouchPointUncheckedCreateInput = {
    id?: number
    claimantId: number
    type: TouchPointType
    created?: Date | string
    updated?: Date | string
  }

  export type TouchPointUpdateInput = {
    type?: EnumTouchPointTypeFieldUpdateOperationsInput | TouchPointType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    claimant?: ClaimantUpdateOneRequiredWithoutTouchPointNestedInput
  }

  export type TouchPointUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    type?: EnumTouchPointTypeFieldUpdateOperationsInput | TouchPointType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TouchPointCreateManyInput = {
    id?: number
    claimantId: number
    type: TouchPointType
    created?: Date | string
    updated?: Date | string
  }

  export type TouchPointUpdateManyMutationInput = {
    type?: EnumTouchPointTypeFieldUpdateOperationsInput | TouchPointType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TouchPointUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    type?: EnumTouchPointTypeFieldUpdateOperationsInput | TouchPointType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferrerCreateInput = {
    name: string
    type: ReferrerTypes
    payType: ReferrerPayTypes
    preIntakeTimer?: number
    created?: Date | string
    updated?: Date | string
    Claimant?: ClaimantCreateNestedManyWithoutReferrerInput
  }

  export type ReferrerUncheckedCreateInput = {
    id?: number
    name: string
    type: ReferrerTypes
    payType: ReferrerPayTypes
    preIntakeTimer?: number
    created?: Date | string
    updated?: Date | string
    Claimant?: ClaimantUncheckedCreateNestedManyWithoutReferrerInput
  }

  export type ReferrerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumReferrerTypesFieldUpdateOperationsInput | ReferrerTypes
    payType?: EnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes
    preIntakeTimer?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    Claimant?: ClaimantUpdateManyWithoutReferrerNestedInput
  }

  export type ReferrerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumReferrerTypesFieldUpdateOperationsInput | ReferrerTypes
    payType?: EnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes
    preIntakeTimer?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    Claimant?: ClaimantUncheckedUpdateManyWithoutReferrerNestedInput
  }

  export type ReferrerCreateManyInput = {
    id?: number
    name: string
    type: ReferrerTypes
    payType: ReferrerPayTypes
    preIntakeTimer?: number
    created?: Date | string
    updated?: Date | string
  }

  export type ReferrerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumReferrerTypesFieldUpdateOperationsInput | ReferrerTypes
    payType?: EnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes
    preIntakeTimer?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferrerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumReferrerTypesFieldUpdateOperationsInput | ReferrerTypes
    payType?: EnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes
    preIntakeTimer?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SSAStatusCreateInput = {
    name: string
    created?: Date | string
    updated?: Date | string
    claimant?: ClaimantCreateNestedManyWithoutSsaStatusInput
    OptionRule?: OptionRuleCreateNestedManyWithoutSsaStatusInput
    QuestionRule?: QuestionRuleCreateNestedManyWithoutSsaStatusInput
  }

  export type SSAStatusUncheckedCreateInput = {
    id?: number
    name: string
    created?: Date | string
    updated?: Date | string
    claimant?: ClaimantUncheckedCreateNestedManyWithoutSsaStatusInput
    OptionRule?: OptionRuleUncheckedCreateNestedManyWithoutSsaStatusInput
    QuestionRule?: QuestionRuleUncheckedCreateNestedManyWithoutSsaStatusInput
  }

  export type SSAStatusUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    claimant?: ClaimantUpdateManyWithoutSsaStatusNestedInput
    OptionRule?: OptionRuleUpdateManyWithoutSsaStatusNestedInput
    QuestionRule?: QuestionRuleUpdateManyWithoutSsaStatusNestedInput
  }

  export type SSAStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    claimant?: ClaimantUncheckedUpdateManyWithoutSsaStatusNestedInput
    OptionRule?: OptionRuleUncheckedUpdateManyWithoutSsaStatusNestedInput
    QuestionRule?: QuestionRuleUncheckedUpdateManyWithoutSsaStatusNestedInput
  }

  export type SSAStatusCreateManyInput = {
    id?: number
    name: string
    created?: Date | string
    updated?: Date | string
  }

  export type SSAStatusUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SSAStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type CallSessionListRelationFilter = {
    every?: CallSessionWhereInput
    some?: CallSessionWhereInput
    none?: CallSessionWhereInput
  }

  export type CallSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    active?: SortOrder
    lastActive?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    active?: SortOrder
    lastActive?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    active?: SortOrder
    lastActive?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type CursorListRelationFilter = {
    every?: CursorWhereInput
    some?: CursorWhereInput
    none?: CursorWhereInput
  }

  export type AnswerListRelationFilter = {
    every?: AnswerWhereInput
    some?: AnswerWhereInput
    none?: AnswerWhereInput
  }

  export type TouchPointListRelationFilter = {
    every?: TouchPointWhereInput
    some?: TouchPointWhereInput
    none?: TouchPointWhereInput
  }

  export type SubformFieldAnswerListRelationFilter = {
    every?: SubformFieldAnswerWhereInput
    some?: SubformFieldAnswerWhereInput
    none?: SubformFieldAnswerWhereInput
  }

  export type SSAStatusRelationFilter = {
    is?: SSAStatusWhereInput | null
    isNot?: SSAStatusWhereInput | null
  }

  export type ReferrerRelationFilter = {
    is?: ReferrerWhereInput | null
    isNot?: ReferrerWhereInput | null
  }

  export type VoiceMailListRelationFilter = {
    every?: VoiceMailWhereInput
    some?: VoiceMailWhereInput
    none?: VoiceMailWhereInput
  }

  export type CursorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TouchPointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubformFieldAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoiceMailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClaimantCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    referrerId?: SortOrder
    ssaStatusId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type ClaimantAvgOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    ssaStatusId?: SortOrder
  }

  export type ClaimantMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    referrerId?: SortOrder
    ssaStatusId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type ClaimantMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    referrerId?: SortOrder
    ssaStatusId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type ClaimantSumOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    ssaStatusId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type EnumSessionTypesFilter = {
    equals?: SessionTypes
    in?: Enumerable<SessionTypes>
    notIn?: Enumerable<SessionTypes>
    not?: NestedEnumSessionTypesFilter | SessionTypes
  }

  export type EnumSessionStatusesNullableFilter = {
    equals?: SessionStatuses | null
    in?: Enumerable<SessionStatuses> | null
    notIn?: Enumerable<SessionStatuses> | null
    not?: NestedEnumSessionStatusesNullableFilter | SessionStatuses | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ClaimantRelationFilter = {
    is?: ClaimantWhereInput
    isNot?: ClaimantWhereInput
  }

  export type CallSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    claimantId?: SortOrder
    sessionType?: SortOrder
    sessionStatus?: SortOrder
    created?: SortOrder
    ended?: SortOrder
    updated?: SortOrder
    recordingUrl?: SortOrder
    outgoingPhone?: SortOrder
  }

  export type CallSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    claimantId?: SortOrder
  }

  export type CallSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    claimantId?: SortOrder
    sessionType?: SortOrder
    sessionStatus?: SortOrder
    created?: SortOrder
    ended?: SortOrder
    updated?: SortOrder
    recordingUrl?: SortOrder
    outgoingPhone?: SortOrder
  }

  export type CallSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    claimantId?: SortOrder
    sessionType?: SortOrder
    sessionStatus?: SortOrder
    created?: SortOrder
    ended?: SortOrder
    updated?: SortOrder
    recordingUrl?: SortOrder
    outgoingPhone?: SortOrder
  }

  export type CallSessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    claimantId?: SortOrder
  }

  export type EnumSessionTypesWithAggregatesFilter = {
    equals?: SessionTypes
    in?: Enumerable<SessionTypes>
    notIn?: Enumerable<SessionTypes>
    not?: NestedEnumSessionTypesWithAggregatesFilter | SessionTypes
    _count?: NestedIntFilter
    _min?: NestedEnumSessionTypesFilter
    _max?: NestedEnumSessionTypesFilter
  }

  export type EnumSessionStatusesNullableWithAggregatesFilter = {
    equals?: SessionStatuses | null
    in?: Enumerable<SessionStatuses> | null
    notIn?: Enumerable<SessionStatuses> | null
    not?: NestedEnumSessionStatusesNullableWithAggregatesFilter | SessionStatuses | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumSessionStatusesNullableFilter
    _max?: NestedEnumSessionStatusesNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type VoiceMailCountOrderByAggregateInput = {
    id?: SortOrder
    claimantId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    recordingUrl?: SortOrder
    transcription?: SortOrder
  }

  export type VoiceMailAvgOrderByAggregateInput = {
    id?: SortOrder
    claimantId?: SortOrder
  }

  export type VoiceMailMaxOrderByAggregateInput = {
    id?: SortOrder
    claimantId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    recordingUrl?: SortOrder
    transcription?: SortOrder
  }

  export type VoiceMailMinOrderByAggregateInput = {
    id?: SortOrder
    claimantId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    recordingUrl?: SortOrder
    transcription?: SortOrder
  }

  export type VoiceMailSumOrderByAggregateInput = {
    id?: SortOrder
    claimantId?: SortOrder
  }

  export type FormSectionListRelationFilter = {
    every?: FormSectionWhereInput
    some?: FormSectionWhereInput
    none?: FormSectionWhereInput
  }

  export type FormSectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type FormAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FormMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type FormMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type FormSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type FormRelationFilter = {
    is?: FormWhereInput
    isNot?: FormWhereInput
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormSectionCountOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    showTimer?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type FormSectionAvgOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    order?: SortOrder
  }

  export type FormSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    showTimer?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type FormSectionMinOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    showTimer?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type FormSectionSumOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    order?: SortOrder
  }

  export type EnumQuestionTypeFilter = {
    equals?: QuestionType
    in?: Enumerable<QuestionType>
    notIn?: Enumerable<QuestionType>
    not?: NestedEnumQuestionTypeFilter | QuestionType
  }

  export type EnumInputTypeNullableFilter = {
    equals?: InputType | null
    in?: Enumerable<InputType> | null
    notIn?: Enumerable<InputType> | null
    not?: NestedEnumInputTypeNullableFilter | InputType | null
  }

  export type OptionListRelationFilter = {
    every?: OptionWhereInput
    some?: OptionWhereInput
    none?: OptionWhereInput
  }

  export type SubformRelationFilter = {
    is?: SubformWhereInput
    isNot?: SubformWhereInput
  }

  export type FormSectionRelationFilter = {
    is?: FormSectionWhereInput
    isNot?: FormSectionWhereInput
  }

  export type OptionRuleListRelationFilter = {
    every?: OptionRuleWhereInput
    some?: OptionRuleWhereInput
    none?: OptionRuleWhereInput
  }

  export type QuestionRuleListRelationFilter = {
    every?: QuestionRuleWhereInput
    some?: QuestionRuleWhereInput
    none?: QuestionRuleWhereInput
  }

  export type QuestionFormatRuleListRelationFilter = {
    every?: QuestionFormatRuleWhereInput
    some?: QuestionFormatRuleWhereInput
    none?: QuestionFormatRuleWhereInput
  }

  export type OptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OptionRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionFormatRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    formSectionId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    inputType?: SortOrder
    order?: SortOrder
    scriptText?: SortOrder
    optout?: SortOrder
    optoutText?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type QuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    formSectionId?: SortOrder
    order?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    formSectionId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    inputType?: SortOrder
    order?: SortOrder
    scriptText?: SortOrder
    optout?: SortOrder
    optoutText?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    formSectionId?: SortOrder
    question?: SortOrder
    questionType?: SortOrder
    inputType?: SortOrder
    order?: SortOrder
    scriptText?: SortOrder
    optout?: SortOrder
    optoutText?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type QuestionSumOrderByAggregateInput = {
    id?: SortOrder
    formSectionId?: SortOrder
    order?: SortOrder
  }

  export type EnumQuestionTypeWithAggregatesFilter = {
    equals?: QuestionType
    in?: Enumerable<QuestionType>
    notIn?: Enumerable<QuestionType>
    not?: NestedEnumQuestionTypeWithAggregatesFilter | QuestionType
    _count?: NestedIntFilter
    _min?: NestedEnumQuestionTypeFilter
    _max?: NestedEnumQuestionTypeFilter
  }

  export type EnumInputTypeNullableWithAggregatesFilter = {
    equals?: InputType | null
    in?: Enumerable<InputType> | null
    notIn?: Enumerable<InputType> | null
    not?: NestedEnumInputTypeNullableWithAggregatesFilter | InputType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumInputTypeNullableFilter
    _max?: NestedEnumInputTypeNullableFilter
  }

  export type QuestionRelationFilter = {
    is?: QuestionWhereInput
    isNot?: QuestionWhereInput
  }

  export type OptionRelationFilter = {
    is?: OptionWhereInput | null
    isNot?: OptionWhereInput | null
  }

  export type CallSessionRelationFilter = {
    is?: CallSessionWhereInput
    isNot?: CallSessionWhereInput
  }

  export type AnswerQuestionIdSessionIdClaimantIdCompoundUniqueInput = {
    questionId: number
    sessionId: number
    claimantId: number
  }

  export type AnswerCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    claimantId?: SortOrder
    sessionId?: SortOrder
    optionId?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type AnswerAvgOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    claimantId?: SortOrder
    sessionId?: SortOrder
    optionId?: SortOrder
  }

  export type AnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    claimantId?: SortOrder
    sessionId?: SortOrder
    optionId?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type AnswerMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    claimantId?: SortOrder
    sessionId?: SortOrder
    optionId?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type AnswerSumOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    claimantId?: SortOrder
    sessionId?: SortOrder
    optionId?: SortOrder
  }

  export type SubformFieldListRelationFilter = {
    every?: SubformFieldWhereInput
    some?: SubformFieldWhereInput
    none?: SubformFieldWhereInput
  }

  export type SubformFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubformCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SubformAvgOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
  }

  export type SubformMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SubformMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SubformSumOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
  }

  export type EnumSubFormFieldTypeFilter = {
    equals?: SubFormFieldType
    in?: Enumerable<SubFormFieldType>
    notIn?: Enumerable<SubFormFieldType>
    not?: NestedEnumSubFormFieldTypeFilter | SubFormFieldType
  }

  export type SubformFieldOptionListRelationFilter = {
    every?: SubformFieldOptionWhereInput
    some?: SubformFieldOptionWhereInput
    none?: SubformFieldOptionWhereInput
  }

  export type SubformFieldOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubformFieldCountOrderByAggregateInput = {
    id?: SortOrder
    subformId?: SortOrder
    fieldType?: SortOrder
    inputType?: SortOrder
    max?: SortOrder
    name?: SortOrder
    label?: SortOrder
    required?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SubformFieldAvgOrderByAggregateInput = {
    id?: SortOrder
    subformId?: SortOrder
    max?: SortOrder
  }

  export type SubformFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    subformId?: SortOrder
    fieldType?: SortOrder
    inputType?: SortOrder
    max?: SortOrder
    name?: SortOrder
    label?: SortOrder
    required?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SubformFieldMinOrderByAggregateInput = {
    id?: SortOrder
    subformId?: SortOrder
    fieldType?: SortOrder
    inputType?: SortOrder
    max?: SortOrder
    name?: SortOrder
    label?: SortOrder
    required?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SubformFieldSumOrderByAggregateInput = {
    id?: SortOrder
    subformId?: SortOrder
    max?: SortOrder
  }

  export type EnumSubFormFieldTypeWithAggregatesFilter = {
    equals?: SubFormFieldType
    in?: Enumerable<SubFormFieldType>
    notIn?: Enumerable<SubFormFieldType>
    not?: NestedEnumSubFormFieldTypeWithAggregatesFilter | SubFormFieldType
    _count?: NestedIntFilter
    _min?: NestedEnumSubFormFieldTypeFilter
    _max?: NestedEnumSubFormFieldTypeFilter
  }

  export type SubformFieldRelationFilter = {
    is?: SubformFieldWhereInput
    isNot?: SubformFieldWhereInput
  }

  export type SubformFieldOptionCountOrderByAggregateInput = {
    id?: SortOrder
    subformFieldId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SubformFieldOptionAvgOrderByAggregateInput = {
    id?: SortOrder
    subformFieldId?: SortOrder
  }

  export type SubformFieldOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    subformFieldId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SubformFieldOptionMinOrderByAggregateInput = {
    id?: SortOrder
    subformFieldId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SubformFieldOptionSumOrderByAggregateInput = {
    id?: SortOrder
    subformFieldId?: SortOrder
  }

  export type SubformFieldOptionRelationFilter = {
    is?: SubformFieldOptionWhereInput | null
    isNot?: SubformFieldOptionWhereInput | null
  }

  export type SubformFieldAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    subformFieldId?: SortOrder
    claimantId?: SortOrder
    sessionId?: SortOrder
    value?: SortOrder
    optionId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SubformFieldAnswerAvgOrderByAggregateInput = {
    id?: SortOrder
    subformFieldId?: SortOrder
    claimantId?: SortOrder
    sessionId?: SortOrder
    optionId?: SortOrder
  }

  export type SubformFieldAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    subformFieldId?: SortOrder
    claimantId?: SortOrder
    sessionId?: SortOrder
    value?: SortOrder
    optionId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SubformFieldAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    subformFieldId?: SortOrder
    claimantId?: SortOrder
    sessionId?: SortOrder
    value?: SortOrder
    optionId?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SubformFieldAnswerSumOrderByAggregateInput = {
    id?: SortOrder
    subformFieldId?: SortOrder
    claimantId?: SortOrder
    sessionId?: SortOrder
    optionId?: SortOrder
  }

  export type CursorCountOrderByAggregateInput = {
    id?: SortOrder
    formSectionId?: SortOrder
    questionId?: SortOrder
    claimantId?: SortOrder
    created?: SortOrder
    updatedAt?: SortOrder
  }

  export type CursorAvgOrderByAggregateInput = {
    id?: SortOrder
    formSectionId?: SortOrder
    questionId?: SortOrder
    claimantId?: SortOrder
  }

  export type CursorMaxOrderByAggregateInput = {
    id?: SortOrder
    formSectionId?: SortOrder
    questionId?: SortOrder
    claimantId?: SortOrder
    created?: SortOrder
    updatedAt?: SortOrder
  }

  export type CursorMinOrderByAggregateInput = {
    id?: SortOrder
    formSectionId?: SortOrder
    questionId?: SortOrder
    claimantId?: SortOrder
    created?: SortOrder
    updatedAt?: SortOrder
  }

  export type CursorSumOrderByAggregateInput = {
    id?: SortOrder
    formSectionId?: SortOrder
    questionId?: SortOrder
    claimantId?: SortOrder
  }

  export type OptionCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updatedAt?: SortOrder
  }

  export type OptionAvgOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
  }

  export type OptionMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updatedAt?: SortOrder
  }

  export type OptionMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    label?: SortOrder
    value?: SortOrder
    created?: SortOrder
    updatedAt?: SortOrder
  }

  export type OptionSumOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
  }

  export type EnumRuleTypeFilter = {
    equals?: RuleType
    in?: Enumerable<RuleType>
    notIn?: Enumerable<RuleType>
    not?: NestedEnumRuleTypeFilter | RuleType
  }

  export type EnumOperatorOptionNullableFilter = {
    equals?: OperatorOption | null
    in?: Enumerable<OperatorOption> | null
    notIn?: Enumerable<OperatorOption> | null
    not?: NestedEnumOperatorOptionNullableFilter | OperatorOption | null
  }

  export type EnumReferrerPayTypesNullableFilter = {
    equals?: ReferrerPayTypes | null
    in?: Enumerable<ReferrerPayTypes> | null
    notIn?: Enumerable<ReferrerPayTypes> | null
    not?: NestedEnumReferrerPayTypesNullableFilter | ReferrerPayTypes | null
  }

  export type FunctionRelationFilter = {
    is?: FunctionWhereInput | null
    isNot?: FunctionWhereInput | null
  }

  export type OptionRuleCountOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    functionId?: SortOrder
    questionAnswerRefId?: SortOrder
    ssaStatusId?: SortOrder
    isReferrerPayType?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type OptionRuleAvgOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    value?: SortOrder
    functionId?: SortOrder
    questionAnswerRefId?: SortOrder
    ssaStatusId?: SortOrder
  }

  export type OptionRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    functionId?: SortOrder
    questionAnswerRefId?: SortOrder
    ssaStatusId?: SortOrder
    isReferrerPayType?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type OptionRuleMinOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    functionId?: SortOrder
    questionAnswerRefId?: SortOrder
    ssaStatusId?: SortOrder
    isReferrerPayType?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type OptionRuleSumOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    value?: SortOrder
    functionId?: SortOrder
    questionAnswerRefId?: SortOrder
    ssaStatusId?: SortOrder
  }

  export type EnumRuleTypeWithAggregatesFilter = {
    equals?: RuleType
    in?: Enumerable<RuleType>
    notIn?: Enumerable<RuleType>
    not?: NestedEnumRuleTypeWithAggregatesFilter | RuleType
    _count?: NestedIntFilter
    _min?: NestedEnumRuleTypeFilter
    _max?: NestedEnumRuleTypeFilter
  }

  export type EnumOperatorOptionNullableWithAggregatesFilter = {
    equals?: OperatorOption | null
    in?: Enumerable<OperatorOption> | null
    notIn?: Enumerable<OperatorOption> | null
    not?: NestedEnumOperatorOptionNullableWithAggregatesFilter | OperatorOption | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumOperatorOptionNullableFilter
    _max?: NestedEnumOperatorOptionNullableFilter
  }

  export type EnumReferrerPayTypesNullableWithAggregatesFilter = {
    equals?: ReferrerPayTypes | null
    in?: Enumerable<ReferrerPayTypes> | null
    notIn?: Enumerable<ReferrerPayTypes> | null
    not?: NestedEnumReferrerPayTypesNullableWithAggregatesFilter | ReferrerPayTypes | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumReferrerPayTypesNullableFilter
    _max?: NestedEnumReferrerPayTypesNullableFilter
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type QuestionRuleCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    optout?: SortOrder
    type?: SortOrder
    value?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    functionId?: SortOrder
    questionAnswerRefId?: SortOrder
    ssaStatusId?: SortOrder
    isReferrerPayType?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type QuestionRuleAvgOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    value?: SortOrder
    functionId?: SortOrder
    questionAnswerRefId?: SortOrder
    ssaStatusId?: SortOrder
  }

  export type QuestionRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    optout?: SortOrder
    type?: SortOrder
    value?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    functionId?: SortOrder
    questionAnswerRefId?: SortOrder
    ssaStatusId?: SortOrder
    isReferrerPayType?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type QuestionRuleMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    optout?: SortOrder
    type?: SortOrder
    value?: SortOrder
    operator?: SortOrder
    comparisonValue?: SortOrder
    functionId?: SortOrder
    questionAnswerRefId?: SortOrder
    ssaStatusId?: SortOrder
    isReferrerPayType?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type QuestionRuleSumOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    value?: SortOrder
    functionId?: SortOrder
    questionAnswerRefId?: SortOrder
    ssaStatusId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type EnumQuestionFormatTypesFilter = {
    equals?: QuestionFormatTypes
    in?: Enumerable<QuestionFormatTypes>
    notIn?: Enumerable<QuestionFormatTypes>
    not?: NestedEnumQuestionFormatTypesFilter | QuestionFormatTypes
  }

  export type EnumClaimantFieldRefTypesNullableFilter = {
    equals?: ClaimantFieldRefTypes | null
    in?: Enumerable<ClaimantFieldRefTypes> | null
    notIn?: Enumerable<ClaimantFieldRefTypes> | null
    not?: NestedEnumClaimantFieldRefTypesNullableFilter | ClaimantFieldRefTypes | null
  }

  export type QuestionFormatRuleCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    type?: SortOrder
    questionAnswerRefId?: SortOrder
    claimantField?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type QuestionFormatRuleAvgOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    questionAnswerRefId?: SortOrder
  }

  export type QuestionFormatRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    type?: SortOrder
    questionAnswerRefId?: SortOrder
    claimantField?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type QuestionFormatRuleMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    type?: SortOrder
    questionAnswerRefId?: SortOrder
    claimantField?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type QuestionFormatRuleSumOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    questionAnswerRefId?: SortOrder
  }

  export type EnumQuestionFormatTypesWithAggregatesFilter = {
    equals?: QuestionFormatTypes
    in?: Enumerable<QuestionFormatTypes>
    notIn?: Enumerable<QuestionFormatTypes>
    not?: NestedEnumQuestionFormatTypesWithAggregatesFilter | QuestionFormatTypes
    _count?: NestedIntFilter
    _min?: NestedEnumQuestionFormatTypesFilter
    _max?: NestedEnumQuestionFormatTypesFilter
  }

  export type EnumClaimantFieldRefTypesNullableWithAggregatesFilter = {
    equals?: ClaimantFieldRefTypes | null
    in?: Enumerable<ClaimantFieldRefTypes> | null
    notIn?: Enumerable<ClaimantFieldRefTypes> | null
    not?: NestedEnumClaimantFieldRefTypesNullableWithAggregatesFilter | ClaimantFieldRefTypes | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumClaimantFieldRefTypesNullableFilter
    _max?: NestedEnumClaimantFieldRefTypesNullableFilter
  }

  export type FunctionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    function?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type FunctionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FunctionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    function?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type FunctionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    function?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type FunctionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTouchPointTypeFilter = {
    equals?: TouchPointType
    in?: Enumerable<TouchPointType>
    notIn?: Enumerable<TouchPointType>
    not?: NestedEnumTouchPointTypeFilter | TouchPointType
  }

  export type TouchPointCountOrderByAggregateInput = {
    id?: SortOrder
    claimantId?: SortOrder
    type?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type TouchPointAvgOrderByAggregateInput = {
    id?: SortOrder
    claimantId?: SortOrder
  }

  export type TouchPointMaxOrderByAggregateInput = {
    id?: SortOrder
    claimantId?: SortOrder
    type?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type TouchPointMinOrderByAggregateInput = {
    id?: SortOrder
    claimantId?: SortOrder
    type?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type TouchPointSumOrderByAggregateInput = {
    id?: SortOrder
    claimantId?: SortOrder
  }

  export type EnumTouchPointTypeWithAggregatesFilter = {
    equals?: TouchPointType
    in?: Enumerable<TouchPointType>
    notIn?: Enumerable<TouchPointType>
    not?: NestedEnumTouchPointTypeWithAggregatesFilter | TouchPointType
    _count?: NestedIntFilter
    _min?: NestedEnumTouchPointTypeFilter
    _max?: NestedEnumTouchPointTypeFilter
  }

  export type EnumReferrerTypesFilter = {
    equals?: ReferrerTypes
    in?: Enumerable<ReferrerTypes>
    notIn?: Enumerable<ReferrerTypes>
    not?: NestedEnumReferrerTypesFilter | ReferrerTypes
  }

  export type EnumReferrerPayTypesFilter = {
    equals?: ReferrerPayTypes
    in?: Enumerable<ReferrerPayTypes>
    notIn?: Enumerable<ReferrerPayTypes>
    not?: NestedEnumReferrerPayTypesFilter | ReferrerPayTypes
  }

  export type ClaimantListRelationFilter = {
    every?: ClaimantWhereInput
    some?: ClaimantWhereInput
    none?: ClaimantWhereInput
  }

  export type ClaimantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferrerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    payType?: SortOrder
    preIntakeTimer?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type ReferrerAvgOrderByAggregateInput = {
    id?: SortOrder
    preIntakeTimer?: SortOrder
  }

  export type ReferrerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    payType?: SortOrder
    preIntakeTimer?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type ReferrerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    payType?: SortOrder
    preIntakeTimer?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type ReferrerSumOrderByAggregateInput = {
    id?: SortOrder
    preIntakeTimer?: SortOrder
  }

  export type EnumReferrerTypesWithAggregatesFilter = {
    equals?: ReferrerTypes
    in?: Enumerable<ReferrerTypes>
    notIn?: Enumerable<ReferrerTypes>
    not?: NestedEnumReferrerTypesWithAggregatesFilter | ReferrerTypes
    _count?: NestedIntFilter
    _min?: NestedEnumReferrerTypesFilter
    _max?: NestedEnumReferrerTypesFilter
  }

  export type EnumReferrerPayTypesWithAggregatesFilter = {
    equals?: ReferrerPayTypes
    in?: Enumerable<ReferrerPayTypes>
    notIn?: Enumerable<ReferrerPayTypes>
    not?: NestedEnumReferrerPayTypesWithAggregatesFilter | ReferrerPayTypes
    _count?: NestedIntFilter
    _min?: NestedEnumReferrerPayTypesFilter
    _max?: NestedEnumReferrerPayTypesFilter
  }

  export type SSAStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SSAStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SSAStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SSAStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type SSAStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CallSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CallSessionCreateWithoutUserInput>, Enumerable<CallSessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CallSessionCreateOrConnectWithoutUserInput>
    createMany?: CallSessionCreateManyUserInputEnvelope
    connect?: Enumerable<CallSessionWhereUniqueInput>
  }

  export type CallSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CallSessionCreateWithoutUserInput>, Enumerable<CallSessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CallSessionCreateOrConnectWithoutUserInput>
    createMany?: CallSessionCreateManyUserInputEnvelope
    connect?: Enumerable<CallSessionWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CallSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CallSessionCreateWithoutUserInput>, Enumerable<CallSessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CallSessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CallSessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CallSessionCreateManyUserInputEnvelope
    set?: Enumerable<CallSessionWhereUniqueInput>
    disconnect?: Enumerable<CallSessionWhereUniqueInput>
    delete?: Enumerable<CallSessionWhereUniqueInput>
    connect?: Enumerable<CallSessionWhereUniqueInput>
    update?: Enumerable<CallSessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CallSessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CallSessionScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CallSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CallSessionCreateWithoutUserInput>, Enumerable<CallSessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CallSessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CallSessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CallSessionCreateManyUserInputEnvelope
    set?: Enumerable<CallSessionWhereUniqueInput>
    disconnect?: Enumerable<CallSessionWhereUniqueInput>
    delete?: Enumerable<CallSessionWhereUniqueInput>
    connect?: Enumerable<CallSessionWhereUniqueInput>
    update?: Enumerable<CallSessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CallSessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CallSessionScalarWhereInput>
  }

  export type CursorCreateNestedManyWithoutClaimantInput = {
    create?: XOR<Enumerable<CursorCreateWithoutClaimantInput>, Enumerable<CursorUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<CursorCreateOrConnectWithoutClaimantInput>
    createMany?: CursorCreateManyClaimantInputEnvelope
    connect?: Enumerable<CursorWhereUniqueInput>
  }

  export type AnswerCreateNestedManyWithoutClaimantInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutClaimantInput>, Enumerable<AnswerUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutClaimantInput>
    createMany?: AnswerCreateManyClaimantInputEnvelope
    connect?: Enumerable<AnswerWhereUniqueInput>
  }

  export type TouchPointCreateNestedManyWithoutClaimantInput = {
    create?: XOR<Enumerable<TouchPointCreateWithoutClaimantInput>, Enumerable<TouchPointUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<TouchPointCreateOrConnectWithoutClaimantInput>
    createMany?: TouchPointCreateManyClaimantInputEnvelope
    connect?: Enumerable<TouchPointWhereUniqueInput>
  }

  export type CallSessionCreateNestedManyWithoutClaimantInput = {
    create?: XOR<Enumerable<CallSessionCreateWithoutClaimantInput>, Enumerable<CallSessionUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<CallSessionCreateOrConnectWithoutClaimantInput>
    createMany?: CallSessionCreateManyClaimantInputEnvelope
    connect?: Enumerable<CallSessionWhereUniqueInput>
  }

  export type SubformFieldAnswerCreateNestedManyWithoutClaimantInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutClaimantInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutClaimantInput>
    createMany?: SubformFieldAnswerCreateManyClaimantInputEnvelope
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
  }

  export type SSAStatusCreateNestedOneWithoutClaimantInput = {
    create?: XOR<SSAStatusCreateWithoutClaimantInput, SSAStatusUncheckedCreateWithoutClaimantInput>
    connectOrCreate?: SSAStatusCreateOrConnectWithoutClaimantInput
    connect?: SSAStatusWhereUniqueInput
  }

  export type ReferrerCreateNestedOneWithoutClaimantInput = {
    create?: XOR<ReferrerCreateWithoutClaimantInput, ReferrerUncheckedCreateWithoutClaimantInput>
    connectOrCreate?: ReferrerCreateOrConnectWithoutClaimantInput
    connect?: ReferrerWhereUniqueInput
  }

  export type VoiceMailCreateNestedManyWithoutClaimantInput = {
    create?: XOR<Enumerable<VoiceMailCreateWithoutClaimantInput>, Enumerable<VoiceMailUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<VoiceMailCreateOrConnectWithoutClaimantInput>
    createMany?: VoiceMailCreateManyClaimantInputEnvelope
    connect?: Enumerable<VoiceMailWhereUniqueInput>
  }

  export type CursorUncheckedCreateNestedManyWithoutClaimantInput = {
    create?: XOR<Enumerable<CursorCreateWithoutClaimantInput>, Enumerable<CursorUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<CursorCreateOrConnectWithoutClaimantInput>
    createMany?: CursorCreateManyClaimantInputEnvelope
    connect?: Enumerable<CursorWhereUniqueInput>
  }

  export type AnswerUncheckedCreateNestedManyWithoutClaimantInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutClaimantInput>, Enumerable<AnswerUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutClaimantInput>
    createMany?: AnswerCreateManyClaimantInputEnvelope
    connect?: Enumerable<AnswerWhereUniqueInput>
  }

  export type TouchPointUncheckedCreateNestedManyWithoutClaimantInput = {
    create?: XOR<Enumerable<TouchPointCreateWithoutClaimantInput>, Enumerable<TouchPointUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<TouchPointCreateOrConnectWithoutClaimantInput>
    createMany?: TouchPointCreateManyClaimantInputEnvelope
    connect?: Enumerable<TouchPointWhereUniqueInput>
  }

  export type CallSessionUncheckedCreateNestedManyWithoutClaimantInput = {
    create?: XOR<Enumerable<CallSessionCreateWithoutClaimantInput>, Enumerable<CallSessionUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<CallSessionCreateOrConnectWithoutClaimantInput>
    createMany?: CallSessionCreateManyClaimantInputEnvelope
    connect?: Enumerable<CallSessionWhereUniqueInput>
  }

  export type SubformFieldAnswerUncheckedCreateNestedManyWithoutClaimantInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutClaimantInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutClaimantInput>
    createMany?: SubformFieldAnswerCreateManyClaimantInputEnvelope
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
  }

  export type VoiceMailUncheckedCreateNestedManyWithoutClaimantInput = {
    create?: XOR<Enumerable<VoiceMailCreateWithoutClaimantInput>, Enumerable<VoiceMailUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<VoiceMailCreateOrConnectWithoutClaimantInput>
    createMany?: VoiceMailCreateManyClaimantInputEnvelope
    connect?: Enumerable<VoiceMailWhereUniqueInput>
  }

  export type CursorUpdateManyWithoutClaimantNestedInput = {
    create?: XOR<Enumerable<CursorCreateWithoutClaimantInput>, Enumerable<CursorUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<CursorCreateOrConnectWithoutClaimantInput>
    upsert?: Enumerable<CursorUpsertWithWhereUniqueWithoutClaimantInput>
    createMany?: CursorCreateManyClaimantInputEnvelope
    set?: Enumerable<CursorWhereUniqueInput>
    disconnect?: Enumerable<CursorWhereUniqueInput>
    delete?: Enumerable<CursorWhereUniqueInput>
    connect?: Enumerable<CursorWhereUniqueInput>
    update?: Enumerable<CursorUpdateWithWhereUniqueWithoutClaimantInput>
    updateMany?: Enumerable<CursorUpdateManyWithWhereWithoutClaimantInput>
    deleteMany?: Enumerable<CursorScalarWhereInput>
  }

  export type AnswerUpdateManyWithoutClaimantNestedInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutClaimantInput>, Enumerable<AnswerUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutClaimantInput>
    upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutClaimantInput>
    createMany?: AnswerCreateManyClaimantInputEnvelope
    set?: Enumerable<AnswerWhereUniqueInput>
    disconnect?: Enumerable<AnswerWhereUniqueInput>
    delete?: Enumerable<AnswerWhereUniqueInput>
    connect?: Enumerable<AnswerWhereUniqueInput>
    update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutClaimantInput>
    updateMany?: Enumerable<AnswerUpdateManyWithWhereWithoutClaimantInput>
    deleteMany?: Enumerable<AnswerScalarWhereInput>
  }

  export type TouchPointUpdateManyWithoutClaimantNestedInput = {
    create?: XOR<Enumerable<TouchPointCreateWithoutClaimantInput>, Enumerable<TouchPointUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<TouchPointCreateOrConnectWithoutClaimantInput>
    upsert?: Enumerable<TouchPointUpsertWithWhereUniqueWithoutClaimantInput>
    createMany?: TouchPointCreateManyClaimantInputEnvelope
    set?: Enumerable<TouchPointWhereUniqueInput>
    disconnect?: Enumerable<TouchPointWhereUniqueInput>
    delete?: Enumerable<TouchPointWhereUniqueInput>
    connect?: Enumerable<TouchPointWhereUniqueInput>
    update?: Enumerable<TouchPointUpdateWithWhereUniqueWithoutClaimantInput>
    updateMany?: Enumerable<TouchPointUpdateManyWithWhereWithoutClaimantInput>
    deleteMany?: Enumerable<TouchPointScalarWhereInput>
  }

  export type CallSessionUpdateManyWithoutClaimantNestedInput = {
    create?: XOR<Enumerable<CallSessionCreateWithoutClaimantInput>, Enumerable<CallSessionUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<CallSessionCreateOrConnectWithoutClaimantInput>
    upsert?: Enumerable<CallSessionUpsertWithWhereUniqueWithoutClaimantInput>
    createMany?: CallSessionCreateManyClaimantInputEnvelope
    set?: Enumerable<CallSessionWhereUniqueInput>
    disconnect?: Enumerable<CallSessionWhereUniqueInput>
    delete?: Enumerable<CallSessionWhereUniqueInput>
    connect?: Enumerable<CallSessionWhereUniqueInput>
    update?: Enumerable<CallSessionUpdateWithWhereUniqueWithoutClaimantInput>
    updateMany?: Enumerable<CallSessionUpdateManyWithWhereWithoutClaimantInput>
    deleteMany?: Enumerable<CallSessionScalarWhereInput>
  }

  export type SubformFieldAnswerUpdateManyWithoutClaimantNestedInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutClaimantInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutClaimantInput>
    upsert?: Enumerable<SubformFieldAnswerUpsertWithWhereUniqueWithoutClaimantInput>
    createMany?: SubformFieldAnswerCreateManyClaimantInputEnvelope
    set?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    disconnect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    delete?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    update?: Enumerable<SubformFieldAnswerUpdateWithWhereUniqueWithoutClaimantInput>
    updateMany?: Enumerable<SubformFieldAnswerUpdateManyWithWhereWithoutClaimantInput>
    deleteMany?: Enumerable<SubformFieldAnswerScalarWhereInput>
  }

  export type SSAStatusUpdateOneWithoutClaimantNestedInput = {
    create?: XOR<SSAStatusCreateWithoutClaimantInput, SSAStatusUncheckedCreateWithoutClaimantInput>
    connectOrCreate?: SSAStatusCreateOrConnectWithoutClaimantInput
    upsert?: SSAStatusUpsertWithoutClaimantInput
    disconnect?: boolean
    delete?: boolean
    connect?: SSAStatusWhereUniqueInput
    update?: XOR<SSAStatusUpdateWithoutClaimantInput, SSAStatusUncheckedUpdateWithoutClaimantInput>
  }

  export type ReferrerUpdateOneWithoutClaimantNestedInput = {
    create?: XOR<ReferrerCreateWithoutClaimantInput, ReferrerUncheckedCreateWithoutClaimantInput>
    connectOrCreate?: ReferrerCreateOrConnectWithoutClaimantInput
    upsert?: ReferrerUpsertWithoutClaimantInput
    disconnect?: boolean
    delete?: boolean
    connect?: ReferrerWhereUniqueInput
    update?: XOR<ReferrerUpdateWithoutClaimantInput, ReferrerUncheckedUpdateWithoutClaimantInput>
  }

  export type VoiceMailUpdateManyWithoutClaimantNestedInput = {
    create?: XOR<Enumerable<VoiceMailCreateWithoutClaimantInput>, Enumerable<VoiceMailUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<VoiceMailCreateOrConnectWithoutClaimantInput>
    upsert?: Enumerable<VoiceMailUpsertWithWhereUniqueWithoutClaimantInput>
    createMany?: VoiceMailCreateManyClaimantInputEnvelope
    set?: Enumerable<VoiceMailWhereUniqueInput>
    disconnect?: Enumerable<VoiceMailWhereUniqueInput>
    delete?: Enumerable<VoiceMailWhereUniqueInput>
    connect?: Enumerable<VoiceMailWhereUniqueInput>
    update?: Enumerable<VoiceMailUpdateWithWhereUniqueWithoutClaimantInput>
    updateMany?: Enumerable<VoiceMailUpdateManyWithWhereWithoutClaimantInput>
    deleteMany?: Enumerable<VoiceMailScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CursorUncheckedUpdateManyWithoutClaimantNestedInput = {
    create?: XOR<Enumerable<CursorCreateWithoutClaimantInput>, Enumerable<CursorUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<CursorCreateOrConnectWithoutClaimantInput>
    upsert?: Enumerable<CursorUpsertWithWhereUniqueWithoutClaimantInput>
    createMany?: CursorCreateManyClaimantInputEnvelope
    set?: Enumerable<CursorWhereUniqueInput>
    disconnect?: Enumerable<CursorWhereUniqueInput>
    delete?: Enumerable<CursorWhereUniqueInput>
    connect?: Enumerable<CursorWhereUniqueInput>
    update?: Enumerable<CursorUpdateWithWhereUniqueWithoutClaimantInput>
    updateMany?: Enumerable<CursorUpdateManyWithWhereWithoutClaimantInput>
    deleteMany?: Enumerable<CursorScalarWhereInput>
  }

  export type AnswerUncheckedUpdateManyWithoutClaimantNestedInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutClaimantInput>, Enumerable<AnswerUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutClaimantInput>
    upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutClaimantInput>
    createMany?: AnswerCreateManyClaimantInputEnvelope
    set?: Enumerable<AnswerWhereUniqueInput>
    disconnect?: Enumerable<AnswerWhereUniqueInput>
    delete?: Enumerable<AnswerWhereUniqueInput>
    connect?: Enumerable<AnswerWhereUniqueInput>
    update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutClaimantInput>
    updateMany?: Enumerable<AnswerUpdateManyWithWhereWithoutClaimantInput>
    deleteMany?: Enumerable<AnswerScalarWhereInput>
  }

  export type TouchPointUncheckedUpdateManyWithoutClaimantNestedInput = {
    create?: XOR<Enumerable<TouchPointCreateWithoutClaimantInput>, Enumerable<TouchPointUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<TouchPointCreateOrConnectWithoutClaimantInput>
    upsert?: Enumerable<TouchPointUpsertWithWhereUniqueWithoutClaimantInput>
    createMany?: TouchPointCreateManyClaimantInputEnvelope
    set?: Enumerable<TouchPointWhereUniqueInput>
    disconnect?: Enumerable<TouchPointWhereUniqueInput>
    delete?: Enumerable<TouchPointWhereUniqueInput>
    connect?: Enumerable<TouchPointWhereUniqueInput>
    update?: Enumerable<TouchPointUpdateWithWhereUniqueWithoutClaimantInput>
    updateMany?: Enumerable<TouchPointUpdateManyWithWhereWithoutClaimantInput>
    deleteMany?: Enumerable<TouchPointScalarWhereInput>
  }

  export type CallSessionUncheckedUpdateManyWithoutClaimantNestedInput = {
    create?: XOR<Enumerable<CallSessionCreateWithoutClaimantInput>, Enumerable<CallSessionUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<CallSessionCreateOrConnectWithoutClaimantInput>
    upsert?: Enumerable<CallSessionUpsertWithWhereUniqueWithoutClaimantInput>
    createMany?: CallSessionCreateManyClaimantInputEnvelope
    set?: Enumerable<CallSessionWhereUniqueInput>
    disconnect?: Enumerable<CallSessionWhereUniqueInput>
    delete?: Enumerable<CallSessionWhereUniqueInput>
    connect?: Enumerable<CallSessionWhereUniqueInput>
    update?: Enumerable<CallSessionUpdateWithWhereUniqueWithoutClaimantInput>
    updateMany?: Enumerable<CallSessionUpdateManyWithWhereWithoutClaimantInput>
    deleteMany?: Enumerable<CallSessionScalarWhereInput>
  }

  export type SubformFieldAnswerUncheckedUpdateManyWithoutClaimantNestedInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutClaimantInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutClaimantInput>
    upsert?: Enumerable<SubformFieldAnswerUpsertWithWhereUniqueWithoutClaimantInput>
    createMany?: SubformFieldAnswerCreateManyClaimantInputEnvelope
    set?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    disconnect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    delete?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    update?: Enumerable<SubformFieldAnswerUpdateWithWhereUniqueWithoutClaimantInput>
    updateMany?: Enumerable<SubformFieldAnswerUpdateManyWithWhereWithoutClaimantInput>
    deleteMany?: Enumerable<SubformFieldAnswerScalarWhereInput>
  }

  export type VoiceMailUncheckedUpdateManyWithoutClaimantNestedInput = {
    create?: XOR<Enumerable<VoiceMailCreateWithoutClaimantInput>, Enumerable<VoiceMailUncheckedCreateWithoutClaimantInput>>
    connectOrCreate?: Enumerable<VoiceMailCreateOrConnectWithoutClaimantInput>
    upsert?: Enumerable<VoiceMailUpsertWithWhereUniqueWithoutClaimantInput>
    createMany?: VoiceMailCreateManyClaimantInputEnvelope
    set?: Enumerable<VoiceMailWhereUniqueInput>
    disconnect?: Enumerable<VoiceMailWhereUniqueInput>
    delete?: Enumerable<VoiceMailWhereUniqueInput>
    connect?: Enumerable<VoiceMailWhereUniqueInput>
    update?: Enumerable<VoiceMailUpdateWithWhereUniqueWithoutClaimantInput>
    updateMany?: Enumerable<VoiceMailUpdateManyWithWhereWithoutClaimantInput>
    deleteMany?: Enumerable<VoiceMailScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutCallSessionsInput = {
    create?: XOR<UserCreateWithoutCallSessionsInput, UserUncheckedCreateWithoutCallSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCallSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type ClaimantCreateNestedOneWithoutCallSessionsInput = {
    create?: XOR<ClaimantCreateWithoutCallSessionsInput, ClaimantUncheckedCreateWithoutCallSessionsInput>
    connectOrCreate?: ClaimantCreateOrConnectWithoutCallSessionsInput
    connect?: ClaimantWhereUniqueInput
  }

  export type AnswerCreateNestedManyWithoutCallSessionInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutCallSessionInput>, Enumerable<AnswerUncheckedCreateWithoutCallSessionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutCallSessionInput>
    createMany?: AnswerCreateManyCallSessionInputEnvelope
    connect?: Enumerable<AnswerWhereUniqueInput>
  }

  export type SubformFieldAnswerCreateNestedManyWithoutSessionInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutSessionInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutSessionInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutSessionInput>
    createMany?: SubformFieldAnswerCreateManySessionInputEnvelope
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
  }

  export type AnswerUncheckedCreateNestedManyWithoutCallSessionInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutCallSessionInput>, Enumerable<AnswerUncheckedCreateWithoutCallSessionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutCallSessionInput>
    createMany?: AnswerCreateManyCallSessionInputEnvelope
    connect?: Enumerable<AnswerWhereUniqueInput>
  }

  export type SubformFieldAnswerUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutSessionInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutSessionInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutSessionInput>
    createMany?: SubformFieldAnswerCreateManySessionInputEnvelope
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
  }

  export type EnumSessionTypesFieldUpdateOperationsInput = {
    set?: SessionTypes
  }

  export type NullableEnumSessionStatusesFieldUpdateOperationsInput = {
    set?: SessionStatuses | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutCallSessionsNestedInput = {
    create?: XOR<UserCreateWithoutCallSessionsInput, UserUncheckedCreateWithoutCallSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCallSessionsInput
    upsert?: UserUpsertWithoutCallSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCallSessionsInput, UserUncheckedUpdateWithoutCallSessionsInput>
  }

  export type ClaimantUpdateOneRequiredWithoutCallSessionsNestedInput = {
    create?: XOR<ClaimantCreateWithoutCallSessionsInput, ClaimantUncheckedCreateWithoutCallSessionsInput>
    connectOrCreate?: ClaimantCreateOrConnectWithoutCallSessionsInput
    upsert?: ClaimantUpsertWithoutCallSessionsInput
    connect?: ClaimantWhereUniqueInput
    update?: XOR<ClaimantUpdateWithoutCallSessionsInput, ClaimantUncheckedUpdateWithoutCallSessionsInput>
  }

  export type AnswerUpdateManyWithoutCallSessionNestedInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutCallSessionInput>, Enumerable<AnswerUncheckedCreateWithoutCallSessionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutCallSessionInput>
    upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutCallSessionInput>
    createMany?: AnswerCreateManyCallSessionInputEnvelope
    set?: Enumerable<AnswerWhereUniqueInput>
    disconnect?: Enumerable<AnswerWhereUniqueInput>
    delete?: Enumerable<AnswerWhereUniqueInput>
    connect?: Enumerable<AnswerWhereUniqueInput>
    update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutCallSessionInput>
    updateMany?: Enumerable<AnswerUpdateManyWithWhereWithoutCallSessionInput>
    deleteMany?: Enumerable<AnswerScalarWhereInput>
  }

  export type SubformFieldAnswerUpdateManyWithoutSessionNestedInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutSessionInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutSessionInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutSessionInput>
    upsert?: Enumerable<SubformFieldAnswerUpsertWithWhereUniqueWithoutSessionInput>
    createMany?: SubformFieldAnswerCreateManySessionInputEnvelope
    set?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    disconnect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    delete?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    update?: Enumerable<SubformFieldAnswerUpdateWithWhereUniqueWithoutSessionInput>
    updateMany?: Enumerable<SubformFieldAnswerUpdateManyWithWhereWithoutSessionInput>
    deleteMany?: Enumerable<SubformFieldAnswerScalarWhereInput>
  }

  export type AnswerUncheckedUpdateManyWithoutCallSessionNestedInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutCallSessionInput>, Enumerable<AnswerUncheckedCreateWithoutCallSessionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutCallSessionInput>
    upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutCallSessionInput>
    createMany?: AnswerCreateManyCallSessionInputEnvelope
    set?: Enumerable<AnswerWhereUniqueInput>
    disconnect?: Enumerable<AnswerWhereUniqueInput>
    delete?: Enumerable<AnswerWhereUniqueInput>
    connect?: Enumerable<AnswerWhereUniqueInput>
    update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutCallSessionInput>
    updateMany?: Enumerable<AnswerUpdateManyWithWhereWithoutCallSessionInput>
    deleteMany?: Enumerable<AnswerScalarWhereInput>
  }

  export type SubformFieldAnswerUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutSessionInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutSessionInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutSessionInput>
    upsert?: Enumerable<SubformFieldAnswerUpsertWithWhereUniqueWithoutSessionInput>
    createMany?: SubformFieldAnswerCreateManySessionInputEnvelope
    set?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    disconnect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    delete?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    update?: Enumerable<SubformFieldAnswerUpdateWithWhereUniqueWithoutSessionInput>
    updateMany?: Enumerable<SubformFieldAnswerUpdateManyWithWhereWithoutSessionInput>
    deleteMany?: Enumerable<SubformFieldAnswerScalarWhereInput>
  }

  export type ClaimantCreateNestedOneWithoutVoiceMailInput = {
    create?: XOR<ClaimantCreateWithoutVoiceMailInput, ClaimantUncheckedCreateWithoutVoiceMailInput>
    connectOrCreate?: ClaimantCreateOrConnectWithoutVoiceMailInput
    connect?: ClaimantWhereUniqueInput
  }

  export type ClaimantUpdateOneWithoutVoiceMailNestedInput = {
    create?: XOR<ClaimantCreateWithoutVoiceMailInput, ClaimantUncheckedCreateWithoutVoiceMailInput>
    connectOrCreate?: ClaimantCreateOrConnectWithoutVoiceMailInput
    upsert?: ClaimantUpsertWithoutVoiceMailInput
    disconnect?: boolean
    delete?: boolean
    connect?: ClaimantWhereUniqueInput
    update?: XOR<ClaimantUpdateWithoutVoiceMailInput, ClaimantUncheckedUpdateWithoutVoiceMailInput>
  }

  export type FormSectionCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<FormSectionCreateWithoutFormInput>, Enumerable<FormSectionUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<FormSectionCreateOrConnectWithoutFormInput>
    createMany?: FormSectionCreateManyFormInputEnvelope
    connect?: Enumerable<FormSectionWhereUniqueInput>
  }

  export type FormSectionUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<FormSectionCreateWithoutFormInput>, Enumerable<FormSectionUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<FormSectionCreateOrConnectWithoutFormInput>
    createMany?: FormSectionCreateManyFormInputEnvelope
    connect?: Enumerable<FormSectionWhereUniqueInput>
  }

  export type FormSectionUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<FormSectionCreateWithoutFormInput>, Enumerable<FormSectionUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<FormSectionCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<FormSectionUpsertWithWhereUniqueWithoutFormInput>
    createMany?: FormSectionCreateManyFormInputEnvelope
    set?: Enumerable<FormSectionWhereUniqueInput>
    disconnect?: Enumerable<FormSectionWhereUniqueInput>
    delete?: Enumerable<FormSectionWhereUniqueInput>
    connect?: Enumerable<FormSectionWhereUniqueInput>
    update?: Enumerable<FormSectionUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<FormSectionUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<FormSectionScalarWhereInput>
  }

  export type FormSectionUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<FormSectionCreateWithoutFormInput>, Enumerable<FormSectionUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<FormSectionCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<FormSectionUpsertWithWhereUniqueWithoutFormInput>
    createMany?: FormSectionCreateManyFormInputEnvelope
    set?: Enumerable<FormSectionWhereUniqueInput>
    disconnect?: Enumerable<FormSectionWhereUniqueInput>
    delete?: Enumerable<FormSectionWhereUniqueInput>
    connect?: Enumerable<FormSectionWhereUniqueInput>
    update?: Enumerable<FormSectionUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<FormSectionUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<FormSectionScalarWhereInput>
  }

  export type QuestionCreateNestedManyWithoutFormSectionInput = {
    create?: XOR<Enumerable<QuestionCreateWithoutFormSectionInput>, Enumerable<QuestionUncheckedCreateWithoutFormSectionInput>>
    connectOrCreate?: Enumerable<QuestionCreateOrConnectWithoutFormSectionInput>
    createMany?: QuestionCreateManyFormSectionInputEnvelope
    connect?: Enumerable<QuestionWhereUniqueInput>
  }

  export type CursorCreateNestedManyWithoutFormSectionInput = {
    create?: XOR<Enumerable<CursorCreateWithoutFormSectionInput>, Enumerable<CursorUncheckedCreateWithoutFormSectionInput>>
    connectOrCreate?: Enumerable<CursorCreateOrConnectWithoutFormSectionInput>
    createMany?: CursorCreateManyFormSectionInputEnvelope
    connect?: Enumerable<CursorWhereUniqueInput>
  }

  export type FormCreateNestedOneWithoutFormSectionInput = {
    create?: XOR<FormCreateWithoutFormSectionInput, FormUncheckedCreateWithoutFormSectionInput>
    connectOrCreate?: FormCreateOrConnectWithoutFormSectionInput
    connect?: FormWhereUniqueInput
  }

  export type QuestionUncheckedCreateNestedManyWithoutFormSectionInput = {
    create?: XOR<Enumerable<QuestionCreateWithoutFormSectionInput>, Enumerable<QuestionUncheckedCreateWithoutFormSectionInput>>
    connectOrCreate?: Enumerable<QuestionCreateOrConnectWithoutFormSectionInput>
    createMany?: QuestionCreateManyFormSectionInputEnvelope
    connect?: Enumerable<QuestionWhereUniqueInput>
  }

  export type CursorUncheckedCreateNestedManyWithoutFormSectionInput = {
    create?: XOR<Enumerable<CursorCreateWithoutFormSectionInput>, Enumerable<CursorUncheckedCreateWithoutFormSectionInput>>
    connectOrCreate?: Enumerable<CursorCreateOrConnectWithoutFormSectionInput>
    createMany?: CursorCreateManyFormSectionInputEnvelope
    connect?: Enumerable<CursorWhereUniqueInput>
  }

  export type QuestionUpdateManyWithoutFormSectionNestedInput = {
    create?: XOR<Enumerable<QuestionCreateWithoutFormSectionInput>, Enumerable<QuestionUncheckedCreateWithoutFormSectionInput>>
    connectOrCreate?: Enumerable<QuestionCreateOrConnectWithoutFormSectionInput>
    upsert?: Enumerable<QuestionUpsertWithWhereUniqueWithoutFormSectionInput>
    createMany?: QuestionCreateManyFormSectionInputEnvelope
    set?: Enumerable<QuestionWhereUniqueInput>
    disconnect?: Enumerable<QuestionWhereUniqueInput>
    delete?: Enumerable<QuestionWhereUniqueInput>
    connect?: Enumerable<QuestionWhereUniqueInput>
    update?: Enumerable<QuestionUpdateWithWhereUniqueWithoutFormSectionInput>
    updateMany?: Enumerable<QuestionUpdateManyWithWhereWithoutFormSectionInput>
    deleteMany?: Enumerable<QuestionScalarWhereInput>
  }

  export type CursorUpdateManyWithoutFormSectionNestedInput = {
    create?: XOR<Enumerable<CursorCreateWithoutFormSectionInput>, Enumerable<CursorUncheckedCreateWithoutFormSectionInput>>
    connectOrCreate?: Enumerable<CursorCreateOrConnectWithoutFormSectionInput>
    upsert?: Enumerable<CursorUpsertWithWhereUniqueWithoutFormSectionInput>
    createMany?: CursorCreateManyFormSectionInputEnvelope
    set?: Enumerable<CursorWhereUniqueInput>
    disconnect?: Enumerable<CursorWhereUniqueInput>
    delete?: Enumerable<CursorWhereUniqueInput>
    connect?: Enumerable<CursorWhereUniqueInput>
    update?: Enumerable<CursorUpdateWithWhereUniqueWithoutFormSectionInput>
    updateMany?: Enumerable<CursorUpdateManyWithWhereWithoutFormSectionInput>
    deleteMany?: Enumerable<CursorScalarWhereInput>
  }

  export type FormUpdateOneRequiredWithoutFormSectionNestedInput = {
    create?: XOR<FormCreateWithoutFormSectionInput, FormUncheckedCreateWithoutFormSectionInput>
    connectOrCreate?: FormCreateOrConnectWithoutFormSectionInput
    upsert?: FormUpsertWithoutFormSectionInput
    connect?: FormWhereUniqueInput
    update?: XOR<FormUpdateWithoutFormSectionInput, FormUncheckedUpdateWithoutFormSectionInput>
  }

  export type QuestionUncheckedUpdateManyWithoutFormSectionNestedInput = {
    create?: XOR<Enumerable<QuestionCreateWithoutFormSectionInput>, Enumerable<QuestionUncheckedCreateWithoutFormSectionInput>>
    connectOrCreate?: Enumerable<QuestionCreateOrConnectWithoutFormSectionInput>
    upsert?: Enumerable<QuestionUpsertWithWhereUniqueWithoutFormSectionInput>
    createMany?: QuestionCreateManyFormSectionInputEnvelope
    set?: Enumerable<QuestionWhereUniqueInput>
    disconnect?: Enumerable<QuestionWhereUniqueInput>
    delete?: Enumerable<QuestionWhereUniqueInput>
    connect?: Enumerable<QuestionWhereUniqueInput>
    update?: Enumerable<QuestionUpdateWithWhereUniqueWithoutFormSectionInput>
    updateMany?: Enumerable<QuestionUpdateManyWithWhereWithoutFormSectionInput>
    deleteMany?: Enumerable<QuestionScalarWhereInput>
  }

  export type CursorUncheckedUpdateManyWithoutFormSectionNestedInput = {
    create?: XOR<Enumerable<CursorCreateWithoutFormSectionInput>, Enumerable<CursorUncheckedCreateWithoutFormSectionInput>>
    connectOrCreate?: Enumerable<CursorCreateOrConnectWithoutFormSectionInput>
    upsert?: Enumerable<CursorUpsertWithWhereUniqueWithoutFormSectionInput>
    createMany?: CursorCreateManyFormSectionInputEnvelope
    set?: Enumerable<CursorWhereUniqueInput>
    disconnect?: Enumerable<CursorWhereUniqueInput>
    delete?: Enumerable<CursorWhereUniqueInput>
    connect?: Enumerable<CursorWhereUniqueInput>
    update?: Enumerable<CursorUpdateWithWhereUniqueWithoutFormSectionInput>
    updateMany?: Enumerable<CursorUpdateManyWithWhereWithoutFormSectionInput>
    deleteMany?: Enumerable<CursorScalarWhereInput>
  }

  export type AnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutQuestionInput>, Enumerable<AnswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutQuestionInput>
    createMany?: AnswerCreateManyQuestionInputEnvelope
    connect?: Enumerable<AnswerWhereUniqueInput>
  }

  export type OptionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<OptionCreateWithoutQuestionInput>, Enumerable<OptionUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<OptionCreateOrConnectWithoutQuestionInput>
    createMany?: OptionCreateManyQuestionInputEnvelope
    connect?: Enumerable<OptionWhereUniqueInput>
  }

  export type SubformCreateNestedOneWithoutQuestionInput = {
    create?: XOR<SubformCreateWithoutQuestionInput, SubformUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: SubformCreateOrConnectWithoutQuestionInput
    connect?: SubformWhereUniqueInput
  }

  export type FormSectionCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<FormSectionCreateWithoutQuestionsInput, FormSectionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: FormSectionCreateOrConnectWithoutQuestionsInput
    connect?: FormSectionWhereUniqueInput
  }

  export type OptionRuleCreateNestedManyWithoutQuestionAnswerRefInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutQuestionAnswerRefInput>, Enumerable<OptionRuleUncheckedCreateWithoutQuestionAnswerRefInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutQuestionAnswerRefInput>
    createMany?: OptionRuleCreateManyQuestionAnswerRefInputEnvelope
    connect?: Enumerable<OptionRuleWhereUniqueInput>
  }

  export type QuestionRuleCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutQuestionInput>, Enumerable<QuestionRuleUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutQuestionInput>
    createMany?: QuestionRuleCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
  }

  export type QuestionRuleCreateNestedManyWithoutQuestionAnswerRefInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutQuestionAnswerRefInput>, Enumerable<QuestionRuleUncheckedCreateWithoutQuestionAnswerRefInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutQuestionAnswerRefInput>
    createMany?: QuestionRuleCreateManyQuestionAnswerRefInputEnvelope
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
  }

  export type QuestionFormatRuleCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuestionFormatRuleCreateWithoutQuestionInput>, Enumerable<QuestionFormatRuleUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionFormatRuleCreateOrConnectWithoutQuestionInput>
    createMany?: QuestionFormatRuleCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuestionFormatRuleWhereUniqueInput>
  }

  export type QuestionFormatRuleCreateNestedManyWithoutQuestionAnswerRefInput = {
    create?: XOR<Enumerable<QuestionFormatRuleCreateWithoutQuestionAnswerRefInput>, Enumerable<QuestionFormatRuleUncheckedCreateWithoutQuestionAnswerRefInput>>
    connectOrCreate?: Enumerable<QuestionFormatRuleCreateOrConnectWithoutQuestionAnswerRefInput>
    createMany?: QuestionFormatRuleCreateManyQuestionAnswerRefInputEnvelope
    connect?: Enumerable<QuestionFormatRuleWhereUniqueInput>
  }

  export type AnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutQuestionInput>, Enumerable<AnswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutQuestionInput>
    createMany?: AnswerCreateManyQuestionInputEnvelope
    connect?: Enumerable<AnswerWhereUniqueInput>
  }

  export type OptionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<OptionCreateWithoutQuestionInput>, Enumerable<OptionUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<OptionCreateOrConnectWithoutQuestionInput>
    createMany?: OptionCreateManyQuestionInputEnvelope
    connect?: Enumerable<OptionWhereUniqueInput>
  }

  export type SubformUncheckedCreateNestedOneWithoutQuestionInput = {
    create?: XOR<SubformCreateWithoutQuestionInput, SubformUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: SubformCreateOrConnectWithoutQuestionInput
    connect?: SubformWhereUniqueInput
  }

  export type OptionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutQuestionAnswerRefInput>, Enumerable<OptionRuleUncheckedCreateWithoutQuestionAnswerRefInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutQuestionAnswerRefInput>
    createMany?: OptionRuleCreateManyQuestionAnswerRefInputEnvelope
    connect?: Enumerable<OptionRuleWhereUniqueInput>
  }

  export type QuestionRuleUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutQuestionInput>, Enumerable<QuestionRuleUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutQuestionInput>
    createMany?: QuestionRuleCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
  }

  export type QuestionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutQuestionAnswerRefInput>, Enumerable<QuestionRuleUncheckedCreateWithoutQuestionAnswerRefInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutQuestionAnswerRefInput>
    createMany?: QuestionRuleCreateManyQuestionAnswerRefInputEnvelope
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
  }

  export type QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<QuestionFormatRuleCreateWithoutQuestionInput>, Enumerable<QuestionFormatRuleUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionFormatRuleCreateOrConnectWithoutQuestionInput>
    createMany?: QuestionFormatRuleCreateManyQuestionInputEnvelope
    connect?: Enumerable<QuestionFormatRuleWhereUniqueInput>
  }

  export type QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput = {
    create?: XOR<Enumerable<QuestionFormatRuleCreateWithoutQuestionAnswerRefInput>, Enumerable<QuestionFormatRuleUncheckedCreateWithoutQuestionAnswerRefInput>>
    connectOrCreate?: Enumerable<QuestionFormatRuleCreateOrConnectWithoutQuestionAnswerRefInput>
    createMany?: QuestionFormatRuleCreateManyQuestionAnswerRefInputEnvelope
    connect?: Enumerable<QuestionFormatRuleWhereUniqueInput>
  }

  export type EnumQuestionTypeFieldUpdateOperationsInput = {
    set?: QuestionType
  }

  export type NullableEnumInputTypeFieldUpdateOperationsInput = {
    set?: InputType | null
  }

  export type AnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutQuestionInput>, Enumerable<AnswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: AnswerCreateManyQuestionInputEnvelope
    set?: Enumerable<AnswerWhereUniqueInput>
    disconnect?: Enumerable<AnswerWhereUniqueInput>
    delete?: Enumerable<AnswerWhereUniqueInput>
    connect?: Enumerable<AnswerWhereUniqueInput>
    update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<AnswerUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<AnswerScalarWhereInput>
  }

  export type OptionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<OptionCreateWithoutQuestionInput>, Enumerable<OptionUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<OptionCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<OptionUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: OptionCreateManyQuestionInputEnvelope
    set?: Enumerable<OptionWhereUniqueInput>
    disconnect?: Enumerable<OptionWhereUniqueInput>
    delete?: Enumerable<OptionWhereUniqueInput>
    connect?: Enumerable<OptionWhereUniqueInput>
    update?: Enumerable<OptionUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<OptionUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<OptionScalarWhereInput>
  }

  export type SubformUpdateOneWithoutQuestionNestedInput = {
    create?: XOR<SubformCreateWithoutQuestionInput, SubformUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: SubformCreateOrConnectWithoutQuestionInput
    upsert?: SubformUpsertWithoutQuestionInput
    disconnect?: boolean
    delete?: boolean
    connect?: SubformWhereUniqueInput
    update?: XOR<SubformUpdateWithoutQuestionInput, SubformUncheckedUpdateWithoutQuestionInput>
  }

  export type FormSectionUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<FormSectionCreateWithoutQuestionsInput, FormSectionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: FormSectionCreateOrConnectWithoutQuestionsInput
    upsert?: FormSectionUpsertWithoutQuestionsInput
    connect?: FormSectionWhereUniqueInput
    update?: XOR<FormSectionUpdateWithoutQuestionsInput, FormSectionUncheckedUpdateWithoutQuestionsInput>
  }

  export type OptionRuleUpdateManyWithoutQuestionAnswerRefNestedInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutQuestionAnswerRefInput>, Enumerable<OptionRuleUncheckedCreateWithoutQuestionAnswerRefInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutQuestionAnswerRefInput>
    upsert?: Enumerable<OptionRuleUpsertWithWhereUniqueWithoutQuestionAnswerRefInput>
    createMany?: OptionRuleCreateManyQuestionAnswerRefInputEnvelope
    set?: Enumerable<OptionRuleWhereUniqueInput>
    disconnect?: Enumerable<OptionRuleWhereUniqueInput>
    delete?: Enumerable<OptionRuleWhereUniqueInput>
    connect?: Enumerable<OptionRuleWhereUniqueInput>
    update?: Enumerable<OptionRuleUpdateWithWhereUniqueWithoutQuestionAnswerRefInput>
    updateMany?: Enumerable<OptionRuleUpdateManyWithWhereWithoutQuestionAnswerRefInput>
    deleteMany?: Enumerable<OptionRuleScalarWhereInput>
  }

  export type QuestionRuleUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutQuestionInput>, Enumerable<QuestionRuleUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuestionRuleUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuestionRuleCreateManyQuestionInputEnvelope
    set?: Enumerable<QuestionRuleWhereUniqueInput>
    disconnect?: Enumerable<QuestionRuleWhereUniqueInput>
    delete?: Enumerable<QuestionRuleWhereUniqueInput>
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
    update?: Enumerable<QuestionRuleUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuestionRuleUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuestionRuleScalarWhereInput>
  }

  export type QuestionRuleUpdateManyWithoutQuestionAnswerRefNestedInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutQuestionAnswerRefInput>, Enumerable<QuestionRuleUncheckedCreateWithoutQuestionAnswerRefInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutQuestionAnswerRefInput>
    upsert?: Enumerable<QuestionRuleUpsertWithWhereUniqueWithoutQuestionAnswerRefInput>
    createMany?: QuestionRuleCreateManyQuestionAnswerRefInputEnvelope
    set?: Enumerable<QuestionRuleWhereUniqueInput>
    disconnect?: Enumerable<QuestionRuleWhereUniqueInput>
    delete?: Enumerable<QuestionRuleWhereUniqueInput>
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
    update?: Enumerable<QuestionRuleUpdateWithWhereUniqueWithoutQuestionAnswerRefInput>
    updateMany?: Enumerable<QuestionRuleUpdateManyWithWhereWithoutQuestionAnswerRefInput>
    deleteMany?: Enumerable<QuestionRuleScalarWhereInput>
  }

  export type QuestionFormatRuleUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuestionFormatRuleCreateWithoutQuestionInput>, Enumerable<QuestionFormatRuleUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionFormatRuleCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuestionFormatRuleUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuestionFormatRuleCreateManyQuestionInputEnvelope
    set?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    disconnect?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    delete?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    connect?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    update?: Enumerable<QuestionFormatRuleUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuestionFormatRuleUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuestionFormatRuleScalarWhereInput>
  }

  export type QuestionFormatRuleUpdateManyWithoutQuestionAnswerRefNestedInput = {
    create?: XOR<Enumerable<QuestionFormatRuleCreateWithoutQuestionAnswerRefInput>, Enumerable<QuestionFormatRuleUncheckedCreateWithoutQuestionAnswerRefInput>>
    connectOrCreate?: Enumerable<QuestionFormatRuleCreateOrConnectWithoutQuestionAnswerRefInput>
    upsert?: Enumerable<QuestionFormatRuleUpsertWithWhereUniqueWithoutQuestionAnswerRefInput>
    createMany?: QuestionFormatRuleCreateManyQuestionAnswerRefInputEnvelope
    set?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    disconnect?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    delete?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    connect?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    update?: Enumerable<QuestionFormatRuleUpdateWithWhereUniqueWithoutQuestionAnswerRefInput>
    updateMany?: Enumerable<QuestionFormatRuleUpdateManyWithWhereWithoutQuestionAnswerRefInput>
    deleteMany?: Enumerable<QuestionFormatRuleScalarWhereInput>
  }

  export type AnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutQuestionInput>, Enumerable<AnswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: AnswerCreateManyQuestionInputEnvelope
    set?: Enumerable<AnswerWhereUniqueInput>
    disconnect?: Enumerable<AnswerWhereUniqueInput>
    delete?: Enumerable<AnswerWhereUniqueInput>
    connect?: Enumerable<AnswerWhereUniqueInput>
    update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<AnswerUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<AnswerScalarWhereInput>
  }

  export type OptionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<OptionCreateWithoutQuestionInput>, Enumerable<OptionUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<OptionCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<OptionUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: OptionCreateManyQuestionInputEnvelope
    set?: Enumerable<OptionWhereUniqueInput>
    disconnect?: Enumerable<OptionWhereUniqueInput>
    delete?: Enumerable<OptionWhereUniqueInput>
    connect?: Enumerable<OptionWhereUniqueInput>
    update?: Enumerable<OptionUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<OptionUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<OptionScalarWhereInput>
  }

  export type SubformUncheckedUpdateOneWithoutQuestionNestedInput = {
    create?: XOR<SubformCreateWithoutQuestionInput, SubformUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: SubformCreateOrConnectWithoutQuestionInput
    upsert?: SubformUpsertWithoutQuestionInput
    disconnect?: boolean
    delete?: boolean
    connect?: SubformWhereUniqueInput
    update?: XOR<SubformUpdateWithoutQuestionInput, SubformUncheckedUpdateWithoutQuestionInput>
  }

  export type OptionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutQuestionAnswerRefInput>, Enumerable<OptionRuleUncheckedCreateWithoutQuestionAnswerRefInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutQuestionAnswerRefInput>
    upsert?: Enumerable<OptionRuleUpsertWithWhereUniqueWithoutQuestionAnswerRefInput>
    createMany?: OptionRuleCreateManyQuestionAnswerRefInputEnvelope
    set?: Enumerable<OptionRuleWhereUniqueInput>
    disconnect?: Enumerable<OptionRuleWhereUniqueInput>
    delete?: Enumerable<OptionRuleWhereUniqueInput>
    connect?: Enumerable<OptionRuleWhereUniqueInput>
    update?: Enumerable<OptionRuleUpdateWithWhereUniqueWithoutQuestionAnswerRefInput>
    updateMany?: Enumerable<OptionRuleUpdateManyWithWhereWithoutQuestionAnswerRefInput>
    deleteMany?: Enumerable<OptionRuleScalarWhereInput>
  }

  export type QuestionRuleUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutQuestionInput>, Enumerable<QuestionRuleUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuestionRuleUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuestionRuleCreateManyQuestionInputEnvelope
    set?: Enumerable<QuestionRuleWhereUniqueInput>
    disconnect?: Enumerable<QuestionRuleWhereUniqueInput>
    delete?: Enumerable<QuestionRuleWhereUniqueInput>
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
    update?: Enumerable<QuestionRuleUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuestionRuleUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuestionRuleScalarWhereInput>
  }

  export type QuestionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutQuestionAnswerRefInput>, Enumerable<QuestionRuleUncheckedCreateWithoutQuestionAnswerRefInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutQuestionAnswerRefInput>
    upsert?: Enumerable<QuestionRuleUpsertWithWhereUniqueWithoutQuestionAnswerRefInput>
    createMany?: QuestionRuleCreateManyQuestionAnswerRefInputEnvelope
    set?: Enumerable<QuestionRuleWhereUniqueInput>
    disconnect?: Enumerable<QuestionRuleWhereUniqueInput>
    delete?: Enumerable<QuestionRuleWhereUniqueInput>
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
    update?: Enumerable<QuestionRuleUpdateWithWhereUniqueWithoutQuestionAnswerRefInput>
    updateMany?: Enumerable<QuestionRuleUpdateManyWithWhereWithoutQuestionAnswerRefInput>
    deleteMany?: Enumerable<QuestionRuleScalarWhereInput>
  }

  export type QuestionFormatRuleUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<QuestionFormatRuleCreateWithoutQuestionInput>, Enumerable<QuestionFormatRuleUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<QuestionFormatRuleCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<QuestionFormatRuleUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: QuestionFormatRuleCreateManyQuestionInputEnvelope
    set?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    disconnect?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    delete?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    connect?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    update?: Enumerable<QuestionFormatRuleUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<QuestionFormatRuleUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<QuestionFormatRuleScalarWhereInput>
  }

  export type QuestionFormatRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput = {
    create?: XOR<Enumerable<QuestionFormatRuleCreateWithoutQuestionAnswerRefInput>, Enumerable<QuestionFormatRuleUncheckedCreateWithoutQuestionAnswerRefInput>>
    connectOrCreate?: Enumerable<QuestionFormatRuleCreateOrConnectWithoutQuestionAnswerRefInput>
    upsert?: Enumerable<QuestionFormatRuleUpsertWithWhereUniqueWithoutQuestionAnswerRefInput>
    createMany?: QuestionFormatRuleCreateManyQuestionAnswerRefInputEnvelope
    set?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    disconnect?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    delete?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    connect?: Enumerable<QuestionFormatRuleWhereUniqueInput>
    update?: Enumerable<QuestionFormatRuleUpdateWithWhereUniqueWithoutQuestionAnswerRefInput>
    updateMany?: Enumerable<QuestionFormatRuleUpdateManyWithWhereWithoutQuestionAnswerRefInput>
    deleteMany?: Enumerable<QuestionFormatRuleScalarWhereInput>
  }

  export type QuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswersInput
    connect?: QuestionWhereUniqueInput
  }

  export type ClaimantCreateNestedOneWithoutAnswersInput = {
    create?: XOR<ClaimantCreateWithoutAnswersInput, ClaimantUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: ClaimantCreateOrConnectWithoutAnswersInput
    connect?: ClaimantWhereUniqueInput
  }

  export type OptionCreateNestedOneWithoutAnswerInput = {
    create?: XOR<OptionCreateWithoutAnswerInput, OptionUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: OptionCreateOrConnectWithoutAnswerInput
    connect?: OptionWhereUniqueInput
  }

  export type CallSessionCreateNestedOneWithoutAnswerInput = {
    create?: XOR<CallSessionCreateWithoutAnswerInput, CallSessionUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: CallSessionCreateOrConnectWithoutAnswerInput
    connect?: CallSessionWhereUniqueInput
  }

  export type QuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswersInput
    upsert?: QuestionUpsertWithoutAnswersInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<QuestionUpdateWithoutAnswersInput, QuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type ClaimantUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<ClaimantCreateWithoutAnswersInput, ClaimantUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: ClaimantCreateOrConnectWithoutAnswersInput
    upsert?: ClaimantUpsertWithoutAnswersInput
    connect?: ClaimantWhereUniqueInput
    update?: XOR<ClaimantUpdateWithoutAnswersInput, ClaimantUncheckedUpdateWithoutAnswersInput>
  }

  export type OptionUpdateOneWithoutAnswerNestedInput = {
    create?: XOR<OptionCreateWithoutAnswerInput, OptionUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: OptionCreateOrConnectWithoutAnswerInput
    upsert?: OptionUpsertWithoutAnswerInput
    disconnect?: boolean
    delete?: boolean
    connect?: OptionWhereUniqueInput
    update?: XOR<OptionUpdateWithoutAnswerInput, OptionUncheckedUpdateWithoutAnswerInput>
  }

  export type CallSessionUpdateOneRequiredWithoutAnswerNestedInput = {
    create?: XOR<CallSessionCreateWithoutAnswerInput, CallSessionUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: CallSessionCreateOrConnectWithoutAnswerInput
    upsert?: CallSessionUpsertWithoutAnswerInput
    connect?: CallSessionWhereUniqueInput
    update?: XOR<CallSessionUpdateWithoutAnswerInput, CallSessionUncheckedUpdateWithoutAnswerInput>
  }

  export type SubformFieldCreateNestedManyWithoutSubFormInput = {
    create?: XOR<Enumerable<SubformFieldCreateWithoutSubFormInput>, Enumerable<SubformFieldUncheckedCreateWithoutSubFormInput>>
    connectOrCreate?: Enumerable<SubformFieldCreateOrConnectWithoutSubFormInput>
    createMany?: SubformFieldCreateManySubFormInputEnvelope
    connect?: Enumerable<SubformFieldWhereUniqueInput>
  }

  export type QuestionCreateNestedOneWithoutSubformInput = {
    create?: XOR<QuestionCreateWithoutSubformInput, QuestionUncheckedCreateWithoutSubformInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutSubformInput
    connect?: QuestionWhereUniqueInput
  }

  export type SubformFieldUncheckedCreateNestedManyWithoutSubFormInput = {
    create?: XOR<Enumerable<SubformFieldCreateWithoutSubFormInput>, Enumerable<SubformFieldUncheckedCreateWithoutSubFormInput>>
    connectOrCreate?: Enumerable<SubformFieldCreateOrConnectWithoutSubFormInput>
    createMany?: SubformFieldCreateManySubFormInputEnvelope
    connect?: Enumerable<SubformFieldWhereUniqueInput>
  }

  export type SubformFieldUpdateManyWithoutSubFormNestedInput = {
    create?: XOR<Enumerable<SubformFieldCreateWithoutSubFormInput>, Enumerable<SubformFieldUncheckedCreateWithoutSubFormInput>>
    connectOrCreate?: Enumerable<SubformFieldCreateOrConnectWithoutSubFormInput>
    upsert?: Enumerable<SubformFieldUpsertWithWhereUniqueWithoutSubFormInput>
    createMany?: SubformFieldCreateManySubFormInputEnvelope
    set?: Enumerable<SubformFieldWhereUniqueInput>
    disconnect?: Enumerable<SubformFieldWhereUniqueInput>
    delete?: Enumerable<SubformFieldWhereUniqueInput>
    connect?: Enumerable<SubformFieldWhereUniqueInput>
    update?: Enumerable<SubformFieldUpdateWithWhereUniqueWithoutSubFormInput>
    updateMany?: Enumerable<SubformFieldUpdateManyWithWhereWithoutSubFormInput>
    deleteMany?: Enumerable<SubformFieldScalarWhereInput>
  }

  export type QuestionUpdateOneRequiredWithoutSubformNestedInput = {
    create?: XOR<QuestionCreateWithoutSubformInput, QuestionUncheckedCreateWithoutSubformInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutSubformInput
    upsert?: QuestionUpsertWithoutSubformInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<QuestionUpdateWithoutSubformInput, QuestionUncheckedUpdateWithoutSubformInput>
  }

  export type SubformFieldUncheckedUpdateManyWithoutSubFormNestedInput = {
    create?: XOR<Enumerable<SubformFieldCreateWithoutSubFormInput>, Enumerable<SubformFieldUncheckedCreateWithoutSubFormInput>>
    connectOrCreate?: Enumerable<SubformFieldCreateOrConnectWithoutSubFormInput>
    upsert?: Enumerable<SubformFieldUpsertWithWhereUniqueWithoutSubFormInput>
    createMany?: SubformFieldCreateManySubFormInputEnvelope
    set?: Enumerable<SubformFieldWhereUniqueInput>
    disconnect?: Enumerable<SubformFieldWhereUniqueInput>
    delete?: Enumerable<SubformFieldWhereUniqueInput>
    connect?: Enumerable<SubformFieldWhereUniqueInput>
    update?: Enumerable<SubformFieldUpdateWithWhereUniqueWithoutSubFormInput>
    updateMany?: Enumerable<SubformFieldUpdateManyWithWhereWithoutSubFormInput>
    deleteMany?: Enumerable<SubformFieldScalarWhereInput>
  }

  export type SubformFieldOptionCreateNestedManyWithoutSubformFieldInput = {
    create?: XOR<Enumerable<SubformFieldOptionCreateWithoutSubformFieldInput>, Enumerable<SubformFieldOptionUncheckedCreateWithoutSubformFieldInput>>
    connectOrCreate?: Enumerable<SubformFieldOptionCreateOrConnectWithoutSubformFieldInput>
    createMany?: SubformFieldOptionCreateManySubformFieldInputEnvelope
    connect?: Enumerable<SubformFieldOptionWhereUniqueInput>
  }

  export type SubformFieldAnswerCreateNestedManyWithoutSubformFieldInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutSubformFieldInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutSubformFieldInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutSubformFieldInput>
    createMany?: SubformFieldAnswerCreateManySubformFieldInputEnvelope
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
  }

  export type SubformCreateNestedOneWithoutSubformFieldsInput = {
    create?: XOR<SubformCreateWithoutSubformFieldsInput, SubformUncheckedCreateWithoutSubformFieldsInput>
    connectOrCreate?: SubformCreateOrConnectWithoutSubformFieldsInput
    connect?: SubformWhereUniqueInput
  }

  export type SubformFieldOptionUncheckedCreateNestedManyWithoutSubformFieldInput = {
    create?: XOR<Enumerable<SubformFieldOptionCreateWithoutSubformFieldInput>, Enumerable<SubformFieldOptionUncheckedCreateWithoutSubformFieldInput>>
    connectOrCreate?: Enumerable<SubformFieldOptionCreateOrConnectWithoutSubformFieldInput>
    createMany?: SubformFieldOptionCreateManySubformFieldInputEnvelope
    connect?: Enumerable<SubformFieldOptionWhereUniqueInput>
  }

  export type SubformFieldAnswerUncheckedCreateNestedManyWithoutSubformFieldInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutSubformFieldInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutSubformFieldInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutSubformFieldInput>
    createMany?: SubformFieldAnswerCreateManySubformFieldInputEnvelope
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
  }

  export type EnumSubFormFieldTypeFieldUpdateOperationsInput = {
    set?: SubFormFieldType
  }

  export type SubformFieldOptionUpdateManyWithoutSubformFieldNestedInput = {
    create?: XOR<Enumerable<SubformFieldOptionCreateWithoutSubformFieldInput>, Enumerable<SubformFieldOptionUncheckedCreateWithoutSubformFieldInput>>
    connectOrCreate?: Enumerable<SubformFieldOptionCreateOrConnectWithoutSubformFieldInput>
    upsert?: Enumerable<SubformFieldOptionUpsertWithWhereUniqueWithoutSubformFieldInput>
    createMany?: SubformFieldOptionCreateManySubformFieldInputEnvelope
    set?: Enumerable<SubformFieldOptionWhereUniqueInput>
    disconnect?: Enumerable<SubformFieldOptionWhereUniqueInput>
    delete?: Enumerable<SubformFieldOptionWhereUniqueInput>
    connect?: Enumerable<SubformFieldOptionWhereUniqueInput>
    update?: Enumerable<SubformFieldOptionUpdateWithWhereUniqueWithoutSubformFieldInput>
    updateMany?: Enumerable<SubformFieldOptionUpdateManyWithWhereWithoutSubformFieldInput>
    deleteMany?: Enumerable<SubformFieldOptionScalarWhereInput>
  }

  export type SubformFieldAnswerUpdateManyWithoutSubformFieldNestedInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutSubformFieldInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutSubformFieldInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutSubformFieldInput>
    upsert?: Enumerable<SubformFieldAnswerUpsertWithWhereUniqueWithoutSubformFieldInput>
    createMany?: SubformFieldAnswerCreateManySubformFieldInputEnvelope
    set?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    disconnect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    delete?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    update?: Enumerable<SubformFieldAnswerUpdateWithWhereUniqueWithoutSubformFieldInput>
    updateMany?: Enumerable<SubformFieldAnswerUpdateManyWithWhereWithoutSubformFieldInput>
    deleteMany?: Enumerable<SubformFieldAnswerScalarWhereInput>
  }

  export type SubformUpdateOneRequiredWithoutSubformFieldsNestedInput = {
    create?: XOR<SubformCreateWithoutSubformFieldsInput, SubformUncheckedCreateWithoutSubformFieldsInput>
    connectOrCreate?: SubformCreateOrConnectWithoutSubformFieldsInput
    upsert?: SubformUpsertWithoutSubformFieldsInput
    connect?: SubformWhereUniqueInput
    update?: XOR<SubformUpdateWithoutSubformFieldsInput, SubformUncheckedUpdateWithoutSubformFieldsInput>
  }

  export type SubformFieldOptionUncheckedUpdateManyWithoutSubformFieldNestedInput = {
    create?: XOR<Enumerable<SubformFieldOptionCreateWithoutSubformFieldInput>, Enumerable<SubformFieldOptionUncheckedCreateWithoutSubformFieldInput>>
    connectOrCreate?: Enumerable<SubformFieldOptionCreateOrConnectWithoutSubformFieldInput>
    upsert?: Enumerable<SubformFieldOptionUpsertWithWhereUniqueWithoutSubformFieldInput>
    createMany?: SubformFieldOptionCreateManySubformFieldInputEnvelope
    set?: Enumerable<SubformFieldOptionWhereUniqueInput>
    disconnect?: Enumerable<SubformFieldOptionWhereUniqueInput>
    delete?: Enumerable<SubformFieldOptionWhereUniqueInput>
    connect?: Enumerable<SubformFieldOptionWhereUniqueInput>
    update?: Enumerable<SubformFieldOptionUpdateWithWhereUniqueWithoutSubformFieldInput>
    updateMany?: Enumerable<SubformFieldOptionUpdateManyWithWhereWithoutSubformFieldInput>
    deleteMany?: Enumerable<SubformFieldOptionScalarWhereInput>
  }

  export type SubformFieldAnswerUncheckedUpdateManyWithoutSubformFieldNestedInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutSubformFieldInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutSubformFieldInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutSubformFieldInput>
    upsert?: Enumerable<SubformFieldAnswerUpsertWithWhereUniqueWithoutSubformFieldInput>
    createMany?: SubformFieldAnswerCreateManySubformFieldInputEnvelope
    set?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    disconnect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    delete?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    update?: Enumerable<SubformFieldAnswerUpdateWithWhereUniqueWithoutSubformFieldInput>
    updateMany?: Enumerable<SubformFieldAnswerUpdateManyWithWhereWithoutSubformFieldInput>
    deleteMany?: Enumerable<SubformFieldAnswerScalarWhereInput>
  }

  export type SubformFieldAnswerCreateNestedManyWithoutSubformFieldOpionInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutSubformFieldOpionInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutSubformFieldOpionInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutSubformFieldOpionInput>
    createMany?: SubformFieldAnswerCreateManySubformFieldOpionInputEnvelope
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
  }

  export type SubformFieldCreateNestedOneWithoutSubformFieldOptionsInput = {
    create?: XOR<SubformFieldCreateWithoutSubformFieldOptionsInput, SubformFieldUncheckedCreateWithoutSubformFieldOptionsInput>
    connectOrCreate?: SubformFieldCreateOrConnectWithoutSubformFieldOptionsInput
    connect?: SubformFieldWhereUniqueInput
  }

  export type SubformFieldAnswerUncheckedCreateNestedManyWithoutSubformFieldOpionInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutSubformFieldOpionInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutSubformFieldOpionInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutSubformFieldOpionInput>
    createMany?: SubformFieldAnswerCreateManySubformFieldOpionInputEnvelope
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
  }

  export type SubformFieldAnswerUpdateManyWithoutSubformFieldOpionNestedInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutSubformFieldOpionInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutSubformFieldOpionInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutSubformFieldOpionInput>
    upsert?: Enumerable<SubformFieldAnswerUpsertWithWhereUniqueWithoutSubformFieldOpionInput>
    createMany?: SubformFieldAnswerCreateManySubformFieldOpionInputEnvelope
    set?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    disconnect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    delete?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    update?: Enumerable<SubformFieldAnswerUpdateWithWhereUniqueWithoutSubformFieldOpionInput>
    updateMany?: Enumerable<SubformFieldAnswerUpdateManyWithWhereWithoutSubformFieldOpionInput>
    deleteMany?: Enumerable<SubformFieldAnswerScalarWhereInput>
  }

  export type SubformFieldUpdateOneRequiredWithoutSubformFieldOptionsNestedInput = {
    create?: XOR<SubformFieldCreateWithoutSubformFieldOptionsInput, SubformFieldUncheckedCreateWithoutSubformFieldOptionsInput>
    connectOrCreate?: SubformFieldCreateOrConnectWithoutSubformFieldOptionsInput
    upsert?: SubformFieldUpsertWithoutSubformFieldOptionsInput
    connect?: SubformFieldWhereUniqueInput
    update?: XOR<SubformFieldUpdateWithoutSubformFieldOptionsInput, SubformFieldUncheckedUpdateWithoutSubformFieldOptionsInput>
  }

  export type SubformFieldAnswerUncheckedUpdateManyWithoutSubformFieldOpionNestedInput = {
    create?: XOR<Enumerable<SubformFieldAnswerCreateWithoutSubformFieldOpionInput>, Enumerable<SubformFieldAnswerUncheckedCreateWithoutSubformFieldOpionInput>>
    connectOrCreate?: Enumerable<SubformFieldAnswerCreateOrConnectWithoutSubformFieldOpionInput>
    upsert?: Enumerable<SubformFieldAnswerUpsertWithWhereUniqueWithoutSubformFieldOpionInput>
    createMany?: SubformFieldAnswerCreateManySubformFieldOpionInputEnvelope
    set?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    disconnect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    delete?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    connect?: Enumerable<SubformFieldAnswerWhereUniqueInput>
    update?: Enumerable<SubformFieldAnswerUpdateWithWhereUniqueWithoutSubformFieldOpionInput>
    updateMany?: Enumerable<SubformFieldAnswerUpdateManyWithWhereWithoutSubformFieldOpionInput>
    deleteMany?: Enumerable<SubformFieldAnswerScalarWhereInput>
  }

  export type SubformFieldCreateNestedOneWithoutSubformFieldAnswerInput = {
    create?: XOR<SubformFieldCreateWithoutSubformFieldAnswerInput, SubformFieldUncheckedCreateWithoutSubformFieldAnswerInput>
    connectOrCreate?: SubformFieldCreateOrConnectWithoutSubformFieldAnswerInput
    connect?: SubformFieldWhereUniqueInput
  }

  export type SubformFieldOptionCreateNestedOneWithoutSubformFieldAnswerInput = {
    create?: XOR<SubformFieldOptionCreateWithoutSubformFieldAnswerInput, SubformFieldOptionUncheckedCreateWithoutSubformFieldAnswerInput>
    connectOrCreate?: SubformFieldOptionCreateOrConnectWithoutSubformFieldAnswerInput
    connect?: SubformFieldOptionWhereUniqueInput
  }

  export type ClaimantCreateNestedOneWithoutSubformFieldAnswerInput = {
    create?: XOR<ClaimantCreateWithoutSubformFieldAnswerInput, ClaimantUncheckedCreateWithoutSubformFieldAnswerInput>
    connectOrCreate?: ClaimantCreateOrConnectWithoutSubformFieldAnswerInput
    connect?: ClaimantWhereUniqueInput
  }

  export type CallSessionCreateNestedOneWithoutSubformFieldAnswerInput = {
    create?: XOR<CallSessionCreateWithoutSubformFieldAnswerInput, CallSessionUncheckedCreateWithoutSubformFieldAnswerInput>
    connectOrCreate?: CallSessionCreateOrConnectWithoutSubformFieldAnswerInput
    connect?: CallSessionWhereUniqueInput
  }

  export type SubformFieldUpdateOneRequiredWithoutSubformFieldAnswerNestedInput = {
    create?: XOR<SubformFieldCreateWithoutSubformFieldAnswerInput, SubformFieldUncheckedCreateWithoutSubformFieldAnswerInput>
    connectOrCreate?: SubformFieldCreateOrConnectWithoutSubformFieldAnswerInput
    upsert?: SubformFieldUpsertWithoutSubformFieldAnswerInput
    connect?: SubformFieldWhereUniqueInput
    update?: XOR<SubformFieldUpdateWithoutSubformFieldAnswerInput, SubformFieldUncheckedUpdateWithoutSubformFieldAnswerInput>
  }

  export type SubformFieldOptionUpdateOneWithoutSubformFieldAnswerNestedInput = {
    create?: XOR<SubformFieldOptionCreateWithoutSubformFieldAnswerInput, SubformFieldOptionUncheckedCreateWithoutSubformFieldAnswerInput>
    connectOrCreate?: SubformFieldOptionCreateOrConnectWithoutSubformFieldAnswerInput
    upsert?: SubformFieldOptionUpsertWithoutSubformFieldAnswerInput
    disconnect?: boolean
    delete?: boolean
    connect?: SubformFieldOptionWhereUniqueInput
    update?: XOR<SubformFieldOptionUpdateWithoutSubformFieldAnswerInput, SubformFieldOptionUncheckedUpdateWithoutSubformFieldAnswerInput>
  }

  export type ClaimantUpdateOneRequiredWithoutSubformFieldAnswerNestedInput = {
    create?: XOR<ClaimantCreateWithoutSubformFieldAnswerInput, ClaimantUncheckedCreateWithoutSubformFieldAnswerInput>
    connectOrCreate?: ClaimantCreateOrConnectWithoutSubformFieldAnswerInput
    upsert?: ClaimantUpsertWithoutSubformFieldAnswerInput
    connect?: ClaimantWhereUniqueInput
    update?: XOR<ClaimantUpdateWithoutSubformFieldAnswerInput, ClaimantUncheckedUpdateWithoutSubformFieldAnswerInput>
  }

  export type CallSessionUpdateOneRequiredWithoutSubformFieldAnswerNestedInput = {
    create?: XOR<CallSessionCreateWithoutSubformFieldAnswerInput, CallSessionUncheckedCreateWithoutSubformFieldAnswerInput>
    connectOrCreate?: CallSessionCreateOrConnectWithoutSubformFieldAnswerInput
    upsert?: CallSessionUpsertWithoutSubformFieldAnswerInput
    connect?: CallSessionWhereUniqueInput
    update?: XOR<CallSessionUpdateWithoutSubformFieldAnswerInput, CallSessionUncheckedUpdateWithoutSubformFieldAnswerInput>
  }

  export type ClaimantCreateNestedOneWithoutCursorInput = {
    create?: XOR<ClaimantCreateWithoutCursorInput, ClaimantUncheckedCreateWithoutCursorInput>
    connectOrCreate?: ClaimantCreateOrConnectWithoutCursorInput
    connect?: ClaimantWhereUniqueInput
  }

  export type FormSectionCreateNestedOneWithoutCursorInput = {
    create?: XOR<FormSectionCreateWithoutCursorInput, FormSectionUncheckedCreateWithoutCursorInput>
    connectOrCreate?: FormSectionCreateOrConnectWithoutCursorInput
    connect?: FormSectionWhereUniqueInput
  }

  export type ClaimantUpdateOneRequiredWithoutCursorNestedInput = {
    create?: XOR<ClaimantCreateWithoutCursorInput, ClaimantUncheckedCreateWithoutCursorInput>
    connectOrCreate?: ClaimantCreateOrConnectWithoutCursorInput
    upsert?: ClaimantUpsertWithoutCursorInput
    connect?: ClaimantWhereUniqueInput
    update?: XOR<ClaimantUpdateWithoutCursorInput, ClaimantUncheckedUpdateWithoutCursorInput>
  }

  export type FormSectionUpdateOneRequiredWithoutCursorNestedInput = {
    create?: XOR<FormSectionCreateWithoutCursorInput, FormSectionUncheckedCreateWithoutCursorInput>
    connectOrCreate?: FormSectionCreateOrConnectWithoutCursorInput
    upsert?: FormSectionUpsertWithoutCursorInput
    connect?: FormSectionWhereUniqueInput
    update?: XOR<FormSectionUpdateWithoutCursorInput, FormSectionUncheckedUpdateWithoutCursorInput>
  }

  export type OptionRuleCreateNestedManyWithoutOptionInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutOptionInput>, Enumerable<OptionRuleUncheckedCreateWithoutOptionInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutOptionInput>
    createMany?: OptionRuleCreateManyOptionInputEnvelope
    connect?: Enumerable<OptionRuleWhereUniqueInput>
  }

  export type AnswerCreateNestedManyWithoutOptionInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutOptionInput>, Enumerable<AnswerUncheckedCreateWithoutOptionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutOptionInput>
    createMany?: AnswerCreateManyOptionInputEnvelope
    connect?: Enumerable<AnswerWhereUniqueInput>
  }

  export type QuestionCreateNestedOneWithoutOptionsInput = {
    create?: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutOptionsInput
    connect?: QuestionWhereUniqueInput
  }

  export type OptionRuleUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutOptionInput>, Enumerable<OptionRuleUncheckedCreateWithoutOptionInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutOptionInput>
    createMany?: OptionRuleCreateManyOptionInputEnvelope
    connect?: Enumerable<OptionRuleWhereUniqueInput>
  }

  export type AnswerUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutOptionInput>, Enumerable<AnswerUncheckedCreateWithoutOptionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutOptionInput>
    createMany?: AnswerCreateManyOptionInputEnvelope
    connect?: Enumerable<AnswerWhereUniqueInput>
  }

  export type OptionRuleUpdateManyWithoutOptionNestedInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutOptionInput>, Enumerable<OptionRuleUncheckedCreateWithoutOptionInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutOptionInput>
    upsert?: Enumerable<OptionRuleUpsertWithWhereUniqueWithoutOptionInput>
    createMany?: OptionRuleCreateManyOptionInputEnvelope
    set?: Enumerable<OptionRuleWhereUniqueInput>
    disconnect?: Enumerable<OptionRuleWhereUniqueInput>
    delete?: Enumerable<OptionRuleWhereUniqueInput>
    connect?: Enumerable<OptionRuleWhereUniqueInput>
    update?: Enumerable<OptionRuleUpdateWithWhereUniqueWithoutOptionInput>
    updateMany?: Enumerable<OptionRuleUpdateManyWithWhereWithoutOptionInput>
    deleteMany?: Enumerable<OptionRuleScalarWhereInput>
  }

  export type AnswerUpdateManyWithoutOptionNestedInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutOptionInput>, Enumerable<AnswerUncheckedCreateWithoutOptionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutOptionInput>
    upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutOptionInput>
    createMany?: AnswerCreateManyOptionInputEnvelope
    set?: Enumerable<AnswerWhereUniqueInput>
    disconnect?: Enumerable<AnswerWhereUniqueInput>
    delete?: Enumerable<AnswerWhereUniqueInput>
    connect?: Enumerable<AnswerWhereUniqueInput>
    update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutOptionInput>
    updateMany?: Enumerable<AnswerUpdateManyWithWhereWithoutOptionInput>
    deleteMany?: Enumerable<AnswerScalarWhereInput>
  }

  export type QuestionUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutOptionsInput
    upsert?: QuestionUpsertWithoutOptionsInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<QuestionUpdateWithoutOptionsInput, QuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type OptionRuleUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutOptionInput>, Enumerable<OptionRuleUncheckedCreateWithoutOptionInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutOptionInput>
    upsert?: Enumerable<OptionRuleUpsertWithWhereUniqueWithoutOptionInput>
    createMany?: OptionRuleCreateManyOptionInputEnvelope
    set?: Enumerable<OptionRuleWhereUniqueInput>
    disconnect?: Enumerable<OptionRuleWhereUniqueInput>
    delete?: Enumerable<OptionRuleWhereUniqueInput>
    connect?: Enumerable<OptionRuleWhereUniqueInput>
    update?: Enumerable<OptionRuleUpdateWithWhereUniqueWithoutOptionInput>
    updateMany?: Enumerable<OptionRuleUpdateManyWithWhereWithoutOptionInput>
    deleteMany?: Enumerable<OptionRuleScalarWhereInput>
  }

  export type AnswerUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<Enumerable<AnswerCreateWithoutOptionInput>, Enumerable<AnswerUncheckedCreateWithoutOptionInput>>
    connectOrCreate?: Enumerable<AnswerCreateOrConnectWithoutOptionInput>
    upsert?: Enumerable<AnswerUpsertWithWhereUniqueWithoutOptionInput>
    createMany?: AnswerCreateManyOptionInputEnvelope
    set?: Enumerable<AnswerWhereUniqueInput>
    disconnect?: Enumerable<AnswerWhereUniqueInput>
    delete?: Enumerable<AnswerWhereUniqueInput>
    connect?: Enumerable<AnswerWhereUniqueInput>
    update?: Enumerable<AnswerUpdateWithWhereUniqueWithoutOptionInput>
    updateMany?: Enumerable<AnswerUpdateManyWithWhereWithoutOptionInput>
    deleteMany?: Enumerable<AnswerScalarWhereInput>
  }

  export type OptionCreateNestedOneWithoutRulesInput = {
    create?: XOR<OptionCreateWithoutRulesInput, OptionUncheckedCreateWithoutRulesInput>
    connectOrCreate?: OptionCreateOrConnectWithoutRulesInput
    connect?: OptionWhereUniqueInput
  }

  export type QuestionCreateNestedOneWithoutOptionRuleInput = {
    create?: XOR<QuestionCreateWithoutOptionRuleInput, QuestionUncheckedCreateWithoutOptionRuleInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutOptionRuleInput
    connect?: QuestionWhereUniqueInput
  }

  export type FunctionCreateNestedOneWithoutOptionRuleInput = {
    create?: XOR<FunctionCreateWithoutOptionRuleInput, FunctionUncheckedCreateWithoutOptionRuleInput>
    connectOrCreate?: FunctionCreateOrConnectWithoutOptionRuleInput
    connect?: FunctionWhereUniqueInput
  }

  export type SSAStatusCreateNestedOneWithoutOptionRuleInput = {
    create?: XOR<SSAStatusCreateWithoutOptionRuleInput, SSAStatusUncheckedCreateWithoutOptionRuleInput>
    connectOrCreate?: SSAStatusCreateOrConnectWithoutOptionRuleInput
    connect?: SSAStatusWhereUniqueInput
  }

  export type EnumRuleTypeFieldUpdateOperationsInput = {
    set?: RuleType
  }

  export type NullableEnumOperatorOptionFieldUpdateOperationsInput = {
    set?: OperatorOption | null
  }

  export type NullableEnumReferrerPayTypesFieldUpdateOperationsInput = {
    set?: ReferrerPayTypes | null
  }

  export type OptionUpdateOneWithoutRulesNestedInput = {
    create?: XOR<OptionCreateWithoutRulesInput, OptionUncheckedCreateWithoutRulesInput>
    connectOrCreate?: OptionCreateOrConnectWithoutRulesInput
    upsert?: OptionUpsertWithoutRulesInput
    disconnect?: boolean
    delete?: boolean
    connect?: OptionWhereUniqueInput
    update?: XOR<OptionUpdateWithoutRulesInput, OptionUncheckedUpdateWithoutRulesInput>
  }

  export type QuestionUpdateOneWithoutOptionRuleNestedInput = {
    create?: XOR<QuestionCreateWithoutOptionRuleInput, QuestionUncheckedCreateWithoutOptionRuleInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutOptionRuleInput
    upsert?: QuestionUpsertWithoutOptionRuleInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuestionWhereUniqueInput
    update?: XOR<QuestionUpdateWithoutOptionRuleInput, QuestionUncheckedUpdateWithoutOptionRuleInput>
  }

  export type FunctionUpdateOneWithoutOptionRuleNestedInput = {
    create?: XOR<FunctionCreateWithoutOptionRuleInput, FunctionUncheckedCreateWithoutOptionRuleInput>
    connectOrCreate?: FunctionCreateOrConnectWithoutOptionRuleInput
    upsert?: FunctionUpsertWithoutOptionRuleInput
    disconnect?: boolean
    delete?: boolean
    connect?: FunctionWhereUniqueInput
    update?: XOR<FunctionUpdateWithoutOptionRuleInput, FunctionUncheckedUpdateWithoutOptionRuleInput>
  }

  export type SSAStatusUpdateOneWithoutOptionRuleNestedInput = {
    create?: XOR<SSAStatusCreateWithoutOptionRuleInput, SSAStatusUncheckedCreateWithoutOptionRuleInput>
    connectOrCreate?: SSAStatusCreateOrConnectWithoutOptionRuleInput
    upsert?: SSAStatusUpsertWithoutOptionRuleInput
    disconnect?: boolean
    delete?: boolean
    connect?: SSAStatusWhereUniqueInput
    update?: XOR<SSAStatusUpdateWithoutOptionRuleInput, SSAStatusUncheckedUpdateWithoutOptionRuleInput>
  }

  export type QuestionCreateNestedOneWithoutRulesInput = {
    create?: XOR<QuestionCreateWithoutRulesInput, QuestionUncheckedCreateWithoutRulesInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutRulesInput
    connect?: QuestionWhereUniqueInput
  }

  export type QuestionCreateNestedOneWithoutQuestionAnswerRefInput = {
    create?: XOR<QuestionCreateWithoutQuestionAnswerRefInput, QuestionUncheckedCreateWithoutQuestionAnswerRefInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutQuestionAnswerRefInput
    connect?: QuestionWhereUniqueInput
  }

  export type FunctionCreateNestedOneWithoutQuestionRuleInput = {
    create?: XOR<FunctionCreateWithoutQuestionRuleInput, FunctionUncheckedCreateWithoutQuestionRuleInput>
    connectOrCreate?: FunctionCreateOrConnectWithoutQuestionRuleInput
    connect?: FunctionWhereUniqueInput
  }

  export type SSAStatusCreateNestedOneWithoutQuestionRuleInput = {
    create?: XOR<SSAStatusCreateWithoutQuestionRuleInput, SSAStatusUncheckedCreateWithoutQuestionRuleInput>
    connectOrCreate?: SSAStatusCreateOrConnectWithoutQuestionRuleInput
    connect?: SSAStatusWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type QuestionUpdateOneWithoutRulesNestedInput = {
    create?: XOR<QuestionCreateWithoutRulesInput, QuestionUncheckedCreateWithoutRulesInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutRulesInput
    upsert?: QuestionUpsertWithoutRulesInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuestionWhereUniqueInput
    update?: XOR<QuestionUpdateWithoutRulesInput, QuestionUncheckedUpdateWithoutRulesInput>
  }

  export type QuestionUpdateOneWithoutQuestionAnswerRefNestedInput = {
    create?: XOR<QuestionCreateWithoutQuestionAnswerRefInput, QuestionUncheckedCreateWithoutQuestionAnswerRefInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutQuestionAnswerRefInput
    upsert?: QuestionUpsertWithoutQuestionAnswerRefInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuestionWhereUniqueInput
    update?: XOR<QuestionUpdateWithoutQuestionAnswerRefInput, QuestionUncheckedUpdateWithoutQuestionAnswerRefInput>
  }

  export type FunctionUpdateOneWithoutQuestionRuleNestedInput = {
    create?: XOR<FunctionCreateWithoutQuestionRuleInput, FunctionUncheckedCreateWithoutQuestionRuleInput>
    connectOrCreate?: FunctionCreateOrConnectWithoutQuestionRuleInput
    upsert?: FunctionUpsertWithoutQuestionRuleInput
    disconnect?: boolean
    delete?: boolean
    connect?: FunctionWhereUniqueInput
    update?: XOR<FunctionUpdateWithoutQuestionRuleInput, FunctionUncheckedUpdateWithoutQuestionRuleInput>
  }

  export type SSAStatusUpdateOneWithoutQuestionRuleNestedInput = {
    create?: XOR<SSAStatusCreateWithoutQuestionRuleInput, SSAStatusUncheckedCreateWithoutQuestionRuleInput>
    connectOrCreate?: SSAStatusCreateOrConnectWithoutQuestionRuleInput
    upsert?: SSAStatusUpsertWithoutQuestionRuleInput
    disconnect?: boolean
    delete?: boolean
    connect?: SSAStatusWhereUniqueInput
    update?: XOR<SSAStatusUpdateWithoutQuestionRuleInput, SSAStatusUncheckedUpdateWithoutQuestionRuleInput>
  }

  export type QuestionCreateNestedOneWithoutQuestionFormatRuleInput = {
    create?: XOR<QuestionCreateWithoutQuestionFormatRuleInput, QuestionUncheckedCreateWithoutQuestionFormatRuleInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutQuestionFormatRuleInput
    connect?: QuestionWhereUniqueInput
  }

  export type QuestionCreateNestedOneWithoutQuestionFormatAnswerRefInput = {
    create?: XOR<QuestionCreateWithoutQuestionFormatAnswerRefInput, QuestionUncheckedCreateWithoutQuestionFormatAnswerRefInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutQuestionFormatAnswerRefInput
    connect?: QuestionWhereUniqueInput
  }

  export type EnumQuestionFormatTypesFieldUpdateOperationsInput = {
    set?: QuestionFormatTypes
  }

  export type NullableEnumClaimantFieldRefTypesFieldUpdateOperationsInput = {
    set?: ClaimantFieldRefTypes | null
  }

  export type QuestionUpdateOneWithoutQuestionFormatRuleNestedInput = {
    create?: XOR<QuestionCreateWithoutQuestionFormatRuleInput, QuestionUncheckedCreateWithoutQuestionFormatRuleInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutQuestionFormatRuleInput
    upsert?: QuestionUpsertWithoutQuestionFormatRuleInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuestionWhereUniqueInput
    update?: XOR<QuestionUpdateWithoutQuestionFormatRuleInput, QuestionUncheckedUpdateWithoutQuestionFormatRuleInput>
  }

  export type QuestionUpdateOneWithoutQuestionFormatAnswerRefNestedInput = {
    create?: XOR<QuestionCreateWithoutQuestionFormatAnswerRefInput, QuestionUncheckedCreateWithoutQuestionFormatAnswerRefInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutQuestionFormatAnswerRefInput
    upsert?: QuestionUpsertWithoutQuestionFormatAnswerRefInput
    disconnect?: boolean
    delete?: boolean
    connect?: QuestionWhereUniqueInput
    update?: XOR<QuestionUpdateWithoutQuestionFormatAnswerRefInput, QuestionUncheckedUpdateWithoutQuestionFormatAnswerRefInput>
  }

  export type QuestionRuleCreateNestedManyWithoutFunctionInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutFunctionInput>, Enumerable<QuestionRuleUncheckedCreateWithoutFunctionInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutFunctionInput>
    createMany?: QuestionRuleCreateManyFunctionInputEnvelope
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
  }

  export type OptionRuleCreateNestedManyWithoutFunctionInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutFunctionInput>, Enumerable<OptionRuleUncheckedCreateWithoutFunctionInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutFunctionInput>
    createMany?: OptionRuleCreateManyFunctionInputEnvelope
    connect?: Enumerable<OptionRuleWhereUniqueInput>
  }

  export type QuestionRuleUncheckedCreateNestedManyWithoutFunctionInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutFunctionInput>, Enumerable<QuestionRuleUncheckedCreateWithoutFunctionInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutFunctionInput>
    createMany?: QuestionRuleCreateManyFunctionInputEnvelope
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
  }

  export type OptionRuleUncheckedCreateNestedManyWithoutFunctionInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutFunctionInput>, Enumerable<OptionRuleUncheckedCreateWithoutFunctionInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutFunctionInput>
    createMany?: OptionRuleCreateManyFunctionInputEnvelope
    connect?: Enumerable<OptionRuleWhereUniqueInput>
  }

  export type QuestionRuleUpdateManyWithoutFunctionNestedInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutFunctionInput>, Enumerable<QuestionRuleUncheckedCreateWithoutFunctionInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutFunctionInput>
    upsert?: Enumerable<QuestionRuleUpsertWithWhereUniqueWithoutFunctionInput>
    createMany?: QuestionRuleCreateManyFunctionInputEnvelope
    set?: Enumerable<QuestionRuleWhereUniqueInput>
    disconnect?: Enumerable<QuestionRuleWhereUniqueInput>
    delete?: Enumerable<QuestionRuleWhereUniqueInput>
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
    update?: Enumerable<QuestionRuleUpdateWithWhereUniqueWithoutFunctionInput>
    updateMany?: Enumerable<QuestionRuleUpdateManyWithWhereWithoutFunctionInput>
    deleteMany?: Enumerable<QuestionRuleScalarWhereInput>
  }

  export type OptionRuleUpdateManyWithoutFunctionNestedInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutFunctionInput>, Enumerable<OptionRuleUncheckedCreateWithoutFunctionInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutFunctionInput>
    upsert?: Enumerable<OptionRuleUpsertWithWhereUniqueWithoutFunctionInput>
    createMany?: OptionRuleCreateManyFunctionInputEnvelope
    set?: Enumerable<OptionRuleWhereUniqueInput>
    disconnect?: Enumerable<OptionRuleWhereUniqueInput>
    delete?: Enumerable<OptionRuleWhereUniqueInput>
    connect?: Enumerable<OptionRuleWhereUniqueInput>
    update?: Enumerable<OptionRuleUpdateWithWhereUniqueWithoutFunctionInput>
    updateMany?: Enumerable<OptionRuleUpdateManyWithWhereWithoutFunctionInput>
    deleteMany?: Enumerable<OptionRuleScalarWhereInput>
  }

  export type QuestionRuleUncheckedUpdateManyWithoutFunctionNestedInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutFunctionInput>, Enumerable<QuestionRuleUncheckedCreateWithoutFunctionInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutFunctionInput>
    upsert?: Enumerable<QuestionRuleUpsertWithWhereUniqueWithoutFunctionInput>
    createMany?: QuestionRuleCreateManyFunctionInputEnvelope
    set?: Enumerable<QuestionRuleWhereUniqueInput>
    disconnect?: Enumerable<QuestionRuleWhereUniqueInput>
    delete?: Enumerable<QuestionRuleWhereUniqueInput>
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
    update?: Enumerable<QuestionRuleUpdateWithWhereUniqueWithoutFunctionInput>
    updateMany?: Enumerable<QuestionRuleUpdateManyWithWhereWithoutFunctionInput>
    deleteMany?: Enumerable<QuestionRuleScalarWhereInput>
  }

  export type OptionRuleUncheckedUpdateManyWithoutFunctionNestedInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutFunctionInput>, Enumerable<OptionRuleUncheckedCreateWithoutFunctionInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutFunctionInput>
    upsert?: Enumerable<OptionRuleUpsertWithWhereUniqueWithoutFunctionInput>
    createMany?: OptionRuleCreateManyFunctionInputEnvelope
    set?: Enumerable<OptionRuleWhereUniqueInput>
    disconnect?: Enumerable<OptionRuleWhereUniqueInput>
    delete?: Enumerable<OptionRuleWhereUniqueInput>
    connect?: Enumerable<OptionRuleWhereUniqueInput>
    update?: Enumerable<OptionRuleUpdateWithWhereUniqueWithoutFunctionInput>
    updateMany?: Enumerable<OptionRuleUpdateManyWithWhereWithoutFunctionInput>
    deleteMany?: Enumerable<OptionRuleScalarWhereInput>
  }

  export type ClaimantCreateNestedOneWithoutTouchPointInput = {
    create?: XOR<ClaimantCreateWithoutTouchPointInput, ClaimantUncheckedCreateWithoutTouchPointInput>
    connectOrCreate?: ClaimantCreateOrConnectWithoutTouchPointInput
    connect?: ClaimantWhereUniqueInput
  }

  export type EnumTouchPointTypeFieldUpdateOperationsInput = {
    set?: TouchPointType
  }

  export type ClaimantUpdateOneRequiredWithoutTouchPointNestedInput = {
    create?: XOR<ClaimantCreateWithoutTouchPointInput, ClaimantUncheckedCreateWithoutTouchPointInput>
    connectOrCreate?: ClaimantCreateOrConnectWithoutTouchPointInput
    upsert?: ClaimantUpsertWithoutTouchPointInput
    connect?: ClaimantWhereUniqueInput
    update?: XOR<ClaimantUpdateWithoutTouchPointInput, ClaimantUncheckedUpdateWithoutTouchPointInput>
  }

  export type ClaimantCreateNestedManyWithoutReferrerInput = {
    create?: XOR<Enumerable<ClaimantCreateWithoutReferrerInput>, Enumerable<ClaimantUncheckedCreateWithoutReferrerInput>>
    connectOrCreate?: Enumerable<ClaimantCreateOrConnectWithoutReferrerInput>
    createMany?: ClaimantCreateManyReferrerInputEnvelope
    connect?: Enumerable<ClaimantWhereUniqueInput>
  }

  export type ClaimantUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<Enumerable<ClaimantCreateWithoutReferrerInput>, Enumerable<ClaimantUncheckedCreateWithoutReferrerInput>>
    connectOrCreate?: Enumerable<ClaimantCreateOrConnectWithoutReferrerInput>
    createMany?: ClaimantCreateManyReferrerInputEnvelope
    connect?: Enumerable<ClaimantWhereUniqueInput>
  }

  export type EnumReferrerTypesFieldUpdateOperationsInput = {
    set?: ReferrerTypes
  }

  export type EnumReferrerPayTypesFieldUpdateOperationsInput = {
    set?: ReferrerPayTypes
  }

  export type ClaimantUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<Enumerable<ClaimantCreateWithoutReferrerInput>, Enumerable<ClaimantUncheckedCreateWithoutReferrerInput>>
    connectOrCreate?: Enumerable<ClaimantCreateOrConnectWithoutReferrerInput>
    upsert?: Enumerable<ClaimantUpsertWithWhereUniqueWithoutReferrerInput>
    createMany?: ClaimantCreateManyReferrerInputEnvelope
    set?: Enumerable<ClaimantWhereUniqueInput>
    disconnect?: Enumerable<ClaimantWhereUniqueInput>
    delete?: Enumerable<ClaimantWhereUniqueInput>
    connect?: Enumerable<ClaimantWhereUniqueInput>
    update?: Enumerable<ClaimantUpdateWithWhereUniqueWithoutReferrerInput>
    updateMany?: Enumerable<ClaimantUpdateManyWithWhereWithoutReferrerInput>
    deleteMany?: Enumerable<ClaimantScalarWhereInput>
  }

  export type ClaimantUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<Enumerable<ClaimantCreateWithoutReferrerInput>, Enumerable<ClaimantUncheckedCreateWithoutReferrerInput>>
    connectOrCreate?: Enumerable<ClaimantCreateOrConnectWithoutReferrerInput>
    upsert?: Enumerable<ClaimantUpsertWithWhereUniqueWithoutReferrerInput>
    createMany?: ClaimantCreateManyReferrerInputEnvelope
    set?: Enumerable<ClaimantWhereUniqueInput>
    disconnect?: Enumerable<ClaimantWhereUniqueInput>
    delete?: Enumerable<ClaimantWhereUniqueInput>
    connect?: Enumerable<ClaimantWhereUniqueInput>
    update?: Enumerable<ClaimantUpdateWithWhereUniqueWithoutReferrerInput>
    updateMany?: Enumerable<ClaimantUpdateManyWithWhereWithoutReferrerInput>
    deleteMany?: Enumerable<ClaimantScalarWhereInput>
  }

  export type ClaimantCreateNestedManyWithoutSsaStatusInput = {
    create?: XOR<Enumerable<ClaimantCreateWithoutSsaStatusInput>, Enumerable<ClaimantUncheckedCreateWithoutSsaStatusInput>>
    connectOrCreate?: Enumerable<ClaimantCreateOrConnectWithoutSsaStatusInput>
    createMany?: ClaimantCreateManySsaStatusInputEnvelope
    connect?: Enumerable<ClaimantWhereUniqueInput>
  }

  export type OptionRuleCreateNestedManyWithoutSsaStatusInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutSsaStatusInput>, Enumerable<OptionRuleUncheckedCreateWithoutSsaStatusInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutSsaStatusInput>
    createMany?: OptionRuleCreateManySsaStatusInputEnvelope
    connect?: Enumerable<OptionRuleWhereUniqueInput>
  }

  export type QuestionRuleCreateNestedManyWithoutSsaStatusInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutSsaStatusInput>, Enumerable<QuestionRuleUncheckedCreateWithoutSsaStatusInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutSsaStatusInput>
    createMany?: QuestionRuleCreateManySsaStatusInputEnvelope
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
  }

  export type ClaimantUncheckedCreateNestedManyWithoutSsaStatusInput = {
    create?: XOR<Enumerable<ClaimantCreateWithoutSsaStatusInput>, Enumerable<ClaimantUncheckedCreateWithoutSsaStatusInput>>
    connectOrCreate?: Enumerable<ClaimantCreateOrConnectWithoutSsaStatusInput>
    createMany?: ClaimantCreateManySsaStatusInputEnvelope
    connect?: Enumerable<ClaimantWhereUniqueInput>
  }

  export type OptionRuleUncheckedCreateNestedManyWithoutSsaStatusInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutSsaStatusInput>, Enumerable<OptionRuleUncheckedCreateWithoutSsaStatusInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutSsaStatusInput>
    createMany?: OptionRuleCreateManySsaStatusInputEnvelope
    connect?: Enumerable<OptionRuleWhereUniqueInput>
  }

  export type QuestionRuleUncheckedCreateNestedManyWithoutSsaStatusInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutSsaStatusInput>, Enumerable<QuestionRuleUncheckedCreateWithoutSsaStatusInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutSsaStatusInput>
    createMany?: QuestionRuleCreateManySsaStatusInputEnvelope
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
  }

  export type ClaimantUpdateManyWithoutSsaStatusNestedInput = {
    create?: XOR<Enumerable<ClaimantCreateWithoutSsaStatusInput>, Enumerable<ClaimantUncheckedCreateWithoutSsaStatusInput>>
    connectOrCreate?: Enumerable<ClaimantCreateOrConnectWithoutSsaStatusInput>
    upsert?: Enumerable<ClaimantUpsertWithWhereUniqueWithoutSsaStatusInput>
    createMany?: ClaimantCreateManySsaStatusInputEnvelope
    set?: Enumerable<ClaimantWhereUniqueInput>
    disconnect?: Enumerable<ClaimantWhereUniqueInput>
    delete?: Enumerable<ClaimantWhereUniqueInput>
    connect?: Enumerable<ClaimantWhereUniqueInput>
    update?: Enumerable<ClaimantUpdateWithWhereUniqueWithoutSsaStatusInput>
    updateMany?: Enumerable<ClaimantUpdateManyWithWhereWithoutSsaStatusInput>
    deleteMany?: Enumerable<ClaimantScalarWhereInput>
  }

  export type OptionRuleUpdateManyWithoutSsaStatusNestedInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutSsaStatusInput>, Enumerable<OptionRuleUncheckedCreateWithoutSsaStatusInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutSsaStatusInput>
    upsert?: Enumerable<OptionRuleUpsertWithWhereUniqueWithoutSsaStatusInput>
    createMany?: OptionRuleCreateManySsaStatusInputEnvelope
    set?: Enumerable<OptionRuleWhereUniqueInput>
    disconnect?: Enumerable<OptionRuleWhereUniqueInput>
    delete?: Enumerable<OptionRuleWhereUniqueInput>
    connect?: Enumerable<OptionRuleWhereUniqueInput>
    update?: Enumerable<OptionRuleUpdateWithWhereUniqueWithoutSsaStatusInput>
    updateMany?: Enumerable<OptionRuleUpdateManyWithWhereWithoutSsaStatusInput>
    deleteMany?: Enumerable<OptionRuleScalarWhereInput>
  }

  export type QuestionRuleUpdateManyWithoutSsaStatusNestedInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutSsaStatusInput>, Enumerable<QuestionRuleUncheckedCreateWithoutSsaStatusInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutSsaStatusInput>
    upsert?: Enumerable<QuestionRuleUpsertWithWhereUniqueWithoutSsaStatusInput>
    createMany?: QuestionRuleCreateManySsaStatusInputEnvelope
    set?: Enumerable<QuestionRuleWhereUniqueInput>
    disconnect?: Enumerable<QuestionRuleWhereUniqueInput>
    delete?: Enumerable<QuestionRuleWhereUniqueInput>
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
    update?: Enumerable<QuestionRuleUpdateWithWhereUniqueWithoutSsaStatusInput>
    updateMany?: Enumerable<QuestionRuleUpdateManyWithWhereWithoutSsaStatusInput>
    deleteMany?: Enumerable<QuestionRuleScalarWhereInput>
  }

  export type ClaimantUncheckedUpdateManyWithoutSsaStatusNestedInput = {
    create?: XOR<Enumerable<ClaimantCreateWithoutSsaStatusInput>, Enumerable<ClaimantUncheckedCreateWithoutSsaStatusInput>>
    connectOrCreate?: Enumerable<ClaimantCreateOrConnectWithoutSsaStatusInput>
    upsert?: Enumerable<ClaimantUpsertWithWhereUniqueWithoutSsaStatusInput>
    createMany?: ClaimantCreateManySsaStatusInputEnvelope
    set?: Enumerable<ClaimantWhereUniqueInput>
    disconnect?: Enumerable<ClaimantWhereUniqueInput>
    delete?: Enumerable<ClaimantWhereUniqueInput>
    connect?: Enumerable<ClaimantWhereUniqueInput>
    update?: Enumerable<ClaimantUpdateWithWhereUniqueWithoutSsaStatusInput>
    updateMany?: Enumerable<ClaimantUpdateManyWithWhereWithoutSsaStatusInput>
    deleteMany?: Enumerable<ClaimantScalarWhereInput>
  }

  export type OptionRuleUncheckedUpdateManyWithoutSsaStatusNestedInput = {
    create?: XOR<Enumerable<OptionRuleCreateWithoutSsaStatusInput>, Enumerable<OptionRuleUncheckedCreateWithoutSsaStatusInput>>
    connectOrCreate?: Enumerable<OptionRuleCreateOrConnectWithoutSsaStatusInput>
    upsert?: Enumerable<OptionRuleUpsertWithWhereUniqueWithoutSsaStatusInput>
    createMany?: OptionRuleCreateManySsaStatusInputEnvelope
    set?: Enumerable<OptionRuleWhereUniqueInput>
    disconnect?: Enumerable<OptionRuleWhereUniqueInput>
    delete?: Enumerable<OptionRuleWhereUniqueInput>
    connect?: Enumerable<OptionRuleWhereUniqueInput>
    update?: Enumerable<OptionRuleUpdateWithWhereUniqueWithoutSsaStatusInput>
    updateMany?: Enumerable<OptionRuleUpdateManyWithWhereWithoutSsaStatusInput>
    deleteMany?: Enumerable<OptionRuleScalarWhereInput>
  }

  export type QuestionRuleUncheckedUpdateManyWithoutSsaStatusNestedInput = {
    create?: XOR<Enumerable<QuestionRuleCreateWithoutSsaStatusInput>, Enumerable<QuestionRuleUncheckedCreateWithoutSsaStatusInput>>
    connectOrCreate?: Enumerable<QuestionRuleCreateOrConnectWithoutSsaStatusInput>
    upsert?: Enumerable<QuestionRuleUpsertWithWhereUniqueWithoutSsaStatusInput>
    createMany?: QuestionRuleCreateManySsaStatusInputEnvelope
    set?: Enumerable<QuestionRuleWhereUniqueInput>
    disconnect?: Enumerable<QuestionRuleWhereUniqueInput>
    delete?: Enumerable<QuestionRuleWhereUniqueInput>
    connect?: Enumerable<QuestionRuleWhereUniqueInput>
    update?: Enumerable<QuestionRuleUpdateWithWhereUniqueWithoutSsaStatusInput>
    updateMany?: Enumerable<QuestionRuleUpdateManyWithWhereWithoutSsaStatusInput>
    deleteMany?: Enumerable<QuestionRuleScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumSessionTypesFilter = {
    equals?: SessionTypes
    in?: Enumerable<SessionTypes>
    notIn?: Enumerable<SessionTypes>
    not?: NestedEnumSessionTypesFilter | SessionTypes
  }

  export type NestedEnumSessionStatusesNullableFilter = {
    equals?: SessionStatuses | null
    in?: Enumerable<SessionStatuses> | null
    notIn?: Enumerable<SessionStatuses> | null
    not?: NestedEnumSessionStatusesNullableFilter | SessionStatuses | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumSessionTypesWithAggregatesFilter = {
    equals?: SessionTypes
    in?: Enumerable<SessionTypes>
    notIn?: Enumerable<SessionTypes>
    not?: NestedEnumSessionTypesWithAggregatesFilter | SessionTypes
    _count?: NestedIntFilter
    _min?: NestedEnumSessionTypesFilter
    _max?: NestedEnumSessionTypesFilter
  }

  export type NestedEnumSessionStatusesNullableWithAggregatesFilter = {
    equals?: SessionStatuses | null
    in?: Enumerable<SessionStatuses> | null
    notIn?: Enumerable<SessionStatuses> | null
    not?: NestedEnumSessionStatusesNullableWithAggregatesFilter | SessionStatuses | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumSessionStatusesNullableFilter
    _max?: NestedEnumSessionStatusesNullableFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedEnumQuestionTypeFilter = {
    equals?: QuestionType
    in?: Enumerable<QuestionType>
    notIn?: Enumerable<QuestionType>
    not?: NestedEnumQuestionTypeFilter | QuestionType
  }

  export type NestedEnumInputTypeNullableFilter = {
    equals?: InputType | null
    in?: Enumerable<InputType> | null
    notIn?: Enumerable<InputType> | null
    not?: NestedEnumInputTypeNullableFilter | InputType | null
  }

  export type NestedEnumQuestionTypeWithAggregatesFilter = {
    equals?: QuestionType
    in?: Enumerable<QuestionType>
    notIn?: Enumerable<QuestionType>
    not?: NestedEnumQuestionTypeWithAggregatesFilter | QuestionType
    _count?: NestedIntFilter
    _min?: NestedEnumQuestionTypeFilter
    _max?: NestedEnumQuestionTypeFilter
  }

  export type NestedEnumInputTypeNullableWithAggregatesFilter = {
    equals?: InputType | null
    in?: Enumerable<InputType> | null
    notIn?: Enumerable<InputType> | null
    not?: NestedEnumInputTypeNullableWithAggregatesFilter | InputType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumInputTypeNullableFilter
    _max?: NestedEnumInputTypeNullableFilter
  }

  export type NestedEnumSubFormFieldTypeFilter = {
    equals?: SubFormFieldType
    in?: Enumerable<SubFormFieldType>
    notIn?: Enumerable<SubFormFieldType>
    not?: NestedEnumSubFormFieldTypeFilter | SubFormFieldType
  }

  export type NestedEnumSubFormFieldTypeWithAggregatesFilter = {
    equals?: SubFormFieldType
    in?: Enumerable<SubFormFieldType>
    notIn?: Enumerable<SubFormFieldType>
    not?: NestedEnumSubFormFieldTypeWithAggregatesFilter | SubFormFieldType
    _count?: NestedIntFilter
    _min?: NestedEnumSubFormFieldTypeFilter
    _max?: NestedEnumSubFormFieldTypeFilter
  }

  export type NestedEnumRuleTypeFilter = {
    equals?: RuleType
    in?: Enumerable<RuleType>
    notIn?: Enumerable<RuleType>
    not?: NestedEnumRuleTypeFilter | RuleType
  }

  export type NestedEnumOperatorOptionNullableFilter = {
    equals?: OperatorOption | null
    in?: Enumerable<OperatorOption> | null
    notIn?: Enumerable<OperatorOption> | null
    not?: NestedEnumOperatorOptionNullableFilter | OperatorOption | null
  }

  export type NestedEnumReferrerPayTypesNullableFilter = {
    equals?: ReferrerPayTypes | null
    in?: Enumerable<ReferrerPayTypes> | null
    notIn?: Enumerable<ReferrerPayTypes> | null
    not?: NestedEnumReferrerPayTypesNullableFilter | ReferrerPayTypes | null
  }

  export type NestedEnumRuleTypeWithAggregatesFilter = {
    equals?: RuleType
    in?: Enumerable<RuleType>
    notIn?: Enumerable<RuleType>
    not?: NestedEnumRuleTypeWithAggregatesFilter | RuleType
    _count?: NestedIntFilter
    _min?: NestedEnumRuleTypeFilter
    _max?: NestedEnumRuleTypeFilter
  }

  export type NestedEnumOperatorOptionNullableWithAggregatesFilter = {
    equals?: OperatorOption | null
    in?: Enumerable<OperatorOption> | null
    notIn?: Enumerable<OperatorOption> | null
    not?: NestedEnumOperatorOptionNullableWithAggregatesFilter | OperatorOption | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumOperatorOptionNullableFilter
    _max?: NestedEnumOperatorOptionNullableFilter
  }

  export type NestedEnumReferrerPayTypesNullableWithAggregatesFilter = {
    equals?: ReferrerPayTypes | null
    in?: Enumerable<ReferrerPayTypes> | null
    notIn?: Enumerable<ReferrerPayTypes> | null
    not?: NestedEnumReferrerPayTypesNullableWithAggregatesFilter | ReferrerPayTypes | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumReferrerPayTypesNullableFilter
    _max?: NestedEnumReferrerPayTypesNullableFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedEnumQuestionFormatTypesFilter = {
    equals?: QuestionFormatTypes
    in?: Enumerable<QuestionFormatTypes>
    notIn?: Enumerable<QuestionFormatTypes>
    not?: NestedEnumQuestionFormatTypesFilter | QuestionFormatTypes
  }

  export type NestedEnumClaimantFieldRefTypesNullableFilter = {
    equals?: ClaimantFieldRefTypes | null
    in?: Enumerable<ClaimantFieldRefTypes> | null
    notIn?: Enumerable<ClaimantFieldRefTypes> | null
    not?: NestedEnumClaimantFieldRefTypesNullableFilter | ClaimantFieldRefTypes | null
  }

  export type NestedEnumQuestionFormatTypesWithAggregatesFilter = {
    equals?: QuestionFormatTypes
    in?: Enumerable<QuestionFormatTypes>
    notIn?: Enumerable<QuestionFormatTypes>
    not?: NestedEnumQuestionFormatTypesWithAggregatesFilter | QuestionFormatTypes
    _count?: NestedIntFilter
    _min?: NestedEnumQuestionFormatTypesFilter
    _max?: NestedEnumQuestionFormatTypesFilter
  }

  export type NestedEnumClaimantFieldRefTypesNullableWithAggregatesFilter = {
    equals?: ClaimantFieldRefTypes | null
    in?: Enumerable<ClaimantFieldRefTypes> | null
    notIn?: Enumerable<ClaimantFieldRefTypes> | null
    not?: NestedEnumClaimantFieldRefTypesNullableWithAggregatesFilter | ClaimantFieldRefTypes | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumClaimantFieldRefTypesNullableFilter
    _max?: NestedEnumClaimantFieldRefTypesNullableFilter
  }

  export type NestedEnumTouchPointTypeFilter = {
    equals?: TouchPointType
    in?: Enumerable<TouchPointType>
    notIn?: Enumerable<TouchPointType>
    not?: NestedEnumTouchPointTypeFilter | TouchPointType
  }

  export type NestedEnumTouchPointTypeWithAggregatesFilter = {
    equals?: TouchPointType
    in?: Enumerable<TouchPointType>
    notIn?: Enumerable<TouchPointType>
    not?: NestedEnumTouchPointTypeWithAggregatesFilter | TouchPointType
    _count?: NestedIntFilter
    _min?: NestedEnumTouchPointTypeFilter
    _max?: NestedEnumTouchPointTypeFilter
  }

  export type NestedEnumReferrerTypesFilter = {
    equals?: ReferrerTypes
    in?: Enumerable<ReferrerTypes>
    notIn?: Enumerable<ReferrerTypes>
    not?: NestedEnumReferrerTypesFilter | ReferrerTypes
  }

  export type NestedEnumReferrerPayTypesFilter = {
    equals?: ReferrerPayTypes
    in?: Enumerable<ReferrerPayTypes>
    notIn?: Enumerable<ReferrerPayTypes>
    not?: NestedEnumReferrerPayTypesFilter | ReferrerPayTypes
  }

  export type NestedEnumReferrerTypesWithAggregatesFilter = {
    equals?: ReferrerTypes
    in?: Enumerable<ReferrerTypes>
    notIn?: Enumerable<ReferrerTypes>
    not?: NestedEnumReferrerTypesWithAggregatesFilter | ReferrerTypes
    _count?: NestedIntFilter
    _min?: NestedEnumReferrerTypesFilter
    _max?: NestedEnumReferrerTypesFilter
  }

  export type NestedEnumReferrerPayTypesWithAggregatesFilter = {
    equals?: ReferrerPayTypes
    in?: Enumerable<ReferrerPayTypes>
    notIn?: Enumerable<ReferrerPayTypes>
    not?: NestedEnumReferrerPayTypesWithAggregatesFilter | ReferrerPayTypes
    _count?: NestedIntFilter
    _min?: NestedEnumReferrerPayTypesFilter
    _max?: NestedEnumReferrerPayTypesFilter
  }

  export type CallSessionCreateWithoutUserInput = {
    sessionType: SessionTypes
    sessionStatus?: SessionStatuses | null
    created?: Date | string
    ended?: Date | string | null
    updated?: Date | string
    claimant: ClaimantCreateNestedOneWithoutCallSessionsInput
    answer?: AnswerCreateNestedManyWithoutCallSessionInput
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutSessionInput
    recordingUrl?: string | null
    outgoingPhone: string
  }

  export type CallSessionUncheckedCreateWithoutUserInput = {
    id?: number
    claimantId: number
    sessionType: SessionTypes
    sessionStatus?: SessionStatuses | null
    created?: Date | string
    ended?: Date | string | null
    updated?: Date | string
    answer?: AnswerUncheckedCreateNestedManyWithoutCallSessionInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutSessionInput
    recordingUrl?: string | null
    outgoingPhone: string
  }

  export type CallSessionCreateOrConnectWithoutUserInput = {
    where: CallSessionWhereUniqueInput
    create: XOR<CallSessionCreateWithoutUserInput, CallSessionUncheckedCreateWithoutUserInput>
  }

  export type CallSessionCreateManyUserInputEnvelope = {
    data: Enumerable<CallSessionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CallSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: CallSessionWhereUniqueInput
    update: XOR<CallSessionUpdateWithoutUserInput, CallSessionUncheckedUpdateWithoutUserInput>
    create: XOR<CallSessionCreateWithoutUserInput, CallSessionUncheckedCreateWithoutUserInput>
  }

  export type CallSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: CallSessionWhereUniqueInput
    data: XOR<CallSessionUpdateWithoutUserInput, CallSessionUncheckedUpdateWithoutUserInput>
  }

  export type CallSessionUpdateManyWithWhereWithoutUserInput = {
    where: CallSessionScalarWhereInput
    data: XOR<CallSessionUpdateManyMutationInput, CallSessionUncheckedUpdateManyWithoutCallSessionsInput>
  }

  export type CallSessionScalarWhereInput = {
    AND?: Enumerable<CallSessionScalarWhereInput>
    OR?: Enumerable<CallSessionScalarWhereInput>
    NOT?: Enumerable<CallSessionScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    claimantId?: IntFilter | number
    sessionType?: EnumSessionTypesFilter | SessionTypes
    sessionStatus?: EnumSessionStatusesNullableFilter | SessionStatuses | null
    created?: DateTimeFilter | Date | string
    ended?: DateTimeNullableFilter | Date | string | null
    updated?: DateTimeFilter | Date | string
    recordingUrl?: StringNullableFilter | string | null
    outgoingPhone?: StringFilter | string
  }

  export type CursorCreateWithoutClaimantInput = {
    questionId: number
    created?: Date | string
    updatedAt?: Date | string
    formSection: FormSectionCreateNestedOneWithoutCursorInput
  }

  export type CursorUncheckedCreateWithoutClaimantInput = {
    id?: number
    formSectionId: number
    questionId: number
    created?: Date | string
    updatedAt?: Date | string
  }

  export type CursorCreateOrConnectWithoutClaimantInput = {
    where: CursorWhereUniqueInput
    create: XOR<CursorCreateWithoutClaimantInput, CursorUncheckedCreateWithoutClaimantInput>
  }

  export type CursorCreateManyClaimantInputEnvelope = {
    data: Enumerable<CursorCreateManyClaimantInput>
    skipDuplicates?: boolean
  }

  export type AnswerCreateWithoutClaimantInput = {
    value?: string | null
    created?: Date | string
    updated?: Date | string
    question: QuestionCreateNestedOneWithoutAnswersInput
    option?: OptionCreateNestedOneWithoutAnswerInput
    callSession: CallSessionCreateNestedOneWithoutAnswerInput
  }

  export type AnswerUncheckedCreateWithoutClaimantInput = {
    id?: number
    questionId: number
    sessionId: number
    optionId?: number | null
    value?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type AnswerCreateOrConnectWithoutClaimantInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutClaimantInput, AnswerUncheckedCreateWithoutClaimantInput>
  }

  export type AnswerCreateManyClaimantInputEnvelope = {
    data: Enumerable<AnswerCreateManyClaimantInput>
    skipDuplicates?: boolean
  }

  export type TouchPointCreateWithoutClaimantInput = {
    type: TouchPointType
    created?: Date | string
    updated?: Date | string
  }

  export type TouchPointUncheckedCreateWithoutClaimantInput = {
    id?: number
    type: TouchPointType
    created?: Date | string
    updated?: Date | string
  }

  export type TouchPointCreateOrConnectWithoutClaimantInput = {
    where: TouchPointWhereUniqueInput
    create: XOR<TouchPointCreateWithoutClaimantInput, TouchPointUncheckedCreateWithoutClaimantInput>
  }

  export type TouchPointCreateManyClaimantInputEnvelope = {
    data: Enumerable<TouchPointCreateManyClaimantInput>
    skipDuplicates?: boolean
  }

  export type CallSessionCreateWithoutClaimantInput = {
    sessionType: SessionTypes
    sessionStatus?: SessionStatuses | null
    created?: Date | string
    ended?: Date | string | null
    updated?: Date | string
    user: UserCreateNestedOneWithoutCallSessionsInput
    answer?: AnswerCreateNestedManyWithoutCallSessionInput
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutSessionInput
    recordingUrl?: string | null
    outgoingPhone: string
  }

  export type CallSessionUncheckedCreateWithoutClaimantInput = {
    id?: number
    userId: number
    sessionType: SessionTypes
    sessionStatus?: SessionStatuses | null
    created?: Date | string
    ended?: Date | string | null
    updated?: Date | string
    answer?: AnswerUncheckedCreateNestedManyWithoutCallSessionInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutSessionInput
    recordingUrl?: string | null
    outgoingPhone: string
  }

  export type CallSessionCreateOrConnectWithoutClaimantInput = {
    where: CallSessionWhereUniqueInput
    create: XOR<CallSessionCreateWithoutClaimantInput, CallSessionUncheckedCreateWithoutClaimantInput>
  }

  export type CallSessionCreateManyClaimantInputEnvelope = {
    data: Enumerable<CallSessionCreateManyClaimantInput>
    skipDuplicates?: boolean
  }

  export type SubformFieldAnswerCreateWithoutClaimantInput = {
    value?: string | null
    created?: Date | string
    updated?: Date | string
    subformField: SubformFieldCreateNestedOneWithoutSubformFieldAnswerInput
    subformFieldOpion?: SubformFieldOptionCreateNestedOneWithoutSubformFieldAnswerInput
    session: CallSessionCreateNestedOneWithoutSubformFieldAnswerInput
  }

  export type SubformFieldAnswerUncheckedCreateWithoutClaimantInput = {
    id?: number
    subformFieldId: number
    sessionId: number
    value?: string | null
    optionId?: number | null
    created?: Date | string
    updated?: Date | string
  }

  export type SubformFieldAnswerCreateOrConnectWithoutClaimantInput = {
    where: SubformFieldAnswerWhereUniqueInput
    create: XOR<SubformFieldAnswerCreateWithoutClaimantInput, SubformFieldAnswerUncheckedCreateWithoutClaimantInput>
  }

  export type SubformFieldAnswerCreateManyClaimantInputEnvelope = {
    data: Enumerable<SubformFieldAnswerCreateManyClaimantInput>
    skipDuplicates?: boolean
  }

  export type SSAStatusCreateWithoutClaimantInput = {
    name: string
    created?: Date | string
    updated?: Date | string
    OptionRule?: OptionRuleCreateNestedManyWithoutSsaStatusInput
    QuestionRule?: QuestionRuleCreateNestedManyWithoutSsaStatusInput
  }

  export type SSAStatusUncheckedCreateWithoutClaimantInput = {
    id?: number
    name: string
    created?: Date | string
    updated?: Date | string
    OptionRule?: OptionRuleUncheckedCreateNestedManyWithoutSsaStatusInput
    QuestionRule?: QuestionRuleUncheckedCreateNestedManyWithoutSsaStatusInput
  }

  export type SSAStatusCreateOrConnectWithoutClaimantInput = {
    where: SSAStatusWhereUniqueInput
    create: XOR<SSAStatusCreateWithoutClaimantInput, SSAStatusUncheckedCreateWithoutClaimantInput>
  }

  export type ReferrerCreateWithoutClaimantInput = {
    name: string
    type: ReferrerTypes
    payType: ReferrerPayTypes
    preIntakeTimer?: number
    created?: Date | string
    updated?: Date | string
  }

  export type ReferrerUncheckedCreateWithoutClaimantInput = {
    id?: number
    name: string
    type: ReferrerTypes
    payType: ReferrerPayTypes
    preIntakeTimer?: number
    created?: Date | string
    updated?: Date | string
  }

  export type ReferrerCreateOrConnectWithoutClaimantInput = {
    where: ReferrerWhereUniqueInput
    create: XOR<ReferrerCreateWithoutClaimantInput, ReferrerUncheckedCreateWithoutClaimantInput>
  }

  export type VoiceMailCreateWithoutClaimantInput = {
    created?: Date | string
    updated?: Date | string
    recordingUrl?: string | null
    transcription?: string | null
  }

  export type VoiceMailUncheckedCreateWithoutClaimantInput = {
    id?: number
    created?: Date | string
    updated?: Date | string
    recordingUrl?: string | null
    transcription?: string | null
  }

  export type VoiceMailCreateOrConnectWithoutClaimantInput = {
    where: VoiceMailWhereUniqueInput
    create: XOR<VoiceMailCreateWithoutClaimantInput, VoiceMailUncheckedCreateWithoutClaimantInput>
  }

  export type VoiceMailCreateManyClaimantInputEnvelope = {
    data: Enumerable<VoiceMailCreateManyClaimantInput>
    skipDuplicates?: boolean
  }

  export type CursorUpsertWithWhereUniqueWithoutClaimantInput = {
    where: CursorWhereUniqueInput
    update: XOR<CursorUpdateWithoutClaimantInput, CursorUncheckedUpdateWithoutClaimantInput>
    create: XOR<CursorCreateWithoutClaimantInput, CursorUncheckedCreateWithoutClaimantInput>
  }

  export type CursorUpdateWithWhereUniqueWithoutClaimantInput = {
    where: CursorWhereUniqueInput
    data: XOR<CursorUpdateWithoutClaimantInput, CursorUncheckedUpdateWithoutClaimantInput>
  }

  export type CursorUpdateManyWithWhereWithoutClaimantInput = {
    where: CursorScalarWhereInput
    data: XOR<CursorUpdateManyMutationInput, CursorUncheckedUpdateManyWithoutCursorInput>
  }

  export type CursorScalarWhereInput = {
    AND?: Enumerable<CursorScalarWhereInput>
    OR?: Enumerable<CursorScalarWhereInput>
    NOT?: Enumerable<CursorScalarWhereInput>
    id?: IntFilter | number
    formSectionId?: IntFilter | number
    questionId?: IntFilter | number
    claimantId?: IntFilter | number
    created?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AnswerUpsertWithWhereUniqueWithoutClaimantInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutClaimantInput, AnswerUncheckedUpdateWithoutClaimantInput>
    create: XOR<AnswerCreateWithoutClaimantInput, AnswerUncheckedCreateWithoutClaimantInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutClaimantInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutClaimantInput, AnswerUncheckedUpdateWithoutClaimantInput>
  }

  export type AnswerUpdateManyWithWhereWithoutClaimantInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutAnswersInput>
  }

  export type AnswerScalarWhereInput = {
    AND?: Enumerable<AnswerScalarWhereInput>
    OR?: Enumerable<AnswerScalarWhereInput>
    NOT?: Enumerable<AnswerScalarWhereInput>
    id?: IntFilter | number
    questionId?: IntFilter | number
    claimantId?: IntFilter | number
    sessionId?: IntFilter | number
    optionId?: IntNullableFilter | number | null
    value?: StringNullableFilter | string | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
  }

  export type TouchPointUpsertWithWhereUniqueWithoutClaimantInput = {
    where: TouchPointWhereUniqueInput
    update: XOR<TouchPointUpdateWithoutClaimantInput, TouchPointUncheckedUpdateWithoutClaimantInput>
    create: XOR<TouchPointCreateWithoutClaimantInput, TouchPointUncheckedCreateWithoutClaimantInput>
  }

  export type TouchPointUpdateWithWhereUniqueWithoutClaimantInput = {
    where: TouchPointWhereUniqueInput
    data: XOR<TouchPointUpdateWithoutClaimantInput, TouchPointUncheckedUpdateWithoutClaimantInput>
  }

  export type TouchPointUpdateManyWithWhereWithoutClaimantInput = {
    where: TouchPointScalarWhereInput
    data: XOR<TouchPointUpdateManyMutationInput, TouchPointUncheckedUpdateManyWithoutTouchPointInput>
  }

  export type TouchPointScalarWhereInput = {
    AND?: Enumerable<TouchPointScalarWhereInput>
    OR?: Enumerable<TouchPointScalarWhereInput>
    NOT?: Enumerable<TouchPointScalarWhereInput>
    id?: IntFilter | number
    claimantId?: IntFilter | number
    type?: EnumTouchPointTypeFilter | TouchPointType
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
  }

  export type CallSessionUpsertWithWhereUniqueWithoutClaimantInput = {
    where: CallSessionWhereUniqueInput
    update: XOR<CallSessionUpdateWithoutClaimantInput, CallSessionUncheckedUpdateWithoutClaimantInput>
    create: XOR<CallSessionCreateWithoutClaimantInput, CallSessionUncheckedCreateWithoutClaimantInput>
  }

  export type CallSessionUpdateWithWhereUniqueWithoutClaimantInput = {
    where: CallSessionWhereUniqueInput
    data: XOR<CallSessionUpdateWithoutClaimantInput, CallSessionUncheckedUpdateWithoutClaimantInput>
  }

  export type CallSessionUpdateManyWithWhereWithoutClaimantInput = {
    where: CallSessionScalarWhereInput
    data: XOR<CallSessionUpdateManyMutationInput, CallSessionUncheckedUpdateManyWithoutCallSessionsInput>
  }

  export type SubformFieldAnswerUpsertWithWhereUniqueWithoutClaimantInput = {
    where: SubformFieldAnswerWhereUniqueInput
    update: XOR<SubformFieldAnswerUpdateWithoutClaimantInput, SubformFieldAnswerUncheckedUpdateWithoutClaimantInput>
    create: XOR<SubformFieldAnswerCreateWithoutClaimantInput, SubformFieldAnswerUncheckedCreateWithoutClaimantInput>
  }

  export type SubformFieldAnswerUpdateWithWhereUniqueWithoutClaimantInput = {
    where: SubformFieldAnswerWhereUniqueInput
    data: XOR<SubformFieldAnswerUpdateWithoutClaimantInput, SubformFieldAnswerUncheckedUpdateWithoutClaimantInput>
  }

  export type SubformFieldAnswerUpdateManyWithWhereWithoutClaimantInput = {
    where: SubformFieldAnswerScalarWhereInput
    data: XOR<SubformFieldAnswerUpdateManyMutationInput, SubformFieldAnswerUncheckedUpdateManyWithoutSubformFieldAnswerInput>
  }

  export type SubformFieldAnswerScalarWhereInput = {
    AND?: Enumerable<SubformFieldAnswerScalarWhereInput>
    OR?: Enumerable<SubformFieldAnswerScalarWhereInput>
    NOT?: Enumerable<SubformFieldAnswerScalarWhereInput>
    id?: IntFilter | number
    subformFieldId?: IntFilter | number
    claimantId?: IntFilter | number
    sessionId?: IntFilter | number
    value?: StringNullableFilter | string | null
    optionId?: IntNullableFilter | number | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
  }

  export type SSAStatusUpsertWithoutClaimantInput = {
    update: XOR<SSAStatusUpdateWithoutClaimantInput, SSAStatusUncheckedUpdateWithoutClaimantInput>
    create: XOR<SSAStatusCreateWithoutClaimantInput, SSAStatusUncheckedCreateWithoutClaimantInput>
  }

  export type SSAStatusUpdateWithoutClaimantInput = {
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    OptionRule?: OptionRuleUpdateManyWithoutSsaStatusNestedInput
    QuestionRule?: QuestionRuleUpdateManyWithoutSsaStatusNestedInput
  }

  export type SSAStatusUncheckedUpdateWithoutClaimantInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    OptionRule?: OptionRuleUncheckedUpdateManyWithoutSsaStatusNestedInput
    QuestionRule?: QuestionRuleUncheckedUpdateManyWithoutSsaStatusNestedInput
  }

  export type ReferrerUpsertWithoutClaimantInput = {
    update: XOR<ReferrerUpdateWithoutClaimantInput, ReferrerUncheckedUpdateWithoutClaimantInput>
    create: XOR<ReferrerCreateWithoutClaimantInput, ReferrerUncheckedCreateWithoutClaimantInput>
  }

  export type ReferrerUpdateWithoutClaimantInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumReferrerTypesFieldUpdateOperationsInput | ReferrerTypes
    payType?: EnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes
    preIntakeTimer?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferrerUncheckedUpdateWithoutClaimantInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumReferrerTypesFieldUpdateOperationsInput | ReferrerTypes
    payType?: EnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes
    preIntakeTimer?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceMailUpsertWithWhereUniqueWithoutClaimantInput = {
    where: VoiceMailWhereUniqueInput
    update: XOR<VoiceMailUpdateWithoutClaimantInput, VoiceMailUncheckedUpdateWithoutClaimantInput>
    create: XOR<VoiceMailCreateWithoutClaimantInput, VoiceMailUncheckedCreateWithoutClaimantInput>
  }

  export type VoiceMailUpdateWithWhereUniqueWithoutClaimantInput = {
    where: VoiceMailWhereUniqueInput
    data: XOR<VoiceMailUpdateWithoutClaimantInput, VoiceMailUncheckedUpdateWithoutClaimantInput>
  }

  export type VoiceMailUpdateManyWithWhereWithoutClaimantInput = {
    where: VoiceMailScalarWhereInput
    data: XOR<VoiceMailUpdateManyMutationInput, VoiceMailUncheckedUpdateManyWithoutVoiceMailInput>
  }

  export type VoiceMailScalarWhereInput = {
    AND?: Enumerable<VoiceMailScalarWhereInput>
    OR?: Enumerable<VoiceMailScalarWhereInput>
    NOT?: Enumerable<VoiceMailScalarWhereInput>
    id?: IntFilter | number
    claimantId?: IntNullableFilter | number | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    recordingUrl?: StringNullableFilter | string | null
    transcription?: StringNullableFilter | string | null
  }

  export type UserCreateWithoutCallSessionsInput = {
    auth0Id?: string
    email?: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    active?: boolean
    lastActive?: Date | string
    created?: Date | string
    updated?: Date | string
  }

  export type UserUncheckedCreateWithoutCallSessionsInput = {
    id?: number
    auth0Id?: string
    email?: string
    phone?: string | null
    firstName?: string | null
    lastName?: string | null
    active?: boolean
    lastActive?: Date | string
    created?: Date | string
    updated?: Date | string
  }

  export type UserCreateOrConnectWithoutCallSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCallSessionsInput, UserUncheckedCreateWithoutCallSessionsInput>
  }

  export type ClaimantCreateWithoutCallSessionsInput = {
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorCreateNestedManyWithoutClaimantInput
    answers?: AnswerCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutClaimantInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutClaimantInput
    referrer?: ReferrerCreateNestedOneWithoutClaimantInput
    VoiceMail?: VoiceMailCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantUncheckedCreateWithoutCallSessionsInput = {
    id?: number
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    referrerId?: number | null
    ssaStatusId?: number | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorUncheckedCreateNestedManyWithoutClaimantInput
    answers?: AnswerUncheckedCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointUncheckedCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutClaimantInput
    VoiceMail?: VoiceMailUncheckedCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantCreateOrConnectWithoutCallSessionsInput = {
    where: ClaimantWhereUniqueInput
    create: XOR<ClaimantCreateWithoutCallSessionsInput, ClaimantUncheckedCreateWithoutCallSessionsInput>
  }

  export type AnswerCreateWithoutCallSessionInput = {
    value?: string | null
    created?: Date | string
    updated?: Date | string
    question: QuestionCreateNestedOneWithoutAnswersInput
    claimant: ClaimantCreateNestedOneWithoutAnswersInput
    option?: OptionCreateNestedOneWithoutAnswerInput
  }

  export type AnswerUncheckedCreateWithoutCallSessionInput = {
    id?: number
    questionId: number
    claimantId: number
    optionId?: number | null
    value?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type AnswerCreateOrConnectWithoutCallSessionInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutCallSessionInput, AnswerUncheckedCreateWithoutCallSessionInput>
  }

  export type AnswerCreateManyCallSessionInputEnvelope = {
    data: Enumerable<AnswerCreateManyCallSessionInput>
    skipDuplicates?: boolean
  }

  export type SubformFieldAnswerCreateWithoutSessionInput = {
    value?: string | null
    created?: Date | string
    updated?: Date | string
    subformField: SubformFieldCreateNestedOneWithoutSubformFieldAnswerInput
    subformFieldOpion?: SubformFieldOptionCreateNestedOneWithoutSubformFieldAnswerInput
    claimant: ClaimantCreateNestedOneWithoutSubformFieldAnswerInput
  }

  export type SubformFieldAnswerUncheckedCreateWithoutSessionInput = {
    id?: number
    subformFieldId: number
    claimantId: number
    value?: string | null
    optionId?: number | null
    created?: Date | string
    updated?: Date | string
  }

  export type SubformFieldAnswerCreateOrConnectWithoutSessionInput = {
    where: SubformFieldAnswerWhereUniqueInput
    create: XOR<SubformFieldAnswerCreateWithoutSessionInput, SubformFieldAnswerUncheckedCreateWithoutSessionInput>
  }

  export type SubformFieldAnswerCreateManySessionInputEnvelope = {
    data: Enumerable<SubformFieldAnswerCreateManySessionInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCallSessionsInput = {
    update: XOR<UserUpdateWithoutCallSessionsInput, UserUncheckedUpdateWithoutCallSessionsInput>
    create: XOR<UserCreateWithoutCallSessionsInput, UserUncheckedCreateWithoutCallSessionsInput>
  }

  export type UserUpdateWithoutCallSessionsInput = {
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutCallSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimantUpsertWithoutCallSessionsInput = {
    update: XOR<ClaimantUpdateWithoutCallSessionsInput, ClaimantUncheckedUpdateWithoutCallSessionsInput>
    create: XOR<ClaimantCreateWithoutCallSessionsInput, ClaimantUncheckedCreateWithoutCallSessionsInput>
  }

  export type ClaimantUpdateWithoutCallSessionsInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUpdateManyWithoutClaimantNestedInput
    answers?: AnswerUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutClaimantNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutClaimantNestedInput
    referrer?: ReferrerUpdateOneWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUpdateManyWithoutClaimantNestedInput
  }

  export type ClaimantUncheckedUpdateWithoutCallSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUncheckedUpdateManyWithoutClaimantNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUncheckedUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUncheckedUpdateManyWithoutClaimantNestedInput
  }

  export type AnswerUpsertWithWhereUniqueWithoutCallSessionInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutCallSessionInput, AnswerUncheckedUpdateWithoutCallSessionInput>
    create: XOR<AnswerCreateWithoutCallSessionInput, AnswerUncheckedCreateWithoutCallSessionInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutCallSessionInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutCallSessionInput, AnswerUncheckedUpdateWithoutCallSessionInput>
  }

  export type AnswerUpdateManyWithWhereWithoutCallSessionInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutAnswerInput>
  }

  export type SubformFieldAnswerUpsertWithWhereUniqueWithoutSessionInput = {
    where: SubformFieldAnswerWhereUniqueInput
    update: XOR<SubformFieldAnswerUpdateWithoutSessionInput, SubformFieldAnswerUncheckedUpdateWithoutSessionInput>
    create: XOR<SubformFieldAnswerCreateWithoutSessionInput, SubformFieldAnswerUncheckedCreateWithoutSessionInput>
  }

  export type SubformFieldAnswerUpdateWithWhereUniqueWithoutSessionInput = {
    where: SubformFieldAnswerWhereUniqueInput
    data: XOR<SubformFieldAnswerUpdateWithoutSessionInput, SubformFieldAnswerUncheckedUpdateWithoutSessionInput>
  }

  export type SubformFieldAnswerUpdateManyWithWhereWithoutSessionInput = {
    where: SubformFieldAnswerScalarWhereInput
    data: XOR<SubformFieldAnswerUpdateManyMutationInput, SubformFieldAnswerUncheckedUpdateManyWithoutSubformFieldAnswerInput>
  }

  export type ClaimantCreateWithoutVoiceMailInput = {
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorCreateNestedManyWithoutClaimantInput
    answers?: AnswerCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutClaimantInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutClaimantInput
    referrer?: ReferrerCreateNestedOneWithoutClaimantInput
  }

  export type ClaimantUncheckedCreateWithoutVoiceMailInput = {
    id?: number
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    referrerId?: number | null
    ssaStatusId?: number | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorUncheckedCreateNestedManyWithoutClaimantInput
    answers?: AnswerUncheckedCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointUncheckedCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantCreateOrConnectWithoutVoiceMailInput = {
    where: ClaimantWhereUniqueInput
    create: XOR<ClaimantCreateWithoutVoiceMailInput, ClaimantUncheckedCreateWithoutVoiceMailInput>
  }

  export type ClaimantUpsertWithoutVoiceMailInput = {
    update: XOR<ClaimantUpdateWithoutVoiceMailInput, ClaimantUncheckedUpdateWithoutVoiceMailInput>
    create: XOR<ClaimantCreateWithoutVoiceMailInput, ClaimantUncheckedCreateWithoutVoiceMailInput>
  }

  export type ClaimantUpdateWithoutVoiceMailInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUpdateManyWithoutClaimantNestedInput
    answers?: AnswerUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutClaimantNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutClaimantNestedInput
    referrer?: ReferrerUpdateOneWithoutClaimantNestedInput
  }

  export type ClaimantUncheckedUpdateWithoutVoiceMailInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUncheckedUpdateManyWithoutClaimantNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUncheckedUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUncheckedUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutClaimantNestedInput
  }

  export type FormSectionCreateWithoutFormInput = {
    name: string
    order?: number
    showTimer?: boolean
    created?: Date | string
    updated?: Date | string
    questions?: QuestionCreateNestedManyWithoutFormSectionInput
    cursor?: CursorCreateNestedManyWithoutFormSectionInput
  }

  export type FormSectionUncheckedCreateWithoutFormInput = {
    id?: number
    name: string
    order?: number
    showTimer?: boolean
    created?: Date | string
    updated?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutFormSectionInput
    cursor?: CursorUncheckedCreateNestedManyWithoutFormSectionInput
  }

  export type FormSectionCreateOrConnectWithoutFormInput = {
    where: FormSectionWhereUniqueInput
    create: XOR<FormSectionCreateWithoutFormInput, FormSectionUncheckedCreateWithoutFormInput>
  }

  export type FormSectionCreateManyFormInputEnvelope = {
    data: Enumerable<FormSectionCreateManyFormInput>
    skipDuplicates?: boolean
  }

  export type FormSectionUpsertWithWhereUniqueWithoutFormInput = {
    where: FormSectionWhereUniqueInput
    update: XOR<FormSectionUpdateWithoutFormInput, FormSectionUncheckedUpdateWithoutFormInput>
    create: XOR<FormSectionCreateWithoutFormInput, FormSectionUncheckedCreateWithoutFormInput>
  }

  export type FormSectionUpdateWithWhereUniqueWithoutFormInput = {
    where: FormSectionWhereUniqueInput
    data: XOR<FormSectionUpdateWithoutFormInput, FormSectionUncheckedUpdateWithoutFormInput>
  }

  export type FormSectionUpdateManyWithWhereWithoutFormInput = {
    where: FormSectionScalarWhereInput
    data: XOR<FormSectionUpdateManyMutationInput, FormSectionUncheckedUpdateManyWithoutFormSectionInput>
  }

  export type FormSectionScalarWhereInput = {
    AND?: Enumerable<FormSectionScalarWhereInput>
    OR?: Enumerable<FormSectionScalarWhereInput>
    NOT?: Enumerable<FormSectionScalarWhereInput>
    id?: IntFilter | number
    formId?: IntFilter | number
    name?: StringFilter | string
    order?: IntFilter | number
    showTimer?: BoolFilter | boolean
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
  }

  export type QuestionCreateWithoutFormSectionInput = {
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerCreateNestedManyWithoutQuestionInput
    options?: OptionCreateNestedManyWithoutQuestionInput
    subform?: SubformCreateNestedOneWithoutQuestionInput
    optionRule?: OptionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionUncheckedCreateWithoutFormSectionInput = {
    id?: number
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
    options?: OptionUncheckedCreateNestedManyWithoutQuestionInput
    subform?: SubformUncheckedCreateNestedOneWithoutQuestionInput
    optionRule?: OptionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionCreateOrConnectWithoutFormSectionInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutFormSectionInput, QuestionUncheckedCreateWithoutFormSectionInput>
  }

  export type QuestionCreateManyFormSectionInputEnvelope = {
    data: Enumerable<QuestionCreateManyFormSectionInput>
    skipDuplicates?: boolean
  }

  export type CursorCreateWithoutFormSectionInput = {
    questionId: number
    created?: Date | string
    updatedAt?: Date | string
    claimant: ClaimantCreateNestedOneWithoutCursorInput
  }

  export type CursorUncheckedCreateWithoutFormSectionInput = {
    id?: number
    questionId: number
    claimantId: number
    created?: Date | string
    updatedAt?: Date | string
  }

  export type CursorCreateOrConnectWithoutFormSectionInput = {
    where: CursorWhereUniqueInput
    create: XOR<CursorCreateWithoutFormSectionInput, CursorUncheckedCreateWithoutFormSectionInput>
  }

  export type CursorCreateManyFormSectionInputEnvelope = {
    data: Enumerable<CursorCreateManyFormSectionInput>
    skipDuplicates?: boolean
  }

  export type FormCreateWithoutFormSectionInput = {
    name: string
    description?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type FormUncheckedCreateWithoutFormSectionInput = {
    id?: number
    name: string
    description?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type FormCreateOrConnectWithoutFormSectionInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutFormSectionInput, FormUncheckedCreateWithoutFormSectionInput>
  }

  export type QuestionUpsertWithWhereUniqueWithoutFormSectionInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutFormSectionInput, QuestionUncheckedUpdateWithoutFormSectionInput>
    create: XOR<QuestionCreateWithoutFormSectionInput, QuestionUncheckedCreateWithoutFormSectionInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutFormSectionInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutFormSectionInput, QuestionUncheckedUpdateWithoutFormSectionInput>
  }

  export type QuestionUpdateManyWithWhereWithoutFormSectionInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: Enumerable<QuestionScalarWhereInput>
    OR?: Enumerable<QuestionScalarWhereInput>
    NOT?: Enumerable<QuestionScalarWhereInput>
    id?: IntFilter | number
    formSectionId?: IntFilter | number
    question?: StringFilter | string
    questionType?: EnumQuestionTypeFilter | QuestionType
    inputType?: EnumInputTypeNullableFilter | InputType | null
    order?: IntFilter | number
    scriptText?: StringFilter | string
    optout?: BoolFilter | boolean
    optoutText?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
  }

  export type CursorUpsertWithWhereUniqueWithoutFormSectionInput = {
    where: CursorWhereUniqueInput
    update: XOR<CursorUpdateWithoutFormSectionInput, CursorUncheckedUpdateWithoutFormSectionInput>
    create: XOR<CursorCreateWithoutFormSectionInput, CursorUncheckedCreateWithoutFormSectionInput>
  }

  export type CursorUpdateWithWhereUniqueWithoutFormSectionInput = {
    where: CursorWhereUniqueInput
    data: XOR<CursorUpdateWithoutFormSectionInput, CursorUncheckedUpdateWithoutFormSectionInput>
  }

  export type CursorUpdateManyWithWhereWithoutFormSectionInput = {
    where: CursorScalarWhereInput
    data: XOR<CursorUpdateManyMutationInput, CursorUncheckedUpdateManyWithoutCursorInput>
  }

  export type FormUpsertWithoutFormSectionInput = {
    update: XOR<FormUpdateWithoutFormSectionInput, FormUncheckedUpdateWithoutFormSectionInput>
    create: XOR<FormCreateWithoutFormSectionInput, FormUncheckedCreateWithoutFormSectionInput>
  }

  export type FormUpdateWithoutFormSectionInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormUncheckedUpdateWithoutFormSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerCreateWithoutQuestionInput = {
    value?: string | null
    created?: Date | string
    updated?: Date | string
    claimant: ClaimantCreateNestedOneWithoutAnswersInput
    option?: OptionCreateNestedOneWithoutAnswerInput
    callSession: CallSessionCreateNestedOneWithoutAnswerInput
  }

  export type AnswerUncheckedCreateWithoutQuestionInput = {
    id?: number
    claimantId: number
    sessionId: number
    optionId?: number | null
    value?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type AnswerCreateOrConnectWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput>
  }

  export type AnswerCreateManyQuestionInputEnvelope = {
    data: Enumerable<AnswerCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type OptionCreateWithoutQuestionInput = {
    label?: string
    value: string
    created?: Date | string
    updatedAt?: Date | string
    rules?: OptionRuleCreateNestedManyWithoutOptionInput
    answer?: AnswerCreateNestedManyWithoutOptionInput
  }

  export type OptionUncheckedCreateWithoutQuestionInput = {
    id?: number
    label?: string
    value: string
    created?: Date | string
    updatedAt?: Date | string
    rules?: OptionRuleUncheckedCreateNestedManyWithoutOptionInput
    answer?: AnswerUncheckedCreateNestedManyWithoutOptionInput
  }

  export type OptionCreateOrConnectWithoutQuestionInput = {
    where: OptionWhereUniqueInput
    create: XOR<OptionCreateWithoutQuestionInput, OptionUncheckedCreateWithoutQuestionInput>
  }

  export type OptionCreateManyQuestionInputEnvelope = {
    data: Enumerable<OptionCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type SubformCreateWithoutQuestionInput = {
    name: string
    created?: Date | string
    updated?: Date | string
    subformFields?: SubformFieldCreateNestedManyWithoutSubFormInput
  }

  export type SubformUncheckedCreateWithoutQuestionInput = {
    id?: number
    name: string
    created?: Date | string
    updated?: Date | string
    subformFields?: SubformFieldUncheckedCreateNestedManyWithoutSubFormInput
  }

  export type SubformCreateOrConnectWithoutQuestionInput = {
    where: SubformWhereUniqueInput
    create: XOR<SubformCreateWithoutQuestionInput, SubformUncheckedCreateWithoutQuestionInput>
  }

  export type FormSectionCreateWithoutQuestionsInput = {
    name: string
    order?: number
    showTimer?: boolean
    created?: Date | string
    updated?: Date | string
    cursor?: CursorCreateNestedManyWithoutFormSectionInput
    form: FormCreateNestedOneWithoutFormSectionInput
  }

  export type FormSectionUncheckedCreateWithoutQuestionsInput = {
    id?: number
    formId: number
    name: string
    order?: number
    showTimer?: boolean
    created?: Date | string
    updated?: Date | string
    cursor?: CursorUncheckedCreateNestedManyWithoutFormSectionInput
  }

  export type FormSectionCreateOrConnectWithoutQuestionsInput = {
    where: FormSectionWhereUniqueInput
    create: XOR<FormSectionCreateWithoutQuestionsInput, FormSectionUncheckedCreateWithoutQuestionsInput>
  }

  export type OptionRuleCreateWithoutQuestionAnswerRefInput = {
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
    option?: OptionCreateNestedOneWithoutRulesInput
    function?: FunctionCreateNestedOneWithoutOptionRuleInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutOptionRuleInput
  }

  export type OptionRuleUncheckedCreateWithoutQuestionAnswerRefInput = {
    id?: number
    optionId?: number | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type OptionRuleCreateOrConnectWithoutQuestionAnswerRefInput = {
    where: OptionRuleWhereUniqueInput
    create: XOR<OptionRuleCreateWithoutQuestionAnswerRefInput, OptionRuleUncheckedCreateWithoutQuestionAnswerRefInput>
  }

  export type OptionRuleCreateManyQuestionAnswerRefInputEnvelope = {
    data: Enumerable<OptionRuleCreateManyQuestionAnswerRefInput>
    skipDuplicates?: boolean
  }

  export type QuestionRuleCreateWithoutQuestionInput = {
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
    questionAnswerRef?: QuestionCreateNestedOneWithoutQuestionAnswerRefInput
    function?: FunctionCreateNestedOneWithoutQuestionRuleInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutQuestionRuleInput
  }

  export type QuestionRuleUncheckedCreateWithoutQuestionInput = {
    id?: number
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    questionAnswerRefId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionRuleCreateOrConnectWithoutQuestionInput = {
    where: QuestionRuleWhereUniqueInput
    create: XOR<QuestionRuleCreateWithoutQuestionInput, QuestionRuleUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionRuleCreateManyQuestionInputEnvelope = {
    data: Enumerable<QuestionRuleCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type QuestionRuleCreateWithoutQuestionAnswerRefInput = {
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
    question?: QuestionCreateNestedOneWithoutRulesInput
    function?: FunctionCreateNestedOneWithoutQuestionRuleInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutQuestionRuleInput
  }

  export type QuestionRuleUncheckedCreateWithoutQuestionAnswerRefInput = {
    id?: number
    questionId?: number | null
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionRuleCreateOrConnectWithoutQuestionAnswerRefInput = {
    where: QuestionRuleWhereUniqueInput
    create: XOR<QuestionRuleCreateWithoutQuestionAnswerRefInput, QuestionRuleUncheckedCreateWithoutQuestionAnswerRefInput>
  }

  export type QuestionRuleCreateManyQuestionAnswerRefInputEnvelope = {
    data: Enumerable<QuestionRuleCreateManyQuestionAnswerRefInput>
    skipDuplicates?: boolean
  }

  export type QuestionFormatRuleCreateWithoutQuestionInput = {
    type: QuestionFormatTypes
    claimantField?: ClaimantFieldRefTypes | null
    created?: Date | string
    updated?: Date | string
    questionAnswerRef?: QuestionCreateNestedOneWithoutQuestionFormatAnswerRefInput
  }

  export type QuestionFormatRuleUncheckedCreateWithoutQuestionInput = {
    id?: number
    type: QuestionFormatTypes
    questionAnswerRefId?: number | null
    claimantField?: ClaimantFieldRefTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionFormatRuleCreateOrConnectWithoutQuestionInput = {
    where: QuestionFormatRuleWhereUniqueInput
    create: XOR<QuestionFormatRuleCreateWithoutQuestionInput, QuestionFormatRuleUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionFormatRuleCreateManyQuestionInputEnvelope = {
    data: Enumerable<QuestionFormatRuleCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type QuestionFormatRuleCreateWithoutQuestionAnswerRefInput = {
    type: QuestionFormatTypes
    claimantField?: ClaimantFieldRefTypes | null
    created?: Date | string
    updated?: Date | string
    question?: QuestionCreateNestedOneWithoutQuestionFormatRuleInput
  }

  export type QuestionFormatRuleUncheckedCreateWithoutQuestionAnswerRefInput = {
    id?: number
    questionId?: number | null
    type: QuestionFormatTypes
    claimantField?: ClaimantFieldRefTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionFormatRuleCreateOrConnectWithoutQuestionAnswerRefInput = {
    where: QuestionFormatRuleWhereUniqueInput
    create: XOR<QuestionFormatRuleCreateWithoutQuestionAnswerRefInput, QuestionFormatRuleUncheckedCreateWithoutQuestionAnswerRefInput>
  }

  export type QuestionFormatRuleCreateManyQuestionAnswerRefInputEnvelope = {
    data: Enumerable<QuestionFormatRuleCreateManyQuestionAnswerRefInput>
    skipDuplicates?: boolean
  }

  export type AnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutQuestionInput, AnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutQuestionInput, AnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type AnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutAnswersInput>
  }

  export type OptionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: OptionWhereUniqueInput
    update: XOR<OptionUpdateWithoutQuestionInput, OptionUncheckedUpdateWithoutQuestionInput>
    create: XOR<OptionCreateWithoutQuestionInput, OptionUncheckedCreateWithoutQuestionInput>
  }

  export type OptionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: OptionWhereUniqueInput
    data: XOR<OptionUpdateWithoutQuestionInput, OptionUncheckedUpdateWithoutQuestionInput>
  }

  export type OptionUpdateManyWithWhereWithoutQuestionInput = {
    where: OptionScalarWhereInput
    data: XOR<OptionUpdateManyMutationInput, OptionUncheckedUpdateManyWithoutOptionsInput>
  }

  export type OptionScalarWhereInput = {
    AND?: Enumerable<OptionScalarWhereInput>
    OR?: Enumerable<OptionScalarWhereInput>
    NOT?: Enumerable<OptionScalarWhereInput>
    id?: IntFilter | number
    questionId?: IntFilter | number
    label?: StringFilter | string
    value?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SubformUpsertWithoutQuestionInput = {
    update: XOR<SubformUpdateWithoutQuestionInput, SubformUncheckedUpdateWithoutQuestionInput>
    create: XOR<SubformCreateWithoutQuestionInput, SubformUncheckedCreateWithoutQuestionInput>
  }

  export type SubformUpdateWithoutQuestionInput = {
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFields?: SubformFieldUpdateManyWithoutSubFormNestedInput
  }

  export type SubformUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFields?: SubformFieldUncheckedUpdateManyWithoutSubFormNestedInput
  }

  export type FormSectionUpsertWithoutQuestionsInput = {
    update: XOR<FormSectionUpdateWithoutQuestionsInput, FormSectionUncheckedUpdateWithoutQuestionsInput>
    create: XOR<FormSectionCreateWithoutQuestionsInput, FormSectionUncheckedCreateWithoutQuestionsInput>
  }

  export type FormSectionUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    showTimer?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUpdateManyWithoutFormSectionNestedInput
    form?: FormUpdateOneRequiredWithoutFormSectionNestedInput
  }

  export type FormSectionUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    showTimer?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUncheckedUpdateManyWithoutFormSectionNestedInput
  }

  export type OptionRuleUpsertWithWhereUniqueWithoutQuestionAnswerRefInput = {
    where: OptionRuleWhereUniqueInput
    update: XOR<OptionRuleUpdateWithoutQuestionAnswerRefInput, OptionRuleUncheckedUpdateWithoutQuestionAnswerRefInput>
    create: XOR<OptionRuleCreateWithoutQuestionAnswerRefInput, OptionRuleUncheckedCreateWithoutQuestionAnswerRefInput>
  }

  export type OptionRuleUpdateWithWhereUniqueWithoutQuestionAnswerRefInput = {
    where: OptionRuleWhereUniqueInput
    data: XOR<OptionRuleUpdateWithoutQuestionAnswerRefInput, OptionRuleUncheckedUpdateWithoutQuestionAnswerRefInput>
  }

  export type OptionRuleUpdateManyWithWhereWithoutQuestionAnswerRefInput = {
    where: OptionRuleScalarWhereInput
    data: XOR<OptionRuleUpdateManyMutationInput, OptionRuleUncheckedUpdateManyWithoutOptionRuleInput>
  }

  export type OptionRuleScalarWhereInput = {
    AND?: Enumerable<OptionRuleScalarWhereInput>
    OR?: Enumerable<OptionRuleScalarWhereInput>
    NOT?: Enumerable<OptionRuleScalarWhereInput>
    id?: IntFilter | number
    optionId?: IntNullableFilter | number | null
    type?: EnumRuleTypeFilter | RuleType
    value?: IntNullableFilter | number | null
    operator?: EnumOperatorOptionNullableFilter | OperatorOption | null
    comparisonValue?: StringNullableFilter | string | null
    functionId?: IntNullableFilter | number | null
    questionAnswerRefId?: IntNullableFilter | number | null
    ssaStatusId?: IntNullableFilter | number | null
    isReferrerPayType?: EnumReferrerPayTypesNullableFilter | ReferrerPayTypes | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
  }

  export type QuestionRuleUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionRuleWhereUniqueInput
    update: XOR<QuestionRuleUpdateWithoutQuestionInput, QuestionRuleUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionRuleCreateWithoutQuestionInput, QuestionRuleUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionRuleUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionRuleWhereUniqueInput
    data: XOR<QuestionRuleUpdateWithoutQuestionInput, QuestionRuleUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionRuleUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionRuleScalarWhereInput
    data: XOR<QuestionRuleUpdateManyMutationInput, QuestionRuleUncheckedUpdateManyWithoutRulesInput>
  }

  export type QuestionRuleScalarWhereInput = {
    AND?: Enumerable<QuestionRuleScalarWhereInput>
    OR?: Enumerable<QuestionRuleScalarWhereInput>
    NOT?: Enumerable<QuestionRuleScalarWhereInput>
    id?: IntFilter | number
    questionId?: IntNullableFilter | number | null
    optout?: BoolNullableFilter | boolean | null
    type?: EnumRuleTypeFilter | RuleType
    value?: IntNullableFilter | number | null
    operator?: EnumOperatorOptionNullableFilter | OperatorOption | null
    comparisonValue?: StringNullableFilter | string | null
    functionId?: IntNullableFilter | number | null
    questionAnswerRefId?: IntNullableFilter | number | null
    ssaStatusId?: IntNullableFilter | number | null
    isReferrerPayType?: EnumReferrerPayTypesNullableFilter | ReferrerPayTypes | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
  }

  export type QuestionRuleUpsertWithWhereUniqueWithoutQuestionAnswerRefInput = {
    where: QuestionRuleWhereUniqueInput
    update: XOR<QuestionRuleUpdateWithoutQuestionAnswerRefInput, QuestionRuleUncheckedUpdateWithoutQuestionAnswerRefInput>
    create: XOR<QuestionRuleCreateWithoutQuestionAnswerRefInput, QuestionRuleUncheckedCreateWithoutQuestionAnswerRefInput>
  }

  export type QuestionRuleUpdateWithWhereUniqueWithoutQuestionAnswerRefInput = {
    where: QuestionRuleWhereUniqueInput
    data: XOR<QuestionRuleUpdateWithoutQuestionAnswerRefInput, QuestionRuleUncheckedUpdateWithoutQuestionAnswerRefInput>
  }

  export type QuestionRuleUpdateManyWithWhereWithoutQuestionAnswerRefInput = {
    where: QuestionRuleScalarWhereInput
    data: XOR<QuestionRuleUpdateManyMutationInput, QuestionRuleUncheckedUpdateManyWithoutQuestionAnswerRefInput>
  }

  export type QuestionFormatRuleUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionFormatRuleWhereUniqueInput
    update: XOR<QuestionFormatRuleUpdateWithoutQuestionInput, QuestionFormatRuleUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionFormatRuleCreateWithoutQuestionInput, QuestionFormatRuleUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionFormatRuleUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionFormatRuleWhereUniqueInput
    data: XOR<QuestionFormatRuleUpdateWithoutQuestionInput, QuestionFormatRuleUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionFormatRuleUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionFormatRuleScalarWhereInput
    data: XOR<QuestionFormatRuleUpdateManyMutationInput, QuestionFormatRuleUncheckedUpdateManyWithoutQuestionFormatRuleInput>
  }

  export type QuestionFormatRuleScalarWhereInput = {
    AND?: Enumerable<QuestionFormatRuleScalarWhereInput>
    OR?: Enumerable<QuestionFormatRuleScalarWhereInput>
    NOT?: Enumerable<QuestionFormatRuleScalarWhereInput>
    id?: IntFilter | number
    questionId?: IntNullableFilter | number | null
    type?: EnumQuestionFormatTypesFilter | QuestionFormatTypes
    questionAnswerRefId?: IntNullableFilter | number | null
    claimantField?: EnumClaimantFieldRefTypesNullableFilter | ClaimantFieldRefTypes | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
  }

  export type QuestionFormatRuleUpsertWithWhereUniqueWithoutQuestionAnswerRefInput = {
    where: QuestionFormatRuleWhereUniqueInput
    update: XOR<QuestionFormatRuleUpdateWithoutQuestionAnswerRefInput, QuestionFormatRuleUncheckedUpdateWithoutQuestionAnswerRefInput>
    create: XOR<QuestionFormatRuleCreateWithoutQuestionAnswerRefInput, QuestionFormatRuleUncheckedCreateWithoutQuestionAnswerRefInput>
  }

  export type QuestionFormatRuleUpdateWithWhereUniqueWithoutQuestionAnswerRefInput = {
    where: QuestionFormatRuleWhereUniqueInput
    data: XOR<QuestionFormatRuleUpdateWithoutQuestionAnswerRefInput, QuestionFormatRuleUncheckedUpdateWithoutQuestionAnswerRefInput>
  }

  export type QuestionFormatRuleUpdateManyWithWhereWithoutQuestionAnswerRefInput = {
    where: QuestionFormatRuleScalarWhereInput
    data: XOR<QuestionFormatRuleUpdateManyMutationInput, QuestionFormatRuleUncheckedUpdateManyWithoutQuestionFormatAnswerRefInput>
  }

  export type QuestionCreateWithoutAnswersInput = {
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    options?: OptionCreateNestedManyWithoutQuestionInput
    subform?: SubformCreateNestedOneWithoutQuestionInput
    formSection: FormSectionCreateNestedOneWithoutQuestionsInput
    optionRule?: OptionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionUncheckedCreateWithoutAnswersInput = {
    id?: number
    formSectionId: number
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    options?: OptionUncheckedCreateNestedManyWithoutQuestionInput
    subform?: SubformUncheckedCreateNestedOneWithoutQuestionInput
    optionRule?: OptionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionCreateOrConnectWithoutAnswersInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
  }

  export type ClaimantCreateWithoutAnswersInput = {
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutClaimantInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutClaimantInput
    referrer?: ReferrerCreateNestedOneWithoutClaimantInput
    VoiceMail?: VoiceMailCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantUncheckedCreateWithoutAnswersInput = {
    id?: number
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    referrerId?: number | null
    ssaStatusId?: number | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorUncheckedCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointUncheckedCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutClaimantInput
    VoiceMail?: VoiceMailUncheckedCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantCreateOrConnectWithoutAnswersInput = {
    where: ClaimantWhereUniqueInput
    create: XOR<ClaimantCreateWithoutAnswersInput, ClaimantUncheckedCreateWithoutAnswersInput>
  }

  export type OptionCreateWithoutAnswerInput = {
    label?: string
    value: string
    created?: Date | string
    updatedAt?: Date | string
    rules?: OptionRuleCreateNestedManyWithoutOptionInput
    question: QuestionCreateNestedOneWithoutOptionsInput
  }

  export type OptionUncheckedCreateWithoutAnswerInput = {
    id?: number
    questionId: number
    label?: string
    value: string
    created?: Date | string
    updatedAt?: Date | string
    rules?: OptionRuleUncheckedCreateNestedManyWithoutOptionInput
  }

  export type OptionCreateOrConnectWithoutAnswerInput = {
    where: OptionWhereUniqueInput
    create: XOR<OptionCreateWithoutAnswerInput, OptionUncheckedCreateWithoutAnswerInput>
  }

  export type CallSessionCreateWithoutAnswerInput = {
    sessionType: SessionTypes
    sessionStatus?: SessionStatuses | null
    created?: Date | string
    ended?: Date | string | null
    updated?: Date | string
    user: UserCreateNestedOneWithoutCallSessionsInput
    claimant: ClaimantCreateNestedOneWithoutCallSessionsInput
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutSessionInput
    recordingUrl?: string | null
    outgoingPhone: string
  }

  export type CallSessionUncheckedCreateWithoutAnswerInput = {
    id?: number
    userId: number
    claimantId: number
    sessionType: SessionTypes
    sessionStatus?: SessionStatuses | null
    created?: Date | string
    ended?: Date | string | null
    updated?: Date | string
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutSessionInput
    recordingUrl?: string | null
    outgoingPhone: string
  }

  export type CallSessionCreateOrConnectWithoutAnswerInput = {
    where: CallSessionWhereUniqueInput
    create: XOR<CallSessionCreateWithoutAnswerInput, CallSessionUncheckedCreateWithoutAnswerInput>
  }

  export type QuestionUpsertWithoutAnswersInput = {
    update: XOR<QuestionUpdateWithoutAnswersInput, QuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
  }

  export type QuestionUpdateWithoutAnswersInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: OptionUpdateManyWithoutQuestionNestedInput
    subform?: SubformUpdateOneWithoutQuestionNestedInput
    formSection?: FormSectionUpdateOneRequiredWithoutQuestionsNestedInput
    optionRule?: OptionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type QuestionUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    formSectionId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: OptionUncheckedUpdateManyWithoutQuestionNestedInput
    subform?: SubformUncheckedUpdateOneWithoutQuestionNestedInput
    optionRule?: OptionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type ClaimantUpsertWithoutAnswersInput = {
    update: XOR<ClaimantUpdateWithoutAnswersInput, ClaimantUncheckedUpdateWithoutAnswersInput>
    create: XOR<ClaimantCreateWithoutAnswersInput, ClaimantUncheckedCreateWithoutAnswersInput>
  }

  export type ClaimantUpdateWithoutAnswersInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutClaimantNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutClaimantNestedInput
    referrer?: ReferrerUpdateOneWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUpdateManyWithoutClaimantNestedInput
  }

  export type ClaimantUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUncheckedUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUncheckedUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUncheckedUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUncheckedUpdateManyWithoutClaimantNestedInput
  }

  export type OptionUpsertWithoutAnswerInput = {
    update: XOR<OptionUpdateWithoutAnswerInput, OptionUncheckedUpdateWithoutAnswerInput>
    create: XOR<OptionCreateWithoutAnswerInput, OptionUncheckedCreateWithoutAnswerInput>
  }

  export type OptionUpdateWithoutAnswerInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: OptionRuleUpdateManyWithoutOptionNestedInput
    question?: QuestionUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type OptionUncheckedUpdateWithoutAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: OptionRuleUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type CallSessionUpsertWithoutAnswerInput = {
    update: XOR<CallSessionUpdateWithoutAnswerInput, CallSessionUncheckedUpdateWithoutAnswerInput>
    create: XOR<CallSessionCreateWithoutAnswerInput, CallSessionUncheckedCreateWithoutAnswerInput>
  }

  export type CallSessionUpdateWithoutAnswerInput = {
    sessionType?: EnumSessionTypesFieldUpdateOperationsInput | SessionTypes
    sessionStatus?: NullableEnumSessionStatusesFieldUpdateOperationsInput | SessionStatuses | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCallSessionsNestedInput
    claimant?: ClaimantUpdateOneRequiredWithoutCallSessionsNestedInput
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutSessionNestedInput
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    outgoingPhone?: StringFieldUpdateOperationsInput | string
  }

  export type CallSessionUncheckedUpdateWithoutAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    sessionType?: EnumSessionTypesFieldUpdateOperationsInput | SessionTypes
    sessionStatus?: NullableEnumSessionStatusesFieldUpdateOperationsInput | SessionStatuses | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutSessionNestedInput
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    outgoingPhone?: StringFieldUpdateOperationsInput | string
  }

  export type SubformFieldCreateWithoutSubFormInput = {
    fieldType: SubFormFieldType
    inputType?: InputType | null
    max?: number | null
    name: string
    label: string
    required?: boolean
    created?: Date | string
    updated?: Date | string
    subformFieldOptions?: SubformFieldOptionCreateNestedManyWithoutSubformFieldInput
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutSubformFieldInput
  }

  export type SubformFieldUncheckedCreateWithoutSubFormInput = {
    id?: number
    fieldType: SubFormFieldType
    inputType?: InputType | null
    max?: number | null
    name: string
    label: string
    required?: boolean
    created?: Date | string
    updated?: Date | string
    subformFieldOptions?: SubformFieldOptionUncheckedCreateNestedManyWithoutSubformFieldInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutSubformFieldInput
  }

  export type SubformFieldCreateOrConnectWithoutSubFormInput = {
    where: SubformFieldWhereUniqueInput
    create: XOR<SubformFieldCreateWithoutSubFormInput, SubformFieldUncheckedCreateWithoutSubFormInput>
  }

  export type SubformFieldCreateManySubFormInputEnvelope = {
    data: Enumerable<SubformFieldCreateManySubFormInput>
    skipDuplicates?: boolean
  }

  export type QuestionCreateWithoutSubformInput = {
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerCreateNestedManyWithoutQuestionInput
    options?: OptionCreateNestedManyWithoutQuestionInput
    formSection: FormSectionCreateNestedOneWithoutQuestionsInput
    optionRule?: OptionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionUncheckedCreateWithoutSubformInput = {
    id?: number
    formSectionId: number
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
    options?: OptionUncheckedCreateNestedManyWithoutQuestionInput
    optionRule?: OptionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionCreateOrConnectWithoutSubformInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutSubformInput, QuestionUncheckedCreateWithoutSubformInput>
  }

  export type SubformFieldUpsertWithWhereUniqueWithoutSubFormInput = {
    where: SubformFieldWhereUniqueInput
    update: XOR<SubformFieldUpdateWithoutSubFormInput, SubformFieldUncheckedUpdateWithoutSubFormInput>
    create: XOR<SubformFieldCreateWithoutSubFormInput, SubformFieldUncheckedCreateWithoutSubFormInput>
  }

  export type SubformFieldUpdateWithWhereUniqueWithoutSubFormInput = {
    where: SubformFieldWhereUniqueInput
    data: XOR<SubformFieldUpdateWithoutSubFormInput, SubformFieldUncheckedUpdateWithoutSubFormInput>
  }

  export type SubformFieldUpdateManyWithWhereWithoutSubFormInput = {
    where: SubformFieldScalarWhereInput
    data: XOR<SubformFieldUpdateManyMutationInput, SubformFieldUncheckedUpdateManyWithoutSubformFieldsInput>
  }

  export type SubformFieldScalarWhereInput = {
    AND?: Enumerable<SubformFieldScalarWhereInput>
    OR?: Enumerable<SubformFieldScalarWhereInput>
    NOT?: Enumerable<SubformFieldScalarWhereInput>
    id?: IntFilter | number
    subformId?: IntFilter | number
    fieldType?: EnumSubFormFieldTypeFilter | SubFormFieldType
    inputType?: EnumInputTypeNullableFilter | InputType | null
    max?: IntNullableFilter | number | null
    name?: StringFilter | string
    label?: StringFilter | string
    required?: BoolFilter | boolean
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
  }

  export type QuestionUpsertWithoutSubformInput = {
    update: XOR<QuestionUpdateWithoutSubformInput, QuestionUncheckedUpdateWithoutSubformInput>
    create: XOR<QuestionCreateWithoutSubformInput, QuestionUncheckedCreateWithoutSubformInput>
  }

  export type QuestionUpdateWithoutSubformInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
    options?: OptionUpdateManyWithoutQuestionNestedInput
    formSection?: FormSectionUpdateOneRequiredWithoutQuestionsNestedInput
    optionRule?: OptionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type QuestionUncheckedUpdateWithoutSubformInput = {
    id?: IntFieldUpdateOperationsInput | number
    formSectionId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
    options?: OptionUncheckedUpdateManyWithoutQuestionNestedInput
    optionRule?: OptionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type SubformFieldOptionCreateWithoutSubformFieldInput = {
    label: string
    value: string
    created?: Date | string
    updated?: Date | string
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutSubformFieldOpionInput
  }

  export type SubformFieldOptionUncheckedCreateWithoutSubformFieldInput = {
    id?: number
    label: string
    value: string
    created?: Date | string
    updated?: Date | string
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutSubformFieldOpionInput
  }

  export type SubformFieldOptionCreateOrConnectWithoutSubformFieldInput = {
    where: SubformFieldOptionWhereUniqueInput
    create: XOR<SubformFieldOptionCreateWithoutSubformFieldInput, SubformFieldOptionUncheckedCreateWithoutSubformFieldInput>
  }

  export type SubformFieldOptionCreateManySubformFieldInputEnvelope = {
    data: Enumerable<SubformFieldOptionCreateManySubformFieldInput>
    skipDuplicates?: boolean
  }

  export type SubformFieldAnswerCreateWithoutSubformFieldInput = {
    value?: string | null
    created?: Date | string
    updated?: Date | string
    subformFieldOpion?: SubformFieldOptionCreateNestedOneWithoutSubformFieldAnswerInput
    claimant: ClaimantCreateNestedOneWithoutSubformFieldAnswerInput
    session: CallSessionCreateNestedOneWithoutSubformFieldAnswerInput
  }

  export type SubformFieldAnswerUncheckedCreateWithoutSubformFieldInput = {
    id?: number
    claimantId: number
    sessionId: number
    value?: string | null
    optionId?: number | null
    created?: Date | string
    updated?: Date | string
  }

  export type SubformFieldAnswerCreateOrConnectWithoutSubformFieldInput = {
    where: SubformFieldAnswerWhereUniqueInput
    create: XOR<SubformFieldAnswerCreateWithoutSubformFieldInput, SubformFieldAnswerUncheckedCreateWithoutSubformFieldInput>
  }

  export type SubformFieldAnswerCreateManySubformFieldInputEnvelope = {
    data: Enumerable<SubformFieldAnswerCreateManySubformFieldInput>
    skipDuplicates?: boolean
  }

  export type SubformCreateWithoutSubformFieldsInput = {
    name: string
    created?: Date | string
    updated?: Date | string
    question: QuestionCreateNestedOneWithoutSubformInput
  }

  export type SubformUncheckedCreateWithoutSubformFieldsInput = {
    id?: number
    questionId: number
    name: string
    created?: Date | string
    updated?: Date | string
  }

  export type SubformCreateOrConnectWithoutSubformFieldsInput = {
    where: SubformWhereUniqueInput
    create: XOR<SubformCreateWithoutSubformFieldsInput, SubformUncheckedCreateWithoutSubformFieldsInput>
  }

  export type SubformFieldOptionUpsertWithWhereUniqueWithoutSubformFieldInput = {
    where: SubformFieldOptionWhereUniqueInput
    update: XOR<SubformFieldOptionUpdateWithoutSubformFieldInput, SubformFieldOptionUncheckedUpdateWithoutSubformFieldInput>
    create: XOR<SubformFieldOptionCreateWithoutSubformFieldInput, SubformFieldOptionUncheckedCreateWithoutSubformFieldInput>
  }

  export type SubformFieldOptionUpdateWithWhereUniqueWithoutSubformFieldInput = {
    where: SubformFieldOptionWhereUniqueInput
    data: XOR<SubformFieldOptionUpdateWithoutSubformFieldInput, SubformFieldOptionUncheckedUpdateWithoutSubformFieldInput>
  }

  export type SubformFieldOptionUpdateManyWithWhereWithoutSubformFieldInput = {
    where: SubformFieldOptionScalarWhereInput
    data: XOR<SubformFieldOptionUpdateManyMutationInput, SubformFieldOptionUncheckedUpdateManyWithoutSubformFieldOptionsInput>
  }

  export type SubformFieldOptionScalarWhereInput = {
    AND?: Enumerable<SubformFieldOptionScalarWhereInput>
    OR?: Enumerable<SubformFieldOptionScalarWhereInput>
    NOT?: Enumerable<SubformFieldOptionScalarWhereInput>
    id?: IntFilter | number
    subformFieldId?: IntFilter | number
    label?: StringFilter | string
    value?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
  }

  export type SubformFieldAnswerUpsertWithWhereUniqueWithoutSubformFieldInput = {
    where: SubformFieldAnswerWhereUniqueInput
    update: XOR<SubformFieldAnswerUpdateWithoutSubformFieldInput, SubformFieldAnswerUncheckedUpdateWithoutSubformFieldInput>
    create: XOR<SubformFieldAnswerCreateWithoutSubformFieldInput, SubformFieldAnswerUncheckedCreateWithoutSubformFieldInput>
  }

  export type SubformFieldAnswerUpdateWithWhereUniqueWithoutSubformFieldInput = {
    where: SubformFieldAnswerWhereUniqueInput
    data: XOR<SubformFieldAnswerUpdateWithoutSubformFieldInput, SubformFieldAnswerUncheckedUpdateWithoutSubformFieldInput>
  }

  export type SubformFieldAnswerUpdateManyWithWhereWithoutSubformFieldInput = {
    where: SubformFieldAnswerScalarWhereInput
    data: XOR<SubformFieldAnswerUpdateManyMutationInput, SubformFieldAnswerUncheckedUpdateManyWithoutSubformFieldAnswerInput>
  }

  export type SubformUpsertWithoutSubformFieldsInput = {
    update: XOR<SubformUpdateWithoutSubformFieldsInput, SubformUncheckedUpdateWithoutSubformFieldsInput>
    create: XOR<SubformCreateWithoutSubformFieldsInput, SubformUncheckedCreateWithoutSubformFieldsInput>
  }

  export type SubformUpdateWithoutSubformFieldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutSubformNestedInput
  }

  export type SubformUncheckedUpdateWithoutSubformFieldsInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformFieldAnswerCreateWithoutSubformFieldOpionInput = {
    value?: string | null
    created?: Date | string
    updated?: Date | string
    subformField: SubformFieldCreateNestedOneWithoutSubformFieldAnswerInput
    claimant: ClaimantCreateNestedOneWithoutSubformFieldAnswerInput
    session: CallSessionCreateNestedOneWithoutSubformFieldAnswerInput
  }

  export type SubformFieldAnswerUncheckedCreateWithoutSubformFieldOpionInput = {
    id?: number
    subformFieldId: number
    claimantId: number
    sessionId: number
    value?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type SubformFieldAnswerCreateOrConnectWithoutSubformFieldOpionInput = {
    where: SubformFieldAnswerWhereUniqueInput
    create: XOR<SubformFieldAnswerCreateWithoutSubformFieldOpionInput, SubformFieldAnswerUncheckedCreateWithoutSubformFieldOpionInput>
  }

  export type SubformFieldAnswerCreateManySubformFieldOpionInputEnvelope = {
    data: Enumerable<SubformFieldAnswerCreateManySubformFieldOpionInput>
    skipDuplicates?: boolean
  }

  export type SubformFieldCreateWithoutSubformFieldOptionsInput = {
    fieldType: SubFormFieldType
    inputType?: InputType | null
    max?: number | null
    name: string
    label: string
    required?: boolean
    created?: Date | string
    updated?: Date | string
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutSubformFieldInput
    subForm: SubformCreateNestedOneWithoutSubformFieldsInput
  }

  export type SubformFieldUncheckedCreateWithoutSubformFieldOptionsInput = {
    id?: number
    subformId: number
    fieldType: SubFormFieldType
    inputType?: InputType | null
    max?: number | null
    name: string
    label: string
    required?: boolean
    created?: Date | string
    updated?: Date | string
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutSubformFieldInput
  }

  export type SubformFieldCreateOrConnectWithoutSubformFieldOptionsInput = {
    where: SubformFieldWhereUniqueInput
    create: XOR<SubformFieldCreateWithoutSubformFieldOptionsInput, SubformFieldUncheckedCreateWithoutSubformFieldOptionsInput>
  }

  export type SubformFieldAnswerUpsertWithWhereUniqueWithoutSubformFieldOpionInput = {
    where: SubformFieldAnswerWhereUniqueInput
    update: XOR<SubformFieldAnswerUpdateWithoutSubformFieldOpionInput, SubformFieldAnswerUncheckedUpdateWithoutSubformFieldOpionInput>
    create: XOR<SubformFieldAnswerCreateWithoutSubformFieldOpionInput, SubformFieldAnswerUncheckedCreateWithoutSubformFieldOpionInput>
  }

  export type SubformFieldAnswerUpdateWithWhereUniqueWithoutSubformFieldOpionInput = {
    where: SubformFieldAnswerWhereUniqueInput
    data: XOR<SubformFieldAnswerUpdateWithoutSubformFieldOpionInput, SubformFieldAnswerUncheckedUpdateWithoutSubformFieldOpionInput>
  }

  export type SubformFieldAnswerUpdateManyWithWhereWithoutSubformFieldOpionInput = {
    where: SubformFieldAnswerScalarWhereInput
    data: XOR<SubformFieldAnswerUpdateManyMutationInput, SubformFieldAnswerUncheckedUpdateManyWithoutSubformFieldAnswerInput>
  }

  export type SubformFieldUpsertWithoutSubformFieldOptionsInput = {
    update: XOR<SubformFieldUpdateWithoutSubformFieldOptionsInput, SubformFieldUncheckedUpdateWithoutSubformFieldOptionsInput>
    create: XOR<SubformFieldCreateWithoutSubformFieldOptionsInput, SubformFieldUncheckedCreateWithoutSubformFieldOptionsInput>
  }

  export type SubformFieldUpdateWithoutSubformFieldOptionsInput = {
    fieldType?: EnumSubFormFieldTypeFieldUpdateOperationsInput | SubFormFieldType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    max?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutSubformFieldNestedInput
    subForm?: SubformUpdateOneRequiredWithoutSubformFieldsNestedInput
  }

  export type SubformFieldUncheckedUpdateWithoutSubformFieldOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    subformId?: IntFieldUpdateOperationsInput | number
    fieldType?: EnumSubFormFieldTypeFieldUpdateOperationsInput | SubFormFieldType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    max?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutSubformFieldNestedInput
  }

  export type SubformFieldCreateWithoutSubformFieldAnswerInput = {
    fieldType: SubFormFieldType
    inputType?: InputType | null
    max?: number | null
    name: string
    label: string
    required?: boolean
    created?: Date | string
    updated?: Date | string
    subformFieldOptions?: SubformFieldOptionCreateNestedManyWithoutSubformFieldInput
    subForm: SubformCreateNestedOneWithoutSubformFieldsInput
  }

  export type SubformFieldUncheckedCreateWithoutSubformFieldAnswerInput = {
    id?: number
    subformId: number
    fieldType: SubFormFieldType
    inputType?: InputType | null
    max?: number | null
    name: string
    label: string
    required?: boolean
    created?: Date | string
    updated?: Date | string
    subformFieldOptions?: SubformFieldOptionUncheckedCreateNestedManyWithoutSubformFieldInput
  }

  export type SubformFieldCreateOrConnectWithoutSubformFieldAnswerInput = {
    where: SubformFieldWhereUniqueInput
    create: XOR<SubformFieldCreateWithoutSubformFieldAnswerInput, SubformFieldUncheckedCreateWithoutSubformFieldAnswerInput>
  }

  export type SubformFieldOptionCreateWithoutSubformFieldAnswerInput = {
    label: string
    value: string
    created?: Date | string
    updated?: Date | string
    subformField: SubformFieldCreateNestedOneWithoutSubformFieldOptionsInput
  }

  export type SubformFieldOptionUncheckedCreateWithoutSubformFieldAnswerInput = {
    id?: number
    subformFieldId: number
    label: string
    value: string
    created?: Date | string
    updated?: Date | string
  }

  export type SubformFieldOptionCreateOrConnectWithoutSubformFieldAnswerInput = {
    where: SubformFieldOptionWhereUniqueInput
    create: XOR<SubformFieldOptionCreateWithoutSubformFieldAnswerInput, SubformFieldOptionUncheckedCreateWithoutSubformFieldAnswerInput>
  }

  export type ClaimantCreateWithoutSubformFieldAnswerInput = {
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorCreateNestedManyWithoutClaimantInput
    answers?: AnswerCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionCreateNestedManyWithoutClaimantInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutClaimantInput
    referrer?: ReferrerCreateNestedOneWithoutClaimantInput
    VoiceMail?: VoiceMailCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantUncheckedCreateWithoutSubformFieldAnswerInput = {
    id?: number
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    referrerId?: number | null
    ssaStatusId?: number | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorUncheckedCreateNestedManyWithoutClaimantInput
    answers?: AnswerUncheckedCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointUncheckedCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutClaimantInput
    VoiceMail?: VoiceMailUncheckedCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantCreateOrConnectWithoutSubformFieldAnswerInput = {
    where: ClaimantWhereUniqueInput
    create: XOR<ClaimantCreateWithoutSubformFieldAnswerInput, ClaimantUncheckedCreateWithoutSubformFieldAnswerInput>
  }

  export type CallSessionCreateWithoutSubformFieldAnswerInput = {
    sessionType: SessionTypes
    sessionStatus?: SessionStatuses | null
    created?: Date | string
    ended?: Date | string | null
    updated?: Date | string
    user: UserCreateNestedOneWithoutCallSessionsInput
    claimant: ClaimantCreateNestedOneWithoutCallSessionsInput
    answer?: AnswerCreateNestedManyWithoutCallSessionInput
    recordingUrl?: string | null
    outgoingPhone: string
  }

  export type CallSessionUncheckedCreateWithoutSubformFieldAnswerInput = {
    id?: number
    userId: number
    claimantId: number
    sessionType: SessionTypes
    sessionStatus?: SessionStatuses | null
    created?: Date | string
    ended?: Date | string | null
    updated?: Date | string
    answer?: AnswerUncheckedCreateNestedManyWithoutCallSessionInput
    recordingUrl?: string | null
    outgoingPhone: string
  }

  export type CallSessionCreateOrConnectWithoutSubformFieldAnswerInput = {
    where: CallSessionWhereUniqueInput
    create: XOR<CallSessionCreateWithoutSubformFieldAnswerInput, CallSessionUncheckedCreateWithoutSubformFieldAnswerInput>
  }

  export type SubformFieldUpsertWithoutSubformFieldAnswerInput = {
    update: XOR<SubformFieldUpdateWithoutSubformFieldAnswerInput, SubformFieldUncheckedUpdateWithoutSubformFieldAnswerInput>
    create: XOR<SubformFieldCreateWithoutSubformFieldAnswerInput, SubformFieldUncheckedCreateWithoutSubformFieldAnswerInput>
  }

  export type SubformFieldUpdateWithoutSubformFieldAnswerInput = {
    fieldType?: EnumSubFormFieldTypeFieldUpdateOperationsInput | SubFormFieldType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    max?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFieldOptions?: SubformFieldOptionUpdateManyWithoutSubformFieldNestedInput
    subForm?: SubformUpdateOneRequiredWithoutSubformFieldsNestedInput
  }

  export type SubformFieldUncheckedUpdateWithoutSubformFieldAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    subformId?: IntFieldUpdateOperationsInput | number
    fieldType?: EnumSubFormFieldTypeFieldUpdateOperationsInput | SubFormFieldType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    max?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFieldOptions?: SubformFieldOptionUncheckedUpdateManyWithoutSubformFieldNestedInput
  }

  export type SubformFieldOptionUpsertWithoutSubformFieldAnswerInput = {
    update: XOR<SubformFieldOptionUpdateWithoutSubformFieldAnswerInput, SubformFieldOptionUncheckedUpdateWithoutSubformFieldAnswerInput>
    create: XOR<SubformFieldOptionCreateWithoutSubformFieldAnswerInput, SubformFieldOptionUncheckedCreateWithoutSubformFieldAnswerInput>
  }

  export type SubformFieldOptionUpdateWithoutSubformFieldAnswerInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformField?: SubformFieldUpdateOneRequiredWithoutSubformFieldOptionsNestedInput
  }

  export type SubformFieldOptionUncheckedUpdateWithoutSubformFieldAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    subformFieldId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimantUpsertWithoutSubformFieldAnswerInput = {
    update: XOR<ClaimantUpdateWithoutSubformFieldAnswerInput, ClaimantUncheckedUpdateWithoutSubformFieldAnswerInput>
    create: XOR<ClaimantCreateWithoutSubformFieldAnswerInput, ClaimantUncheckedCreateWithoutSubformFieldAnswerInput>
  }

  export type ClaimantUpdateWithoutSubformFieldAnswerInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUpdateManyWithoutClaimantNestedInput
    answers?: AnswerUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUpdateManyWithoutClaimantNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutClaimantNestedInput
    referrer?: ReferrerUpdateOneWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUpdateManyWithoutClaimantNestedInput
  }

  export type ClaimantUncheckedUpdateWithoutSubformFieldAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUncheckedUpdateManyWithoutClaimantNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUncheckedUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUncheckedUpdateManyWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUncheckedUpdateManyWithoutClaimantNestedInput
  }

  export type CallSessionUpsertWithoutSubformFieldAnswerInput = {
    update: XOR<CallSessionUpdateWithoutSubformFieldAnswerInput, CallSessionUncheckedUpdateWithoutSubformFieldAnswerInput>
    create: XOR<CallSessionCreateWithoutSubformFieldAnswerInput, CallSessionUncheckedCreateWithoutSubformFieldAnswerInput>
  }

  export type CallSessionUpdateWithoutSubformFieldAnswerInput = {
    sessionType?: EnumSessionTypesFieldUpdateOperationsInput | SessionTypes
    sessionStatus?: NullableEnumSessionStatusesFieldUpdateOperationsInput | SessionStatuses | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCallSessionsNestedInput
    claimant?: ClaimantUpdateOneRequiredWithoutCallSessionsNestedInput
    answer?: AnswerUpdateManyWithoutCallSessionNestedInput
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    outgoingPhone?: StringFieldUpdateOperationsInput | string
  }

  export type CallSessionUncheckedUpdateWithoutSubformFieldAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    sessionType?: EnumSessionTypesFieldUpdateOperationsInput | SessionTypes
    sessionStatus?: NullableEnumSessionStatusesFieldUpdateOperationsInput | SessionStatuses | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: AnswerUncheckedUpdateManyWithoutCallSessionNestedInput
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    outgoingPhone?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimantCreateWithoutCursorInput = {
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    created?: Date | string
    updated?: Date | string
    answers?: AnswerCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutClaimantInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutClaimantInput
    referrer?: ReferrerCreateNestedOneWithoutClaimantInput
    VoiceMail?: VoiceMailCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantUncheckedCreateWithoutCursorInput = {
    id?: number
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    referrerId?: number | null
    ssaStatusId?: number | null
    created?: Date | string
    updated?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointUncheckedCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutClaimantInput
    VoiceMail?: VoiceMailUncheckedCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantCreateOrConnectWithoutCursorInput = {
    where: ClaimantWhereUniqueInput
    create: XOR<ClaimantCreateWithoutCursorInput, ClaimantUncheckedCreateWithoutCursorInput>
  }

  export type FormSectionCreateWithoutCursorInput = {
    name: string
    order?: number
    showTimer?: boolean
    created?: Date | string
    updated?: Date | string
    questions?: QuestionCreateNestedManyWithoutFormSectionInput
    form: FormCreateNestedOneWithoutFormSectionInput
  }

  export type FormSectionUncheckedCreateWithoutCursorInput = {
    id?: number
    formId: number
    name: string
    order?: number
    showTimer?: boolean
    created?: Date | string
    updated?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutFormSectionInput
  }

  export type FormSectionCreateOrConnectWithoutCursorInput = {
    where: FormSectionWhereUniqueInput
    create: XOR<FormSectionCreateWithoutCursorInput, FormSectionUncheckedCreateWithoutCursorInput>
  }

  export type ClaimantUpsertWithoutCursorInput = {
    update: XOR<ClaimantUpdateWithoutCursorInput, ClaimantUncheckedUpdateWithoutCursorInput>
    create: XOR<ClaimantCreateWithoutCursorInput, ClaimantUncheckedCreateWithoutCursorInput>
  }

  export type ClaimantUpdateWithoutCursorInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutClaimantNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutClaimantNestedInput
    referrer?: ReferrerUpdateOneWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUpdateManyWithoutClaimantNestedInput
  }

  export type ClaimantUncheckedUpdateWithoutCursorInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUncheckedUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUncheckedUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUncheckedUpdateManyWithoutClaimantNestedInput
  }

  export type FormSectionUpsertWithoutCursorInput = {
    update: XOR<FormSectionUpdateWithoutCursorInput, FormSectionUncheckedUpdateWithoutCursorInput>
    create: XOR<FormSectionCreateWithoutCursorInput, FormSectionUncheckedCreateWithoutCursorInput>
  }

  export type FormSectionUpdateWithoutCursorInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    showTimer?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUpdateManyWithoutFormSectionNestedInput
    form?: FormUpdateOneRequiredWithoutFormSectionNestedInput
  }

  export type FormSectionUncheckedUpdateWithoutCursorInput = {
    id?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    showTimer?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutFormSectionNestedInput
  }

  export type OptionRuleCreateWithoutOptionInput = {
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
    questionAnswerRef?: QuestionCreateNestedOneWithoutOptionRuleInput
    function?: FunctionCreateNestedOneWithoutOptionRuleInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutOptionRuleInput
  }

  export type OptionRuleUncheckedCreateWithoutOptionInput = {
    id?: number
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    questionAnswerRefId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type OptionRuleCreateOrConnectWithoutOptionInput = {
    where: OptionRuleWhereUniqueInput
    create: XOR<OptionRuleCreateWithoutOptionInput, OptionRuleUncheckedCreateWithoutOptionInput>
  }

  export type OptionRuleCreateManyOptionInputEnvelope = {
    data: Enumerable<OptionRuleCreateManyOptionInput>
    skipDuplicates?: boolean
  }

  export type AnswerCreateWithoutOptionInput = {
    value?: string | null
    created?: Date | string
    updated?: Date | string
    question: QuestionCreateNestedOneWithoutAnswersInput
    claimant: ClaimantCreateNestedOneWithoutAnswersInput
    callSession: CallSessionCreateNestedOneWithoutAnswerInput
  }

  export type AnswerUncheckedCreateWithoutOptionInput = {
    id?: number
    questionId: number
    claimantId: number
    sessionId: number
    value?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type AnswerCreateOrConnectWithoutOptionInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutOptionInput, AnswerUncheckedCreateWithoutOptionInput>
  }

  export type AnswerCreateManyOptionInputEnvelope = {
    data: Enumerable<AnswerCreateManyOptionInput>
    skipDuplicates?: boolean
  }

  export type QuestionCreateWithoutOptionsInput = {
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerCreateNestedManyWithoutQuestionInput
    subform?: SubformCreateNestedOneWithoutQuestionInput
    formSection: FormSectionCreateNestedOneWithoutQuestionsInput
    optionRule?: OptionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionUncheckedCreateWithoutOptionsInput = {
    id?: number
    formSectionId: number
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
    subform?: SubformUncheckedCreateNestedOneWithoutQuestionInput
    optionRule?: OptionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionCreateOrConnectWithoutOptionsInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
  }

  export type OptionRuleUpsertWithWhereUniqueWithoutOptionInput = {
    where: OptionRuleWhereUniqueInput
    update: XOR<OptionRuleUpdateWithoutOptionInput, OptionRuleUncheckedUpdateWithoutOptionInput>
    create: XOR<OptionRuleCreateWithoutOptionInput, OptionRuleUncheckedCreateWithoutOptionInput>
  }

  export type OptionRuleUpdateWithWhereUniqueWithoutOptionInput = {
    where: OptionRuleWhereUniqueInput
    data: XOR<OptionRuleUpdateWithoutOptionInput, OptionRuleUncheckedUpdateWithoutOptionInput>
  }

  export type OptionRuleUpdateManyWithWhereWithoutOptionInput = {
    where: OptionRuleScalarWhereInput
    data: XOR<OptionRuleUpdateManyMutationInput, OptionRuleUncheckedUpdateManyWithoutRulesInput>
  }

  export type AnswerUpsertWithWhereUniqueWithoutOptionInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutOptionInput, AnswerUncheckedUpdateWithoutOptionInput>
    create: XOR<AnswerCreateWithoutOptionInput, AnswerUncheckedCreateWithoutOptionInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutOptionInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutOptionInput, AnswerUncheckedUpdateWithoutOptionInput>
  }

  export type AnswerUpdateManyWithWhereWithoutOptionInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutAnswerInput>
  }

  export type QuestionUpsertWithoutOptionsInput = {
    update: XOR<QuestionUpdateWithoutOptionsInput, QuestionUncheckedUpdateWithoutOptionsInput>
    create: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
  }

  export type QuestionUpdateWithoutOptionsInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
    subform?: SubformUpdateOneWithoutQuestionNestedInput
    formSection?: FormSectionUpdateOneRequiredWithoutQuestionsNestedInput
    optionRule?: OptionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type QuestionUncheckedUpdateWithoutOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    formSectionId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
    subform?: SubformUncheckedUpdateOneWithoutQuestionNestedInput
    optionRule?: OptionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type OptionCreateWithoutRulesInput = {
    label?: string
    value: string
    created?: Date | string
    updatedAt?: Date | string
    answer?: AnswerCreateNestedManyWithoutOptionInput
    question: QuestionCreateNestedOneWithoutOptionsInput
  }

  export type OptionUncheckedCreateWithoutRulesInput = {
    id?: number
    questionId: number
    label?: string
    value: string
    created?: Date | string
    updatedAt?: Date | string
    answer?: AnswerUncheckedCreateNestedManyWithoutOptionInput
  }

  export type OptionCreateOrConnectWithoutRulesInput = {
    where: OptionWhereUniqueInput
    create: XOR<OptionCreateWithoutRulesInput, OptionUncheckedCreateWithoutRulesInput>
  }

  export type QuestionCreateWithoutOptionRuleInput = {
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerCreateNestedManyWithoutQuestionInput
    options?: OptionCreateNestedManyWithoutQuestionInput
    subform?: SubformCreateNestedOneWithoutQuestionInput
    formSection: FormSectionCreateNestedOneWithoutQuestionsInput
    rules?: QuestionRuleCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionUncheckedCreateWithoutOptionRuleInput = {
    id?: number
    formSectionId: number
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
    options?: OptionUncheckedCreateNestedManyWithoutQuestionInput
    subform?: SubformUncheckedCreateNestedOneWithoutQuestionInput
    rules?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionCreateOrConnectWithoutOptionRuleInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutOptionRuleInput, QuestionUncheckedCreateWithoutOptionRuleInput>
  }

  export type FunctionCreateWithoutOptionRuleInput = {
    name: string
    function: string
    created?: Date | string
    updated?: Date | string
    QuestionRule?: QuestionRuleCreateNestedManyWithoutFunctionInput
  }

  export type FunctionUncheckedCreateWithoutOptionRuleInput = {
    id?: number
    name: string
    function: string
    created?: Date | string
    updated?: Date | string
    QuestionRule?: QuestionRuleUncheckedCreateNestedManyWithoutFunctionInput
  }

  export type FunctionCreateOrConnectWithoutOptionRuleInput = {
    where: FunctionWhereUniqueInput
    create: XOR<FunctionCreateWithoutOptionRuleInput, FunctionUncheckedCreateWithoutOptionRuleInput>
  }

  export type SSAStatusCreateWithoutOptionRuleInput = {
    name: string
    created?: Date | string
    updated?: Date | string
    claimant?: ClaimantCreateNestedManyWithoutSsaStatusInput
    QuestionRule?: QuestionRuleCreateNestedManyWithoutSsaStatusInput
  }

  export type SSAStatusUncheckedCreateWithoutOptionRuleInput = {
    id?: number
    name: string
    created?: Date | string
    updated?: Date | string
    claimant?: ClaimantUncheckedCreateNestedManyWithoutSsaStatusInput
    QuestionRule?: QuestionRuleUncheckedCreateNestedManyWithoutSsaStatusInput
  }

  export type SSAStatusCreateOrConnectWithoutOptionRuleInput = {
    where: SSAStatusWhereUniqueInput
    create: XOR<SSAStatusCreateWithoutOptionRuleInput, SSAStatusUncheckedCreateWithoutOptionRuleInput>
  }

  export type OptionUpsertWithoutRulesInput = {
    update: XOR<OptionUpdateWithoutRulesInput, OptionUncheckedUpdateWithoutRulesInput>
    create: XOR<OptionCreateWithoutRulesInput, OptionUncheckedCreateWithoutRulesInput>
  }

  export type OptionUpdateWithoutRulesInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: AnswerUpdateManyWithoutOptionNestedInput
    question?: QuestionUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type OptionUncheckedUpdateWithoutRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: AnswerUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type QuestionUpsertWithoutOptionRuleInput = {
    update: XOR<QuestionUpdateWithoutOptionRuleInput, QuestionUncheckedUpdateWithoutOptionRuleInput>
    create: XOR<QuestionCreateWithoutOptionRuleInput, QuestionUncheckedCreateWithoutOptionRuleInput>
  }

  export type QuestionUpdateWithoutOptionRuleInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
    options?: OptionUpdateManyWithoutQuestionNestedInput
    subform?: SubformUpdateOneWithoutQuestionNestedInput
    formSection?: FormSectionUpdateOneRequiredWithoutQuestionsNestedInput
    rules?: QuestionRuleUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type QuestionUncheckedUpdateWithoutOptionRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    formSectionId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
    options?: OptionUncheckedUpdateManyWithoutQuestionNestedInput
    subform?: SubformUncheckedUpdateOneWithoutQuestionNestedInput
    rules?: QuestionRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type FunctionUpsertWithoutOptionRuleInput = {
    update: XOR<FunctionUpdateWithoutOptionRuleInput, FunctionUncheckedUpdateWithoutOptionRuleInput>
    create: XOR<FunctionCreateWithoutOptionRuleInput, FunctionUncheckedCreateWithoutOptionRuleInput>
  }

  export type FunctionUpdateWithoutOptionRuleInput = {
    name?: StringFieldUpdateOperationsInput | string
    function?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    QuestionRule?: QuestionRuleUpdateManyWithoutFunctionNestedInput
  }

  export type FunctionUncheckedUpdateWithoutOptionRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    function?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    QuestionRule?: QuestionRuleUncheckedUpdateManyWithoutFunctionNestedInput
  }

  export type SSAStatusUpsertWithoutOptionRuleInput = {
    update: XOR<SSAStatusUpdateWithoutOptionRuleInput, SSAStatusUncheckedUpdateWithoutOptionRuleInput>
    create: XOR<SSAStatusCreateWithoutOptionRuleInput, SSAStatusUncheckedCreateWithoutOptionRuleInput>
  }

  export type SSAStatusUpdateWithoutOptionRuleInput = {
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    claimant?: ClaimantUpdateManyWithoutSsaStatusNestedInput
    QuestionRule?: QuestionRuleUpdateManyWithoutSsaStatusNestedInput
  }

  export type SSAStatusUncheckedUpdateWithoutOptionRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    claimant?: ClaimantUncheckedUpdateManyWithoutSsaStatusNestedInput
    QuestionRule?: QuestionRuleUncheckedUpdateManyWithoutSsaStatusNestedInput
  }

  export type QuestionCreateWithoutRulesInput = {
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerCreateNestedManyWithoutQuestionInput
    options?: OptionCreateNestedManyWithoutQuestionInput
    subform?: SubformCreateNestedOneWithoutQuestionInput
    formSection: FormSectionCreateNestedOneWithoutQuestionsInput
    optionRule?: OptionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    questionAnswerRef?: QuestionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionUncheckedCreateWithoutRulesInput = {
    id?: number
    formSectionId: number
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
    options?: OptionUncheckedCreateNestedManyWithoutQuestionInput
    subform?: SubformUncheckedCreateNestedOneWithoutQuestionInput
    optionRule?: OptionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    questionAnswerRef?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionCreateOrConnectWithoutRulesInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutRulesInput, QuestionUncheckedCreateWithoutRulesInput>
  }

  export type QuestionCreateWithoutQuestionAnswerRefInput = {
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerCreateNestedManyWithoutQuestionInput
    options?: OptionCreateNestedManyWithoutQuestionInput
    subform?: SubformCreateNestedOneWithoutQuestionInput
    formSection: FormSectionCreateNestedOneWithoutQuestionsInput
    optionRule?: OptionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleCreateNestedManyWithoutQuestionInput
    questionFormatRule?: QuestionFormatRuleCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionUncheckedCreateWithoutQuestionAnswerRefInput = {
    id?: number
    formSectionId: number
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
    options?: OptionUncheckedCreateNestedManyWithoutQuestionInput
    subform?: SubformUncheckedCreateNestedOneWithoutQuestionInput
    optionRule?: OptionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionFormatRule?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionCreateOrConnectWithoutQuestionAnswerRefInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutQuestionAnswerRefInput, QuestionUncheckedCreateWithoutQuestionAnswerRefInput>
  }

  export type FunctionCreateWithoutQuestionRuleInput = {
    name: string
    function: string
    created?: Date | string
    updated?: Date | string
    OptionRule?: OptionRuleCreateNestedManyWithoutFunctionInput
  }

  export type FunctionUncheckedCreateWithoutQuestionRuleInput = {
    id?: number
    name: string
    function: string
    created?: Date | string
    updated?: Date | string
    OptionRule?: OptionRuleUncheckedCreateNestedManyWithoutFunctionInput
  }

  export type FunctionCreateOrConnectWithoutQuestionRuleInput = {
    where: FunctionWhereUniqueInput
    create: XOR<FunctionCreateWithoutQuestionRuleInput, FunctionUncheckedCreateWithoutQuestionRuleInput>
  }

  export type SSAStatusCreateWithoutQuestionRuleInput = {
    name: string
    created?: Date | string
    updated?: Date | string
    claimant?: ClaimantCreateNestedManyWithoutSsaStatusInput
    OptionRule?: OptionRuleCreateNestedManyWithoutSsaStatusInput
  }

  export type SSAStatusUncheckedCreateWithoutQuestionRuleInput = {
    id?: number
    name: string
    created?: Date | string
    updated?: Date | string
    claimant?: ClaimantUncheckedCreateNestedManyWithoutSsaStatusInput
    OptionRule?: OptionRuleUncheckedCreateNestedManyWithoutSsaStatusInput
  }

  export type SSAStatusCreateOrConnectWithoutQuestionRuleInput = {
    where: SSAStatusWhereUniqueInput
    create: XOR<SSAStatusCreateWithoutQuestionRuleInput, SSAStatusUncheckedCreateWithoutQuestionRuleInput>
  }

  export type QuestionUpsertWithoutRulesInput = {
    update: XOR<QuestionUpdateWithoutRulesInput, QuestionUncheckedUpdateWithoutRulesInput>
    create: XOR<QuestionCreateWithoutRulesInput, QuestionUncheckedCreateWithoutRulesInput>
  }

  export type QuestionUpdateWithoutRulesInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
    options?: OptionUpdateManyWithoutQuestionNestedInput
    subform?: SubformUpdateOneWithoutQuestionNestedInput
    formSection?: FormSectionUpdateOneRequiredWithoutQuestionsNestedInput
    optionRule?: OptionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    questionAnswerRef?: QuestionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type QuestionUncheckedUpdateWithoutRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    formSectionId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
    options?: OptionUncheckedUpdateManyWithoutQuestionNestedInput
    subform?: SubformUncheckedUpdateOneWithoutQuestionNestedInput
    optionRule?: OptionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    questionAnswerRef?: QuestionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type QuestionUpsertWithoutQuestionAnswerRefInput = {
    update: XOR<QuestionUpdateWithoutQuestionAnswerRefInput, QuestionUncheckedUpdateWithoutQuestionAnswerRefInput>
    create: XOR<QuestionCreateWithoutQuestionAnswerRefInput, QuestionUncheckedCreateWithoutQuestionAnswerRefInput>
  }

  export type QuestionUpdateWithoutQuestionAnswerRefInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
    options?: OptionUpdateManyWithoutQuestionNestedInput
    subform?: SubformUpdateOneWithoutQuestionNestedInput
    formSection?: FormSectionUpdateOneRequiredWithoutQuestionsNestedInput
    optionRule?: OptionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUpdateManyWithoutQuestionNestedInput
    questionFormatRule?: QuestionFormatRuleUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type QuestionUncheckedUpdateWithoutQuestionAnswerRefInput = {
    id?: IntFieldUpdateOperationsInput | number
    formSectionId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
    options?: OptionUncheckedUpdateManyWithoutQuestionNestedInput
    subform?: SubformUncheckedUpdateOneWithoutQuestionNestedInput
    optionRule?: OptionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionFormatRule?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type FunctionUpsertWithoutQuestionRuleInput = {
    update: XOR<FunctionUpdateWithoutQuestionRuleInput, FunctionUncheckedUpdateWithoutQuestionRuleInput>
    create: XOR<FunctionCreateWithoutQuestionRuleInput, FunctionUncheckedCreateWithoutQuestionRuleInput>
  }

  export type FunctionUpdateWithoutQuestionRuleInput = {
    name?: StringFieldUpdateOperationsInput | string
    function?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    OptionRule?: OptionRuleUpdateManyWithoutFunctionNestedInput
  }

  export type FunctionUncheckedUpdateWithoutQuestionRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    function?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    OptionRule?: OptionRuleUncheckedUpdateManyWithoutFunctionNestedInput
  }

  export type SSAStatusUpsertWithoutQuestionRuleInput = {
    update: XOR<SSAStatusUpdateWithoutQuestionRuleInput, SSAStatusUncheckedUpdateWithoutQuestionRuleInput>
    create: XOR<SSAStatusCreateWithoutQuestionRuleInput, SSAStatusUncheckedCreateWithoutQuestionRuleInput>
  }

  export type SSAStatusUpdateWithoutQuestionRuleInput = {
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    claimant?: ClaimantUpdateManyWithoutSsaStatusNestedInput
    OptionRule?: OptionRuleUpdateManyWithoutSsaStatusNestedInput
  }

  export type SSAStatusUncheckedUpdateWithoutQuestionRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    claimant?: ClaimantUncheckedUpdateManyWithoutSsaStatusNestedInput
    OptionRule?: OptionRuleUncheckedUpdateManyWithoutSsaStatusNestedInput
  }

  export type QuestionCreateWithoutQuestionFormatRuleInput = {
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerCreateNestedManyWithoutQuestionInput
    options?: OptionCreateNestedManyWithoutQuestionInput
    subform?: SubformCreateNestedOneWithoutQuestionInput
    formSection: FormSectionCreateNestedOneWithoutQuestionsInput
    optionRule?: OptionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatAnswerRef?: QuestionFormatRuleCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionUncheckedCreateWithoutQuestionFormatRuleInput = {
    id?: number
    formSectionId: number
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
    options?: OptionUncheckedCreateNestedManyWithoutQuestionInput
    subform?: SubformUncheckedCreateNestedOneWithoutQuestionInput
    optionRule?: OptionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
  }

  export type QuestionCreateOrConnectWithoutQuestionFormatRuleInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutQuestionFormatRuleInput, QuestionUncheckedCreateWithoutQuestionFormatRuleInput>
  }

  export type QuestionCreateWithoutQuestionFormatAnswerRefInput = {
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerCreateNestedManyWithoutQuestionInput
    options?: OptionCreateNestedManyWithoutQuestionInput
    subform?: SubformCreateNestedOneWithoutQuestionInput
    formSection: FormSectionCreateNestedOneWithoutQuestionsInput
    optionRule?: OptionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutQuestionFormatAnswerRefInput = {
    id?: number
    formSectionId: number
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
    options?: OptionUncheckedCreateNestedManyWithoutQuestionInput
    subform?: SubformUncheckedCreateNestedOneWithoutQuestionInput
    optionRule?: OptionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    rules?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionInput
    questionAnswerRef?: QuestionRuleUncheckedCreateNestedManyWithoutQuestionAnswerRefInput
    questionFormatRule?: QuestionFormatRuleUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutQuestionFormatAnswerRefInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutQuestionFormatAnswerRefInput, QuestionUncheckedCreateWithoutQuestionFormatAnswerRefInput>
  }

  export type QuestionUpsertWithoutQuestionFormatRuleInput = {
    update: XOR<QuestionUpdateWithoutQuestionFormatRuleInput, QuestionUncheckedUpdateWithoutQuestionFormatRuleInput>
    create: XOR<QuestionCreateWithoutQuestionFormatRuleInput, QuestionUncheckedCreateWithoutQuestionFormatRuleInput>
  }

  export type QuestionUpdateWithoutQuestionFormatRuleInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
    options?: OptionUpdateManyWithoutQuestionNestedInput
    subform?: SubformUpdateOneWithoutQuestionNestedInput
    formSection?: FormSectionUpdateOneRequiredWithoutQuestionsNestedInput
    optionRule?: OptionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type QuestionUncheckedUpdateWithoutQuestionFormatRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    formSectionId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
    options?: OptionUncheckedUpdateManyWithoutQuestionNestedInput
    subform?: SubformUncheckedUpdateOneWithoutQuestionNestedInput
    optionRule?: OptionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type QuestionUpsertWithoutQuestionFormatAnswerRefInput = {
    update: XOR<QuestionUpdateWithoutQuestionFormatAnswerRefInput, QuestionUncheckedUpdateWithoutQuestionFormatAnswerRefInput>
    create: XOR<QuestionCreateWithoutQuestionFormatAnswerRefInput, QuestionUncheckedCreateWithoutQuestionFormatAnswerRefInput>
  }

  export type QuestionUpdateWithoutQuestionFormatAnswerRefInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
    options?: OptionUpdateManyWithoutQuestionNestedInput
    subform?: SubformUpdateOneWithoutQuestionNestedInput
    formSection?: FormSectionUpdateOneRequiredWithoutQuestionsNestedInput
    optionRule?: OptionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutQuestionFormatAnswerRefInput = {
    id?: IntFieldUpdateOperationsInput | number
    formSectionId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
    options?: OptionUncheckedUpdateManyWithoutQuestionNestedInput
    subform?: SubformUncheckedUpdateOneWithoutQuestionNestedInput
    optionRule?: OptionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionRuleCreateWithoutFunctionInput = {
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
    question?: QuestionCreateNestedOneWithoutRulesInput
    questionAnswerRef?: QuestionCreateNestedOneWithoutQuestionAnswerRefInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutQuestionRuleInput
  }

  export type QuestionRuleUncheckedCreateWithoutFunctionInput = {
    id?: number
    questionId?: number | null
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    questionAnswerRefId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionRuleCreateOrConnectWithoutFunctionInput = {
    where: QuestionRuleWhereUniqueInput
    create: XOR<QuestionRuleCreateWithoutFunctionInput, QuestionRuleUncheckedCreateWithoutFunctionInput>
  }

  export type QuestionRuleCreateManyFunctionInputEnvelope = {
    data: Enumerable<QuestionRuleCreateManyFunctionInput>
    skipDuplicates?: boolean
  }

  export type OptionRuleCreateWithoutFunctionInput = {
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
    option?: OptionCreateNestedOneWithoutRulesInput
    questionAnswerRef?: QuestionCreateNestedOneWithoutOptionRuleInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutOptionRuleInput
  }

  export type OptionRuleUncheckedCreateWithoutFunctionInput = {
    id?: number
    optionId?: number | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    questionAnswerRefId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type OptionRuleCreateOrConnectWithoutFunctionInput = {
    where: OptionRuleWhereUniqueInput
    create: XOR<OptionRuleCreateWithoutFunctionInput, OptionRuleUncheckedCreateWithoutFunctionInput>
  }

  export type OptionRuleCreateManyFunctionInputEnvelope = {
    data: Enumerable<OptionRuleCreateManyFunctionInput>
    skipDuplicates?: boolean
  }

  export type QuestionRuleUpsertWithWhereUniqueWithoutFunctionInput = {
    where: QuestionRuleWhereUniqueInput
    update: XOR<QuestionRuleUpdateWithoutFunctionInput, QuestionRuleUncheckedUpdateWithoutFunctionInput>
    create: XOR<QuestionRuleCreateWithoutFunctionInput, QuestionRuleUncheckedCreateWithoutFunctionInput>
  }

  export type QuestionRuleUpdateWithWhereUniqueWithoutFunctionInput = {
    where: QuestionRuleWhereUniqueInput
    data: XOR<QuestionRuleUpdateWithoutFunctionInput, QuestionRuleUncheckedUpdateWithoutFunctionInput>
  }

  export type QuestionRuleUpdateManyWithWhereWithoutFunctionInput = {
    where: QuestionRuleScalarWhereInput
    data: XOR<QuestionRuleUpdateManyMutationInput, QuestionRuleUncheckedUpdateManyWithoutQuestionRuleInput>
  }

  export type OptionRuleUpsertWithWhereUniqueWithoutFunctionInput = {
    where: OptionRuleWhereUniqueInput
    update: XOR<OptionRuleUpdateWithoutFunctionInput, OptionRuleUncheckedUpdateWithoutFunctionInput>
    create: XOR<OptionRuleCreateWithoutFunctionInput, OptionRuleUncheckedCreateWithoutFunctionInput>
  }

  export type OptionRuleUpdateWithWhereUniqueWithoutFunctionInput = {
    where: OptionRuleWhereUniqueInput
    data: XOR<OptionRuleUpdateWithoutFunctionInput, OptionRuleUncheckedUpdateWithoutFunctionInput>
  }

  export type OptionRuleUpdateManyWithWhereWithoutFunctionInput = {
    where: OptionRuleScalarWhereInput
    data: XOR<OptionRuleUpdateManyMutationInput, OptionRuleUncheckedUpdateManyWithoutOptionRuleInput>
  }

  export type ClaimantCreateWithoutTouchPointInput = {
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorCreateNestedManyWithoutClaimantInput
    answers?: AnswerCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutClaimantInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutClaimantInput
    referrer?: ReferrerCreateNestedOneWithoutClaimantInput
    VoiceMail?: VoiceMailCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantUncheckedCreateWithoutTouchPointInput = {
    id?: number
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    referrerId?: number | null
    ssaStatusId?: number | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorUncheckedCreateNestedManyWithoutClaimantInput
    answers?: AnswerUncheckedCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutClaimantInput
    VoiceMail?: VoiceMailUncheckedCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantCreateOrConnectWithoutTouchPointInput = {
    where: ClaimantWhereUniqueInput
    create: XOR<ClaimantCreateWithoutTouchPointInput, ClaimantUncheckedCreateWithoutTouchPointInput>
  }

  export type ClaimantUpsertWithoutTouchPointInput = {
    update: XOR<ClaimantUpdateWithoutTouchPointInput, ClaimantUncheckedUpdateWithoutTouchPointInput>
    create: XOR<ClaimantCreateWithoutTouchPointInput, ClaimantUncheckedCreateWithoutTouchPointInput>
  }

  export type ClaimantUpdateWithoutTouchPointInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUpdateManyWithoutClaimantNestedInput
    answers?: AnswerUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutClaimantNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutClaimantNestedInput
    referrer?: ReferrerUpdateOneWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUpdateManyWithoutClaimantNestedInput
  }

  export type ClaimantUncheckedUpdateWithoutTouchPointInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUncheckedUpdateManyWithoutClaimantNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUncheckedUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUncheckedUpdateManyWithoutClaimantNestedInput
  }

  export type ClaimantCreateWithoutReferrerInput = {
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorCreateNestedManyWithoutClaimantInput
    answers?: AnswerCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutClaimantInput
    ssaStatus?: SSAStatusCreateNestedOneWithoutClaimantInput
    VoiceMail?: VoiceMailCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantUncheckedCreateWithoutReferrerInput = {
    id?: number
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    ssaStatusId?: number | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorUncheckedCreateNestedManyWithoutClaimantInput
    answers?: AnswerUncheckedCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointUncheckedCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutClaimantInput
    VoiceMail?: VoiceMailUncheckedCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantCreateOrConnectWithoutReferrerInput = {
    where: ClaimantWhereUniqueInput
    create: XOR<ClaimantCreateWithoutReferrerInput, ClaimantUncheckedCreateWithoutReferrerInput>
  }

  export type ClaimantCreateManyReferrerInputEnvelope = {
    data: Enumerable<ClaimantCreateManyReferrerInput>
    skipDuplicates?: boolean
  }

  export type ClaimantUpsertWithWhereUniqueWithoutReferrerInput = {
    where: ClaimantWhereUniqueInput
    update: XOR<ClaimantUpdateWithoutReferrerInput, ClaimantUncheckedUpdateWithoutReferrerInput>
    create: XOR<ClaimantCreateWithoutReferrerInput, ClaimantUncheckedCreateWithoutReferrerInput>
  }

  export type ClaimantUpdateWithWhereUniqueWithoutReferrerInput = {
    where: ClaimantWhereUniqueInput
    data: XOR<ClaimantUpdateWithoutReferrerInput, ClaimantUncheckedUpdateWithoutReferrerInput>
  }

  export type ClaimantUpdateManyWithWhereWithoutReferrerInput = {
    where: ClaimantScalarWhereInput
    data: XOR<ClaimantUpdateManyMutationInput, ClaimantUncheckedUpdateManyWithoutClaimantInput>
  }

  export type ClaimantScalarWhereInput = {
    AND?: Enumerable<ClaimantScalarWhereInput>
    OR?: Enumerable<ClaimantScalarWhereInput>
    NOT?: Enumerable<ClaimantScalarWhereInput>
    id?: IntFilter | number
    firstName?: StringNullableFilter | string | null
    middleName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    referrerId?: IntNullableFilter | number | null
    ssaStatusId?: IntNullableFilter | number | null
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
  }

  export type ClaimantCreateWithoutSsaStatusInput = {
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorCreateNestedManyWithoutClaimantInput
    answers?: AnswerCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerCreateNestedManyWithoutClaimantInput
    referrer?: ReferrerCreateNestedOneWithoutClaimantInput
    VoiceMail?: VoiceMailCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantUncheckedCreateWithoutSsaStatusInput = {
    id?: number
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    referrerId?: number | null
    created?: Date | string
    updated?: Date | string
    cursor?: CursorUncheckedCreateNestedManyWithoutClaimantInput
    answers?: AnswerUncheckedCreateNestedManyWithoutClaimantInput
    touchPoint?: TouchPointUncheckedCreateNestedManyWithoutClaimantInput
    callSessions?: CallSessionUncheckedCreateNestedManyWithoutClaimantInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedCreateNestedManyWithoutClaimantInput
    VoiceMail?: VoiceMailUncheckedCreateNestedManyWithoutClaimantInput
  }

  export type ClaimantCreateOrConnectWithoutSsaStatusInput = {
    where: ClaimantWhereUniqueInput
    create: XOR<ClaimantCreateWithoutSsaStatusInput, ClaimantUncheckedCreateWithoutSsaStatusInput>
  }

  export type ClaimantCreateManySsaStatusInputEnvelope = {
    data: Enumerable<ClaimantCreateManySsaStatusInput>
    skipDuplicates?: boolean
  }

  export type OptionRuleCreateWithoutSsaStatusInput = {
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
    option?: OptionCreateNestedOneWithoutRulesInput
    questionAnswerRef?: QuestionCreateNestedOneWithoutOptionRuleInput
    function?: FunctionCreateNestedOneWithoutOptionRuleInput
  }

  export type OptionRuleUncheckedCreateWithoutSsaStatusInput = {
    id?: number
    optionId?: number | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    questionAnswerRefId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type OptionRuleCreateOrConnectWithoutSsaStatusInput = {
    where: OptionRuleWhereUniqueInput
    create: XOR<OptionRuleCreateWithoutSsaStatusInput, OptionRuleUncheckedCreateWithoutSsaStatusInput>
  }

  export type OptionRuleCreateManySsaStatusInputEnvelope = {
    data: Enumerable<OptionRuleCreateManySsaStatusInput>
    skipDuplicates?: boolean
  }

  export type QuestionRuleCreateWithoutSsaStatusInput = {
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
    question?: QuestionCreateNestedOneWithoutRulesInput
    questionAnswerRef?: QuestionCreateNestedOneWithoutQuestionAnswerRefInput
    function?: FunctionCreateNestedOneWithoutQuestionRuleInput
  }

  export type QuestionRuleUncheckedCreateWithoutSsaStatusInput = {
    id?: number
    questionId?: number | null
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    questionAnswerRefId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionRuleCreateOrConnectWithoutSsaStatusInput = {
    where: QuestionRuleWhereUniqueInput
    create: XOR<QuestionRuleCreateWithoutSsaStatusInput, QuestionRuleUncheckedCreateWithoutSsaStatusInput>
  }

  export type QuestionRuleCreateManySsaStatusInputEnvelope = {
    data: Enumerable<QuestionRuleCreateManySsaStatusInput>
    skipDuplicates?: boolean
  }

  export type ClaimantUpsertWithWhereUniqueWithoutSsaStatusInput = {
    where: ClaimantWhereUniqueInput
    update: XOR<ClaimantUpdateWithoutSsaStatusInput, ClaimantUncheckedUpdateWithoutSsaStatusInput>
    create: XOR<ClaimantCreateWithoutSsaStatusInput, ClaimantUncheckedCreateWithoutSsaStatusInput>
  }

  export type ClaimantUpdateWithWhereUniqueWithoutSsaStatusInput = {
    where: ClaimantWhereUniqueInput
    data: XOR<ClaimantUpdateWithoutSsaStatusInput, ClaimantUncheckedUpdateWithoutSsaStatusInput>
  }

  export type ClaimantUpdateManyWithWhereWithoutSsaStatusInput = {
    where: ClaimantScalarWhereInput
    data: XOR<ClaimantUpdateManyMutationInput, ClaimantUncheckedUpdateManyWithoutClaimantInput>
  }

  export type OptionRuleUpsertWithWhereUniqueWithoutSsaStatusInput = {
    where: OptionRuleWhereUniqueInput
    update: XOR<OptionRuleUpdateWithoutSsaStatusInput, OptionRuleUncheckedUpdateWithoutSsaStatusInput>
    create: XOR<OptionRuleCreateWithoutSsaStatusInput, OptionRuleUncheckedCreateWithoutSsaStatusInput>
  }

  export type OptionRuleUpdateWithWhereUniqueWithoutSsaStatusInput = {
    where: OptionRuleWhereUniqueInput
    data: XOR<OptionRuleUpdateWithoutSsaStatusInput, OptionRuleUncheckedUpdateWithoutSsaStatusInput>
  }

  export type OptionRuleUpdateManyWithWhereWithoutSsaStatusInput = {
    where: OptionRuleScalarWhereInput
    data: XOR<OptionRuleUpdateManyMutationInput, OptionRuleUncheckedUpdateManyWithoutOptionRuleInput>
  }

  export type QuestionRuleUpsertWithWhereUniqueWithoutSsaStatusInput = {
    where: QuestionRuleWhereUniqueInput
    update: XOR<QuestionRuleUpdateWithoutSsaStatusInput, QuestionRuleUncheckedUpdateWithoutSsaStatusInput>
    create: XOR<QuestionRuleCreateWithoutSsaStatusInput, QuestionRuleUncheckedCreateWithoutSsaStatusInput>
  }

  export type QuestionRuleUpdateWithWhereUniqueWithoutSsaStatusInput = {
    where: QuestionRuleWhereUniqueInput
    data: XOR<QuestionRuleUpdateWithoutSsaStatusInput, QuestionRuleUncheckedUpdateWithoutSsaStatusInput>
  }

  export type QuestionRuleUpdateManyWithWhereWithoutSsaStatusInput = {
    where: QuestionRuleScalarWhereInput
    data: XOR<QuestionRuleUpdateManyMutationInput, QuestionRuleUncheckedUpdateManyWithoutQuestionRuleInput>
  }

  export type CallSessionCreateManyUserInput = {
    id?: number
    claimantId: number
    sessionType: SessionTypes
    sessionStatus?: SessionStatuses | null
    created?: Date | string
    ended?: Date | string | null
    updated?: Date | string
    recordingUrl?: string | null
    outgoingPhone: string
  }

  export type CallSessionUpdateWithoutUserInput = {
    sessionType?: EnumSessionTypesFieldUpdateOperationsInput | SessionTypes
    sessionStatus?: NullableEnumSessionStatusesFieldUpdateOperationsInput | SessionStatuses | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    claimant?: ClaimantUpdateOneRequiredWithoutCallSessionsNestedInput
    answer?: AnswerUpdateManyWithoutCallSessionNestedInput
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutSessionNestedInput
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    outgoingPhone?: StringFieldUpdateOperationsInput | string
  }

  export type CallSessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    sessionType?: EnumSessionTypesFieldUpdateOperationsInput | SessionTypes
    sessionStatus?: NullableEnumSessionStatusesFieldUpdateOperationsInput | SessionStatuses | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: AnswerUncheckedUpdateManyWithoutCallSessionNestedInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutSessionNestedInput
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    outgoingPhone?: StringFieldUpdateOperationsInput | string
  }

  export type CallSessionUncheckedUpdateManyWithoutCallSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    sessionType?: EnumSessionTypesFieldUpdateOperationsInput | SessionTypes
    sessionStatus?: NullableEnumSessionStatusesFieldUpdateOperationsInput | SessionStatuses | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    outgoingPhone?: StringFieldUpdateOperationsInput | string
  }

  export type CursorCreateManyClaimantInput = {
    id?: number
    formSectionId: number
    questionId: number
    created?: Date | string
    updatedAt?: Date | string
  }

  export type AnswerCreateManyClaimantInput = {
    id?: number
    questionId: number
    sessionId: number
    optionId?: number | null
    value?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type TouchPointCreateManyClaimantInput = {
    id?: number
    type: TouchPointType
    created?: Date | string
    updated?: Date | string
  }

  export type CallSessionCreateManyClaimantInput = {
    id?: number
    userId: number
    sessionType: SessionTypes
    sessionStatus?: SessionStatuses | null
    created?: Date | string
    ended?: Date | string | null
    updated?: Date | string
    recordingUrl?: string | null
    outgoingPhone: string
  }

  export type SubformFieldAnswerCreateManyClaimantInput = {
    id?: number
    subformFieldId: number
    sessionId: number
    value?: string | null
    optionId?: number | null
    created?: Date | string
    updated?: Date | string
  }

  export type VoiceMailCreateManyClaimantInput = {
    id?: number
    created?: Date | string
    updated?: Date | string
    recordingUrl?: string | null
    transcription?: string | null
  }

  export type CursorUpdateWithoutClaimantInput = {
    questionId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formSection?: FormSectionUpdateOneRequiredWithoutCursorNestedInput
  }

  export type CursorUncheckedUpdateWithoutClaimantInput = {
    id?: IntFieldUpdateOperationsInput | number
    formSectionId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursorUncheckedUpdateManyWithoutCursorInput = {
    id?: IntFieldUpdateOperationsInput | number
    formSectionId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerUpdateWithoutClaimantInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutAnswersNestedInput
    option?: OptionUpdateOneWithoutAnswerNestedInput
    callSession?: CallSessionUpdateOneRequiredWithoutAnswerNestedInput
  }

  export type AnswerUncheckedUpdateWithoutClaimantInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerUncheckedUpdateManyWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TouchPointUpdateWithoutClaimantInput = {
    type?: EnumTouchPointTypeFieldUpdateOperationsInput | TouchPointType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TouchPointUncheckedUpdateWithoutClaimantInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTouchPointTypeFieldUpdateOperationsInput | TouchPointType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TouchPointUncheckedUpdateManyWithoutTouchPointInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTouchPointTypeFieldUpdateOperationsInput | TouchPointType
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSessionUpdateWithoutClaimantInput = {
    sessionType?: EnumSessionTypesFieldUpdateOperationsInput | SessionTypes
    sessionStatus?: NullableEnumSessionStatusesFieldUpdateOperationsInput | SessionStatuses | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCallSessionsNestedInput
    answer?: AnswerUpdateManyWithoutCallSessionNestedInput
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutSessionNestedInput
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    outgoingPhone?: StringFieldUpdateOperationsInput | string
  }

  export type CallSessionUncheckedUpdateWithoutClaimantInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    sessionType?: EnumSessionTypesFieldUpdateOperationsInput | SessionTypes
    sessionStatus?: NullableEnumSessionStatusesFieldUpdateOperationsInput | SessionStatuses | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    ended?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: AnswerUncheckedUpdateManyWithoutCallSessionNestedInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutSessionNestedInput
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    outgoingPhone?: StringFieldUpdateOperationsInput | string
  }

  export type SubformFieldAnswerUpdateWithoutClaimantInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformField?: SubformFieldUpdateOneRequiredWithoutSubformFieldAnswerNestedInput
    subformFieldOpion?: SubformFieldOptionUpdateOneWithoutSubformFieldAnswerNestedInput
    session?: CallSessionUpdateOneRequiredWithoutSubformFieldAnswerNestedInput
  }

  export type SubformFieldAnswerUncheckedUpdateWithoutClaimantInput = {
    id?: IntFieldUpdateOperationsInput | number
    subformFieldId?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformFieldAnswerUncheckedUpdateManyWithoutSubformFieldAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    subformFieldId?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceMailUpdateWithoutClaimantInput = {
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoiceMailUncheckedUpdateWithoutClaimantInput = {
    id?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoiceMailUncheckedUpdateManyWithoutVoiceMailInput = {
    id?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnswerCreateManyCallSessionInput = {
    id?: number
    questionId: number
    claimantId: number
    optionId?: number | null
    value?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type SubformFieldAnswerCreateManySessionInput = {
    id?: number
    subformFieldId: number
    claimantId: number
    value?: string | null
    optionId?: number | null
    created?: Date | string
    updated?: Date | string
  }

  export type AnswerUpdateWithoutCallSessionInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutAnswersNestedInput
    claimant?: ClaimantUpdateOneRequiredWithoutAnswersNestedInput
    option?: OptionUpdateOneWithoutAnswerNestedInput
  }

  export type AnswerUncheckedUpdateWithoutCallSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerUncheckedUpdateManyWithoutAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformFieldAnswerUpdateWithoutSessionInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformField?: SubformFieldUpdateOneRequiredWithoutSubformFieldAnswerNestedInput
    subformFieldOpion?: SubformFieldOptionUpdateOneWithoutSubformFieldAnswerNestedInput
    claimant?: ClaimantUpdateOneRequiredWithoutSubformFieldAnswerNestedInput
  }

  export type SubformFieldAnswerUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    subformFieldId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormSectionCreateManyFormInput = {
    id?: number
    name: string
    order?: number
    showTimer?: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type FormSectionUpdateWithoutFormInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    showTimer?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUpdateManyWithoutFormSectionNestedInput
    cursor?: CursorUpdateManyWithoutFormSectionNestedInput
  }

  export type FormSectionUncheckedUpdateWithoutFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    showTimer?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutFormSectionNestedInput
    cursor?: CursorUncheckedUpdateManyWithoutFormSectionNestedInput
  }

  export type FormSectionUncheckedUpdateManyWithoutFormSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    showTimer?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateManyFormSectionInput = {
    id?: number
    question: string
    questionType: QuestionType
    inputType?: InputType | null
    order?: number
    scriptText?: string
    optout?: boolean
    optoutText?: string
    created?: Date | string
    updated?: Date | string
  }

  export type CursorCreateManyFormSectionInput = {
    id?: number
    questionId: number
    claimantId: number
    created?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionUpdateWithoutFormSectionInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
    options?: OptionUpdateManyWithoutQuestionNestedInput
    subform?: SubformUpdateOneWithoutQuestionNestedInput
    optionRule?: OptionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type QuestionUncheckedUpdateWithoutFormSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
    options?: OptionUncheckedUpdateManyWithoutQuestionNestedInput
    subform?: SubformUncheckedUpdateOneWithoutQuestionNestedInput
    optionRule?: OptionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    rules?: QuestionRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionAnswerRef?: QuestionRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
    questionFormatRule?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionNestedInput
    questionFormatAnswerRef?: QuestionFormatRuleUncheckedUpdateManyWithoutQuestionAnswerRefNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | QuestionType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    order?: IntFieldUpdateOperationsInput | number
    scriptText?: StringFieldUpdateOperationsInput | string
    optout?: BoolFieldUpdateOperationsInput | boolean
    optoutText?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursorUpdateWithoutFormSectionInput = {
    questionId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimant?: ClaimantUpdateOneRequiredWithoutCursorNestedInput
  }

  export type CursorUncheckedUpdateWithoutFormSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerCreateManyQuestionInput = {
    id?: number
    claimantId: number
    sessionId: number
    optionId?: number | null
    value?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type OptionCreateManyQuestionInput = {
    id?: number
    label?: string
    value: string
    created?: Date | string
    updatedAt?: Date | string
  }

  export type OptionRuleCreateManyQuestionAnswerRefInput = {
    id?: number
    optionId?: number | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionRuleCreateManyQuestionInput = {
    id?: number
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    questionAnswerRefId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionRuleCreateManyQuestionAnswerRefInput = {
    id?: number
    questionId?: number | null
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionFormatRuleCreateManyQuestionInput = {
    id?: number
    type: QuestionFormatTypes
    questionAnswerRefId?: number | null
    claimantField?: ClaimantFieldRefTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionFormatRuleCreateManyQuestionAnswerRefInput = {
    id?: number
    questionId?: number | null
    type: QuestionFormatTypes
    claimantField?: ClaimantFieldRefTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type AnswerUpdateWithoutQuestionInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    claimant?: ClaimantUpdateOneRequiredWithoutAnswersNestedInput
    option?: OptionUpdateOneWithoutAnswerNestedInput
    callSession?: CallSessionUpdateOneRequiredWithoutAnswerNestedInput
  }

  export type AnswerUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionUpdateWithoutQuestionInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: OptionRuleUpdateManyWithoutOptionNestedInput
    answer?: AnswerUpdateManyWithoutOptionNestedInput
  }

  export type OptionUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: OptionRuleUncheckedUpdateManyWithoutOptionNestedInput
    answer?: AnswerUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type OptionUncheckedUpdateManyWithoutOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionRuleUpdateWithoutQuestionAnswerRefInput = {
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    option?: OptionUpdateOneWithoutRulesNestedInput
    function?: FunctionUpdateOneWithoutOptionRuleNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutOptionRuleNestedInput
  }

  export type OptionRuleUncheckedUpdateWithoutQuestionAnswerRefInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionRuleUncheckedUpdateManyWithoutOptionRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionRuleUpdateWithoutQuestionInput = {
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    questionAnswerRef?: QuestionUpdateOneWithoutQuestionAnswerRefNestedInput
    function?: FunctionUpdateOneWithoutQuestionRuleNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutQuestionRuleNestedInput
  }

  export type QuestionRuleUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionRuleUncheckedUpdateManyWithoutRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionRuleUpdateWithoutQuestionAnswerRefInput = {
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneWithoutRulesNestedInput
    function?: FunctionUpdateOneWithoutQuestionRuleNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutQuestionRuleNestedInput
  }

  export type QuestionRuleUncheckedUpdateWithoutQuestionAnswerRefInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionRuleUncheckedUpdateManyWithoutQuestionAnswerRefInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionFormatRuleUpdateWithoutQuestionInput = {
    type?: EnumQuestionFormatTypesFieldUpdateOperationsInput | QuestionFormatTypes
    claimantField?: NullableEnumClaimantFieldRefTypesFieldUpdateOperationsInput | ClaimantFieldRefTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    questionAnswerRef?: QuestionUpdateOneWithoutQuestionFormatAnswerRefNestedInput
  }

  export type QuestionFormatRuleUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumQuestionFormatTypesFieldUpdateOperationsInput | QuestionFormatTypes
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    claimantField?: NullableEnumClaimantFieldRefTypesFieldUpdateOperationsInput | ClaimantFieldRefTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionFormatRuleUncheckedUpdateManyWithoutQuestionFormatRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumQuestionFormatTypesFieldUpdateOperationsInput | QuestionFormatTypes
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    claimantField?: NullableEnumClaimantFieldRefTypesFieldUpdateOperationsInput | ClaimantFieldRefTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionFormatRuleUpdateWithoutQuestionAnswerRefInput = {
    type?: EnumQuestionFormatTypesFieldUpdateOperationsInput | QuestionFormatTypes
    claimantField?: NullableEnumClaimantFieldRefTypesFieldUpdateOperationsInput | ClaimantFieldRefTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneWithoutQuestionFormatRuleNestedInput
  }

  export type QuestionFormatRuleUncheckedUpdateWithoutQuestionAnswerRefInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumQuestionFormatTypesFieldUpdateOperationsInput | QuestionFormatTypes
    claimantField?: NullableEnumClaimantFieldRefTypesFieldUpdateOperationsInput | ClaimantFieldRefTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionFormatRuleUncheckedUpdateManyWithoutQuestionFormatAnswerRefInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumQuestionFormatTypesFieldUpdateOperationsInput | QuestionFormatTypes
    claimantField?: NullableEnumClaimantFieldRefTypesFieldUpdateOperationsInput | ClaimantFieldRefTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformFieldCreateManySubFormInput = {
    id?: number
    fieldType: SubFormFieldType
    inputType?: InputType | null
    max?: number | null
    name: string
    label: string
    required?: boolean
    created?: Date | string
    updated?: Date | string
  }

  export type SubformFieldUpdateWithoutSubFormInput = {
    fieldType?: EnumSubFormFieldTypeFieldUpdateOperationsInput | SubFormFieldType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    max?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFieldOptions?: SubformFieldOptionUpdateManyWithoutSubformFieldNestedInput
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutSubformFieldNestedInput
  }

  export type SubformFieldUncheckedUpdateWithoutSubFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    fieldType?: EnumSubFormFieldTypeFieldUpdateOperationsInput | SubFormFieldType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    max?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFieldOptions?: SubformFieldOptionUncheckedUpdateManyWithoutSubformFieldNestedInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutSubformFieldNestedInput
  }

  export type SubformFieldUncheckedUpdateManyWithoutSubformFieldsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fieldType?: EnumSubFormFieldTypeFieldUpdateOperationsInput | SubFormFieldType
    inputType?: NullableEnumInputTypeFieldUpdateOperationsInput | InputType | null
    max?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformFieldOptionCreateManySubformFieldInput = {
    id?: number
    label: string
    value: string
    created?: Date | string
    updated?: Date | string
  }

  export type SubformFieldAnswerCreateManySubformFieldInput = {
    id?: number
    claimantId: number
    sessionId: number
    value?: string | null
    optionId?: number | null
    created?: Date | string
    updated?: Date | string
  }

  export type SubformFieldOptionUpdateWithoutSubformFieldInput = {
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutSubformFieldOpionNestedInput
  }

  export type SubformFieldOptionUncheckedUpdateWithoutSubformFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutSubformFieldOpionNestedInput
  }

  export type SubformFieldOptionUncheckedUpdateManyWithoutSubformFieldOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformFieldAnswerUpdateWithoutSubformFieldInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformFieldOpion?: SubformFieldOptionUpdateOneWithoutSubformFieldAnswerNestedInput
    claimant?: ClaimantUpdateOneRequiredWithoutSubformFieldAnswerNestedInput
    session?: CallSessionUpdateOneRequiredWithoutSubformFieldAnswerNestedInput
  }

  export type SubformFieldAnswerUncheckedUpdateWithoutSubformFieldInput = {
    id?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubformFieldAnswerCreateManySubformFieldOpionInput = {
    id?: number
    subformFieldId: number
    claimantId: number
    sessionId: number
    value?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type SubformFieldAnswerUpdateWithoutSubformFieldOpionInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    subformField?: SubformFieldUpdateOneRequiredWithoutSubformFieldAnswerNestedInput
    claimant?: ClaimantUpdateOneRequiredWithoutSubformFieldAnswerNestedInput
    session?: CallSessionUpdateOneRequiredWithoutSubformFieldAnswerNestedInput
  }

  export type SubformFieldAnswerUncheckedUpdateWithoutSubformFieldOpionInput = {
    id?: IntFieldUpdateOperationsInput | number
    subformFieldId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionRuleCreateManyOptionInput = {
    id?: number
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    questionAnswerRefId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type AnswerCreateManyOptionInput = {
    id?: number
    questionId: number
    claimantId: number
    sessionId: number
    value?: string | null
    created?: Date | string
    updated?: Date | string
  }

  export type OptionRuleUpdateWithoutOptionInput = {
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    questionAnswerRef?: QuestionUpdateOneWithoutOptionRuleNestedInput
    function?: FunctionUpdateOneWithoutOptionRuleNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutOptionRuleNestedInput
  }

  export type OptionRuleUncheckedUpdateWithoutOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionRuleUncheckedUpdateManyWithoutRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerUpdateWithoutOptionInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutAnswersNestedInput
    claimant?: ClaimantUpdateOneRequiredWithoutAnswersNestedInput
    callSession?: CallSessionUpdateOneRequiredWithoutAnswerNestedInput
  }

  export type AnswerUncheckedUpdateWithoutOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    claimantId?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionRuleCreateManyFunctionInput = {
    id?: number
    questionId?: number | null
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    questionAnswerRefId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type OptionRuleCreateManyFunctionInput = {
    id?: number
    optionId?: number | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    questionAnswerRefId?: number | null
    ssaStatusId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionRuleUpdateWithoutFunctionInput = {
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneWithoutRulesNestedInput
    questionAnswerRef?: QuestionUpdateOneWithoutQuestionAnswerRefNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutQuestionRuleNestedInput
  }

  export type QuestionRuleUncheckedUpdateWithoutFunctionInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionRuleUncheckedUpdateManyWithoutQuestionRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionRuleUpdateWithoutFunctionInput = {
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    option?: OptionUpdateOneWithoutRulesNestedInput
    questionAnswerRef?: QuestionUpdateOneWithoutOptionRuleNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutOptionRuleNestedInput
  }

  export type OptionRuleUncheckedUpdateWithoutFunctionInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimantCreateManyReferrerInput = {
    id?: number
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    ssaStatusId?: number | null
    created?: Date | string
    updated?: Date | string
  }

  export type ClaimantUpdateWithoutReferrerInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUpdateManyWithoutClaimantNestedInput
    answers?: AnswerUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutClaimantNestedInput
    ssaStatus?: SSAStatusUpdateOneWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUpdateManyWithoutClaimantNestedInput
  }

  export type ClaimantUncheckedUpdateWithoutReferrerInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUncheckedUpdateManyWithoutClaimantNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUncheckedUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUncheckedUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUncheckedUpdateManyWithoutClaimantNestedInput
  }

  export type ClaimantUncheckedUpdateManyWithoutClaimantInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ssaStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimantCreateManySsaStatusInput = {
    id?: number
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    phone?: string | null
    email?: string | null
    referrerId?: number | null
    created?: Date | string
    updated?: Date | string
  }

  export type OptionRuleCreateManySsaStatusInput = {
    id?: number
    optionId?: number | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    questionAnswerRefId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type QuestionRuleCreateManySsaStatusInput = {
    id?: number
    questionId?: number | null
    optout?: boolean | null
    type: RuleType
    value?: number | null
    operator?: OperatorOption | null
    comparisonValue?: string | null
    functionId?: number | null
    questionAnswerRefId?: number | null
    isReferrerPayType?: ReferrerPayTypes | null
    created?: Date | string
    updated?: Date | string
  }

  export type ClaimantUpdateWithoutSsaStatusInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUpdateManyWithoutClaimantNestedInput
    answers?: AnswerUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUpdateManyWithoutClaimantNestedInput
    referrer?: ReferrerUpdateOneWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUpdateManyWithoutClaimantNestedInput
  }

  export type ClaimantUncheckedUpdateWithoutSsaStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableIntFieldUpdateOperationsInput | number | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    cursor?: CursorUncheckedUpdateManyWithoutClaimantNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutClaimantNestedInput
    touchPoint?: TouchPointUncheckedUpdateManyWithoutClaimantNestedInput
    callSessions?: CallSessionUncheckedUpdateManyWithoutClaimantNestedInput
    subformFieldAnswer?: SubformFieldAnswerUncheckedUpdateManyWithoutClaimantNestedInput
    VoiceMail?: VoiceMailUncheckedUpdateManyWithoutClaimantNestedInput
  }

  export type OptionRuleUpdateWithoutSsaStatusInput = {
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    option?: OptionUpdateOneWithoutRulesNestedInput
    questionAnswerRef?: QuestionUpdateOneWithoutOptionRuleNestedInput
    function?: FunctionUpdateOneWithoutOptionRuleNestedInput
  }

  export type OptionRuleUncheckedUpdateWithoutSsaStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionRuleUpdateWithoutSsaStatusInput = {
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneWithoutRulesNestedInput
    questionAnswerRef?: QuestionUpdateOneWithoutQuestionAnswerRefNestedInput
    function?: FunctionUpdateOneWithoutQuestionRuleNestedInput
  }

  export type QuestionRuleUncheckedUpdateWithoutSsaStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    optout?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumRuleTypeFieldUpdateOperationsInput | RuleType
    value?: NullableIntFieldUpdateOperationsInput | number | null
    operator?: NullableEnumOperatorOptionFieldUpdateOperationsInput | OperatorOption | null
    comparisonValue?: NullableStringFieldUpdateOperationsInput | string | null
    functionId?: NullableIntFieldUpdateOperationsInput | number | null
    questionAnswerRefId?: NullableIntFieldUpdateOperationsInput | number | null
    isReferrerPayType?: NullableEnumReferrerPayTypesFieldUpdateOperationsInput | ReferrerPayTypes | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}